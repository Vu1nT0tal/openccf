[
    {
        "url": "https://doi.org/10.1109/TrustCom50675.2020.00049",
        "title": "Program Slice based Vulnerable Code Clone Detection",
        "authors": "Xiaonan Song, Aimin Yu, Haibo Yu, Shirun Liu, Xin Bai, Lijun Cai, Dan Meng",
        "abstract": "Vulnerabilities in software will not only lead to security problems of the software itself, but also cause the spread of vulnerabilities through code clones. It is important to detect and locate vulnerabilities among the source code to facilitate the fix. Although many methods are proposed to detect code clones in source code, most of them fail to detect code clones that involve statement addition and deletion effectively or are not suitable for vulnerability detection. In this paper, we propose a method that can detect vulnerabilities caused by code clones. Program slices are used to filter statements that are not related to vulnerabilities and extract important vulnerable statements in function. Hash function and bitvector are applied to improve efficiency during the detection. The results are displayed in html, among which the vulnerable statements are highlighted to help subsequent patching work. Our method is evaluated on open source software (Openssl, Linux Kernel, FFmpeg and QEMU). The results of experiments show that our method detects 12.72% more vulnerable clones in acceptable time compared with Vuddy, proving the effectiveness of our method.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "软件中的漏洞不仅会导致软件本身的安全问题，还会通过代码克隆造成漏洞的传播。检测和定位源代码中的漏洞以便于修复是很重要的。虽然很多方法被提出来检测源代码中的代码克隆，但是大多数方法都不能有效地检测包含语句添加和删除的代码克隆，或者不适合漏洞检测。在本文中，我们提出了一种可以检测由代码克隆引起的漏洞的方法。程序切片用于过滤与漏洞无关的语句，提取函数中重要的易受攻击语句。哈希函数和位向量的应用提高了检测的效率。结果显示在html中，其中易受攻击的语句被突出显示，以帮助后续的修补工作。我们的方法在开源软件(Openssl、Linux内核、FFmpeg和QEMU)上进行评估。实验结果表明，与Vuddy相比，我们的方法在可接受的时间内多检测了12.72%的脆弱克隆，证明了我们方法的有效性。",
        "title_zh": "基于程序切片的易受攻击代码克隆检测",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/trustcom/trustcom2020.html",
        "conf_title": "19th TrustCom 2020: Guangzhou, China",
        "conf_url": "https://doi.org/10.1109/TrustCom50675.2020",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TrustCom50675.2020.00180",
        "title": "SecureESFS: Sharing Android External Storage Files in A Securer Way",
        "authors": "Shan Liang, Yuewu Wang, Lingguang Lei, Jiwu Jing, Quan Zhou",
        "abstract": "As an essential component on Android devices, External Storage is frequently used for sharing files between different apps. Therefore, compared to Internal Storage, the access control on the External Storage is usually very loose. However, a lot of sensitive files might be stored on the External Storage, which makes it an attractive target for the attackers. Since Android 10, a security mechanism named Scoped Storage has been introduced to protect the sensitive files on the External Storage. However, this mechanism is mainly used to protect the app-specific files, and can't support the sharing of sensitive files between trusted apps in a secure and flexible way. In this paper, we present a secure External Storage sensitive file sharing solution named SecureESFS. It first extends a Linux kernel security mechanism named ACL on the SDCardFS filesystem to protect the External Storage. With different ACL policy settings, the user can dynamically share sensitive files between trusted apps according to specific business needs. We also enforce the integrity protection on the ACL policies by checking the hash message authentication codes (HMAC) of these policies. Moreover, we design a transparent encryption mechanism in SecureESFS to protect the sensitive files on the External Storage, when the Android devices are physically accessed by the attackers, such as removing the SD card. For versions lower than Android 10, SecureESFS can provide independent protection and secure sharing for the sensitive files on the External Storage. For versions higher than Android 10, SecureESFS can achieve the secure sharing of sensitive files while Scoped Storage provides protection for the app-specific files. SecureESFS may also be used to enhance the security of the Scoped Storage mechanism. Experiments conducted on a prototype show that SecureESFS works well and incurs acceptable overhead.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "作为Android设备上的一个重要组件，外部存储经常用于在不同的应用程序之间共享文件。因此，与内部存储相比，外部存储的访问控制通常非常松散。然而，大量敏感文件可能存储在外部存储器上，这使得它成为攻击者的诱人目标。从Android 10开始，引入了名为Scoped Storage的安全机制来保护外部存储上的敏感文件。然而，这种机制主要用于保护特定于app的文件，不能以安全和灵活的方式支持可信app之间的敏感文件共享。在本文中，我们提出了一个名为SecureESFS的安全外部存储敏感文件共享解决方案。它首先在SDCardFS文件系统上扩展了一个名为ACL的Linux内核安全机制来保护外部存储。通过不同的ACL策略设置，用户可以根据特定的业务需求在受信任的应用程序之间动态共享敏感文件。我们还通过检查ACL策略的哈希消息认证码(HMAC)来加强这些策略的完整性保护。此外，我们在SecureESFS中设计了一个透明的加密机制，当攻击者物理访问Android设备时，例如移除SD卡，可以保护外部存储上的敏感文件。对于低于Android 10的版本，SecureESFS可以为外部存储上的敏感文件提供独立保护和安全共享。对于高于Android 10的版本，SecureESFS可以实现敏感文件的安全共享，而作用域存储则为应用程序特定的文件提供保护。SecureESFS还可用于增强作用域存储机制的安全性。在原型上进行的实验表明，SecureESFS运行良好，开销也可以接受。",
        "title_zh": "SecureESFS:以更安全的方式共享Android外部存储文件",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/trustcom/trustcom2020.html",
        "conf_title": "19th TrustCom 2020: Guangzhou, China",
        "conf_url": "https://doi.org/10.1109/TrustCom50675.2020",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TrustCom/BigDataSE.2019.00011",
        "title": "Building Trust in Container Environment",
        "authors": "Yunlong Guo, Aimin Yu, Xiaoli Gong, Lixin Zhao, Lijun Cai, Dan Meng",
        "abstract": "Container technology is an emerging virtualization technology that is more efficient and lightweight than virtual machines. This technology is becoming increasingly popular. However, containers are vulnerable to attackers due to various security issues. It is necessary to build trust between users and their containers, as well as between a remote party and the container in the untrusted container environment. The existing trusted computing technologies build a trust chain from hardware to the running operating system. In this paper, we extend the trust chain to containers and build trust in the container environment. We first boot the computer to a trusted operating system. The trusted OS then verifies programs running on the OS to improve security. We design the well-formed signature list to help users to authorize container executables and modify the Linux kernel to verify executables running in containers. Therefore, the user is able to control what programs can run in his containers and trust the containers. Our approach generates a measurement list and creates a vTPM for each container. A remote party can request the measurement list based on our container state challenge protocol. As a result, a remote party is able to know the container state and decide whether to trust the container. We also implement the executables measurement and verification mechanism and evaluate the performance. The results show the container start delay is no more than 3% of the normal container start time and the overhead to measure and verify executables is no more than 1 us in most cases, which is reasonably efficient.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "容器技术是一种新兴的虚拟化技术，比虚拟机更高效、更轻量级。这项技术越来越受欢迎。然而，由于各种安全问题，容器容易受到攻击者的攻击。有必要在用户和他们的容器之间，以及在不可信容器环境中的远程方和容器之间建立信任。现有的可信计算技术建立了从硬件到运行的操作系统的信任链。在本文中，我们将信任链扩展到容器，并在容器环境中建立信任。我们首先将计算机引导至可信的操作系统。然后，可信操作系统验证操作系统上运行的程序，以提高安全性。我们设计了格式良好的签名列表来帮助用户授权容器可执行文件，并修改Linux内核来验证容器中运行的可执行文件。因此，用户能够控制哪些程序可以在他的容器中运行，并信任这些容器。我们的方法生成一个测量列表，并为每个容器创建一个vTPM。远程方可以基于我们的容器状态询问协议请求测量列表。结果，远程方能够知道容器状态并决定是否信任该容器。我们还实现了可执行文件的测量和验证机制，并对性能进行了评估。结果表明，容器启动延迟不超过正常容器启动时间的3%,测量和验证可执行文件的开销在大多数情况下不超过1 us，这是相当有效的。",
        "title_zh": "在容器环境中建立信任",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/trustcom/trustcom2019.html",
        "conf_title": "18th TrustCom / 13th BigDataSE 2019: Rotorua, New Zealand",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/8883860/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TrustCom.2016.0241",
        "title": "The Design and Implementation of a Lightweight Management Framework for Non-volatile Memory",
        "authors": "Zheng Zhang, Dan Feng, Jianxi Chen, Ya Yu, Jing Zeng",
        "abstract": "The disk is always the bottleneck of storage system for decades. The emergency of non-volatile memory, such as Phase Change Memory, Spin-Transfer Torque and Memristors provides an opportunity to improve the performance of storage system due to its comparable access speed like DRAM. However, existing storage systems are designed and optimized for disk, directly replacing disk with the non-volatile memory will make the software latency become the major bottleneck. In order to address the problem and to improve the performance of non-volatile memory based system, we design and implement a lightweight management framework for non-volatile memory. The framework is composed of a user-level library and a kernel-level file system for non-volatile memory, called NVMFS. Unlike current storage systems, the framework provides a relative short I/O path and a dedicated file system for non-volatile memory. The upper-level applications can load library dynamically in the framework to access NVMFS on non-volatile memory. We have implemented the prototype of the framework in Linux kernel and evaluated the performance of the framework through the standard benchmark.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "几十年来，磁盘一直是存储系统的瓶颈。相变存储器、自旋转移矩和忆阻器等非易失性存储器的出现，由于其可媲美DRAM的存取速度，为提高存储系统的性能提供了契机。然而，现有的存储系统是为磁盘设计和优化的，直接用非易失性存储器代替磁盘会使软件延迟成为主要瓶颈。为了解决这个问题并提高基于非易失性存储器的系统的性能，我们设计并实现了一个轻量级的非易失性存储器管理框架。该框架由一个用户级库和一个用于非易失性内存的内核级文件系统组成，称为NVMFS。与当前的存储系统不同，该框架为非易失性存储器提供了相对较短的I/O路径和专用文件系统。上层应用程序可以在框架中动态加载库，以访问非易失性存储器上的NVMFS。我们在Linux内核中实现了该框架的原型，并通过标准基准测试对该框架的性能进行了评估。",
        "title_zh": "一种轻量级非易失性存储器管理框架的设计与实现",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/trustcom/trustcom2016.html",
        "conf_title": "TrustCom/BigDataSE/ISPA 2016: Tianjin, China",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/7845250/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1007/978-3-030-80825-9_13",
        "title": "Introspect Virtual Machines Like It Is the Linux Kernel!",
        "authors": "Ahmed Abdelraoof, Benjamin Taubmann, Thomas Dangl, Hans P. Reiser",
        "abstract": "",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "",
        "title_zh": "内省的虚拟机就像Linux内核一样！",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dimva/dimva2021.html",
        "conf_title": "DIMVA 2021: Virtual Event",
        "conf_url": "https://doi.org/10.1007/978-3-030-80825-9",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1007/978-3-031-35504-2_10",
        "title": "Extended Abstract: Towards Reliable and Scalable Linux Kernel CVE Attribution in Automated Static Firmware Analyses",
        "authors": "René Helmke, Johannes vom Dorp",
        "abstract": "—In vulnerability assessments, software component- based CVE attribution is a common method to identify possibly vulnerable systems at scale. However, such version-centric ap- proaches yield high false-positive rates for binary distributed Linux kernels in ﬁrmware images. Not ﬁltering included vul- nerable components is a reason for unreliable matching, as heterogeneous hardware properties, modularity, and numerous development streams result in a plethora of vendor-customized builds. To make a step towards increased result reliability while retaining scalability of the analysis method, we enrich version-based CVE matching with kernel-speciﬁc build data from binary images using automated static ﬁrmware analysis. We open source an attribution pipeline that gathers kernel conﬁguration and target architecture to dry build the present kernel version and ﬁlter CVEs based on affected ﬁle references in record descriptions. In a case study with 127 router ﬁrmware images, we show that in comparison to naive version matching, our approach identiﬁes 68% of all version CVE matches as false-positives and reliably removes them from the result set. For 12% of all matches it provides additional evidence of issue applicability. For 19.4%, our approach does not improve reliability because required ﬁle references in CVEs are missing.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "扩展摘要:在自动化静态固件分析中实现可靠和可扩展的Linux内核CVE属性",
        "abstract_zh": "—在漏洞评估中，基于软件组件的CVE属性是大规模识别可能存在漏洞的系统的常用方法。然而，这种以版本为中心的方法对于二进制分布式Linux内核在固件映像中会产生很高的误报率。不过滤包含的易受攻击组件是不可靠匹配的一个原因，因为异构硬件属性、模块化和众多开发流会导致过多的供应商定制版本。为了在提高结果可靠性的同时保持分析方法的可扩展性，我们使用自动化静态固件分析，通过来自二进制图像的内核特定构建数据，丰富了基于版本的CVE匹配。我们开源了一个属性管道，收集内核配置和目标架构，以干式构建当前内核版本，并根据记录描述中受影响的文件引用过滤cv。在对127个路由器固件映像的案例研究中，我们发现，与简单的版本匹配相比，我们的方法将所有版本CVE匹配中的68%识别为误报，并可靠地将其从结果集中删除。对于12%的匹配，它提供了问题适用性的额外证据。对于19.4%，我们的方法没有提高可靠性，因为CVE中所需的文件引用丢失了。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dimva/dimva2023.html",
        "conf_title": "20th DIMVA 2023:\nHamburg, Germany",
        "conf_url": "https://doi.org/10.1007/978-3-031-35504-2",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/DSN-W50199.2020.00022",
        "title": "Approaching certification of complex systems",
        "authors": "Nicholas Mc Guire, Imanol Allende",
        "abstract": "Safety being a system property and not an element property means that novel systems need to be treated as ”oneof”. Only after we gained adequate experience in context of a few (probably dozen) such complex system will common ”baseline” argument emerge. Trying to build ”out-of-context” elements certainly is either not feasible at all or would, if feasible, not simplify anything, since all possible states would need to be considered. In the case of, for example, the Linux kernel, the sheer amount of such states would completely overstrain such an approach. Applying route 3S assessment of non-compliant development while managing the extensive tailoring of measures, techniques and processes, seems to us to be the most promising path towards for safe complex systems.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "安全是一个系统属性，而不是一个元素属性，这意味着新系统需要被视为“其中之一”。只有当我们在几个(可能十几个)这样的复杂系统中获得足够的经验后，常见的“基线”论点才会出现。试图构建“脱离上下文”的元素肯定是根本不可行的，或者即使可行，也不会简化任何事情，因为需要考虑所有可能的状态。例如，在Linux内核的情况下，这种状态的绝对数量将完全超过这种方法的负荷。在管理措施、技术和过程的大规模定制的同时，应用路线3S评估不合规开发，在我们看来是实现安全复杂系统的最有希望的途径。",
        "title_zh": "复杂系统认证的探讨",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dsn/dsn2020w.html",
        "conf_title": "50th DSN 2020: Valencia, Spain - Workshops",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/9145942/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/DSN48063.2020.00021",
        "title": "KShot: Live Kernel Patching with SMM and SGX",
        "authors": "Lei Zhou, Fengwei Zhang, Jinghui Liao, Zhenyu Ning, Jidong Xiao, Kevin Leach, Westley Weimer, Guojun Wang",
        "abstract": "Live kernel patching is an increasingly common trend in operating system distributions, enabling dynamic updates to include new features or to fix vulnerabilities without having to reboot the system. Patching the kernel at runtime lowers downtime and reduces the loss of useful state from running applications. However, existing kernel live patching techniques (1) rely on specific support from the target operating system, and (2) admit patch failures resulting from kernel faults. We present KSHOT, a kernel live patching mechanism based on x86 SMM and Intel SGX that focuses on patching Linux kernel security vulnerabilities. Our patching processes are protected by hardware-assisted Trusted Execution Environments. We demonstrate that our technique can successfully patch vulnerable kernel functions at the binary-level without support from the underlying OS and regardless of whether the kernel patching mechanism is compromised. We demonstrate the applicability of KSHOT by successfully patching 30 critical indicative kernel vulnerabilities.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "实时内核补丁是操作系统发行版中越来越普遍的趋势，允许动态更新以包括新功能或修复漏洞，而无需重启系统。在运行时修补内核可以减少停机时间，并减少运行应用程序时有用状态的丢失。然而，现有的内核实时修补技术(1)依赖于来自目标操作系统的特定支持，以及(2)允许由内核故障导致的修补失败。我们介绍了KSHOT，这是一种基于x86 SMM和英特尔SGX的内核实时补丁机制，专注于修补Linux内核安全漏洞。我们的修补流程受到硬件辅助的可信执行环境的保护。我们证明了我们的技术可以成功地在二进制级别上修补易受攻击的内核函数，而无需底层操作系统的支持，并且不管内核修补机制是否受到损害。我们通过成功修补30个关键的指示性内核漏洞来证明KSHOT的适用性。",
        "title_zh": "KShot:SMM和SGX的实时内核补丁",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dsn/dsn2020.html",
        "conf_title": "50th DSN 2020: Valencia, Spain",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/9145511/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/DSN-W52860.2021.00028",
        "title": "Automatically Constructing Peer Slices via Semanticand Context-Aware Security Checks in the Linux Kernel",
        "authors": "Yongzhi Liu, Xiarun Chen, Zhou Yang, Weiping Wen",
        "abstract": "OS kernels enforce many security checks to validate system states. We observe that paths containing security checks are in fact very informative in inferring critical semantics in OS kernel. In particular, Such slices are valuable for detecting kernel semantic bugs because understanding semantics is typically required by the detection. However, there are few studies that address security checks, and constructing these slices is challenging due to not only a lack of clear criteria but also the large and complex OS. In this paper, combining security checks with program slicing, we first systematically study security check peer slices and propose an automatic approach to construct security check peer slices in OS kernel. Using an inter-procedural, semantic- and context-aware analysis, we can find slices sharing similar semantics in similar contexts. Based on the information offered by security check peer slices, we then introduce the Scenarios for semantic vulnerability detection by security check peer slices: missing security check and inaccurate security check. The evaluation results show that our approach can accurately constructing security check peer slices.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "OS内核执行许多安全检查来验证系统状态。我们观察到，包含安全检查的路径事实上在推断OS内核中的关键语义方面非常有用。特别是，这样的切片对于检测内核语义错误是有价值的，因为理解语义通常是检测所需要的。然而，很少有研究涉及安全检查，构建这些切片具有挑战性，不仅因为缺乏明确的标准，而且因为操作系统庞大而复杂。本文将安全检查与程序切片相结合，首先系统地研究了安全检查对等切片，提出了一种在操作系统内核中自动构造安全检查对等切片的方法。使用过程间、语义和上下文感知分析，我们可以找到在相似上下文中共享相似语义的切片。基于安全检查对等切片提供的信息，我们介绍了安全检查对等切片进行语义漏洞检测的场景:安全检查缺失和安全检查不准确。评估结果表明，该方法能够准确地构造安全检查对等切片。",
        "title_zh": "在Linux内核中通过语义和上下文感知安全检查自动构建对等切片",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dsn/dsn2021w.html",
        "conf_title": "51st DSN 2021: Taipei, Taiwan - Workshops",
        "conf_url": "https://doi.org/10.1109/DSN-W52860.2021",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/DSN-W54100.2022.00024",
        "title": "A Dataset of Linux Failure Data for Dependability Evaluation and Improvement",
        "authors": "João R. Campos, Ernesto Costa, Marco Vieira",
        "abstract": "Software systems are now used to execute critical tasks on a daily basis. As a result, unhandled or uncontrolled failures at runtime may lead to non-negligible risks or losses. To mitigate this, considerable effort and resources have been dedicated to assessing and improving the dependability of such systems. However, researching novel techniques to develop more dependable systems requires access to rich and detailed data. As data from real systems are not typically available, researchers often look for alternative processes, such as fault injection, to generate realistic synthetic data. As this requires considerable effort and expertise, researchers frequently rely on outdated datasets or develop simplified processes to collect data, eventually compromising the validation and development of their methods. This paper presents, discusses, and makes available a large failure dataset collected from an up-to-date Linux kernel through fault injection. It provides a detailed characterization of the target system by continuously monitoring hundreds of system metrics and various system logs throughout the experiments. Ultimately, the goal is to provide a reliable, well-defined, and properly generated dataset that can be used to research techniques to support the development of more dependable systems.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "软件系统现在被用来执行日常的关键任务。因此，运行时未处理或未控制的故障可能会导致不可忽视的风险或损失。为了减轻这种情况，已经投入了相当多的努力和资源来评估和提高这种系统的可靠性。然而，研究新技术以开发更可靠的系统需要访问丰富和详细的数据。由于来自真实系统的数据通常不可用，研究人员经常寻找替代过程，如故障注入，以生成真实的合成数据。由于这需要相当大的努力和专业知识，研究人员经常依赖过时的数据集或开发简化的过程来收集数据，最终损害了他们方法的验证和开发。本文介绍、讨论并提供了一个通过故障注入从最新的Linux内核中收集的大型故障数据集。通过在整个实验过程中持续监控数百个系统指标和各种系统日志，它提供了目标系统的详细特征。最终，目标是提供一个可靠的、定义良好的、正确生成的数据集，该数据集可用于研究支持更可靠系统开发的技术。",
        "title_zh": "用于可信性评估和改进的Linux故障数据集",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dsn/dsn2022w.html",
        "conf_title": "52nd DSN 2022: Baltimore, MD, USA - Workshops",
        "conf_url": "https://doi.org/10.1109/DSN-W54100.2022",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/DSN.2019.00045",
        "title": "Tell Me More Than Just Assembly! Reversing Cyber-Physical Execution Semantics of Embedded IoT Controller Software Binaries",
        "authors": "Pengfei Sun, Luis Garcia, Saman A. Zonouz",
        "abstract": "The safety of critical cyber-physical IoT devices hinges on the security of their embedded software that implements control algorithms for monitoring and control of the associated physical processes, e.g., robotics and drones. Reverse engineering of the corresponding embedded controller software binaries enables their security analysis by extracting high-level, domain-specific, and cyber-physical execution semantic information from executables. We present MISMO, a domain-specific reverse engineering framework for embedded binary code in emerging cyber-physical IoT control application domains. The reverse engineering outcomes can be used for firmware vulnerability assessment, memory forensics analysis, targeted memory data attacks, or binary patching for dynamic selective memory protection (e.g., important control algorithm parameters). MISMO performs semantic-matching at an algorithmic level that can help with the understanding of any possible cyber-physical security flaws. MISMO compares low-level binary symbolic values and high-level algorithmic expressions to extract domain-specific semantic information for the binary's code and data. MISMO enables a finer-grained understanding of the controller by identifying the specific control and state estimation algorithms used. We evaluated MISMO on 2,263 popular firmware binaries by 30 commercial vendors from 6 application domains including drones, self-driving cars, smart homes, robotics, 3D printers, and the Linux kernel controllers. The results show that MISMO can accurately extract the algorithm-level semantics of the embedded binary code and data regions. We discovered a zero-day vulnerability in the Linux kernel controllers versions 3.13 and above.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "关键的网络物理物联网设备的安全性取决于其嵌入式软件的安全性，该软件实施控制算法来监控和控制相关的物理过程，例如机器人和无人机。相应嵌入式控制器软件二进制文件的逆向工程通过从可执行文件中提取高级、特定领域和网络物理执行语义信息来支持其安全性分析。我们提出了MISMO，这是一个针对新兴信息物理物联网控制应用领域的嵌入式二进制代码的特定领域逆向工程框架。逆向工程结果可用于固件脆弱性评估、存储器取证分析、有针对性的存储器数据攻击或用于动态选择性存储器保护的二进制修补(例如，重要的控制算法参数)。MISMO在算法层面执行语义匹配，这有助于理解任何可能的网络物理安全缺陷。MISMO比较低级二进制符号值和高级算法表达式，以提取二进制代码和数据的特定于领域的语义信息。MISMO通过识别所使用的特定控制和状态估计算法，能够更好地理解控制器。我们在来自6个应用领域的30家商业供应商的2，263个流行的固件二进制文件上评估了MISMO，包括无人机、自动驾驶汽车、智能家居、机器人、3D打印机和Linux内核控制器。结果表明，MISMO能够准确提取嵌入式二进制代码和数据区域的算法级语义。我们在Linux内核控制器版本3.13及更高版本中发现了一个零日漏洞。",
        "title_zh": "告诉我不仅仅是组装！逆转嵌入式物联网控制器软件二进制文件的信息物理执行语义",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dsn/dsn2019.html",
        "conf_title": "49th DSN 2019: Portland, OR, USA",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/8790390/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.ieeecomputersociety.org/10.1109/DSN-W.2018.00029",
        "title": "Towards Lightweight Temporal and Fault Isolation in Mixed-Criticality Systems with Real-Time Containers",
        "authors": "Marcello Cinque, Domenico Cotroneo",
        "abstract": "This paper introduces real-time containers as a lightweight solution, if compared to virtual machines, to achieve temporal and fault isolation in mixed-criticality systems. The paper presents a reference architecture and an initial prototype implementation of the concept, using Docker containers on top of a patched real-time Linux kernel.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "与虚拟机相比，本文介绍了实时容器作为一种轻量级解决方案，用于在混合临界系统中实现时间和故障隔离。本文给出了一个参考架构和这个概念的初始原型实现，在一个打补丁的实时Linux内核上使用Docker容器。",
        "title_zh": "具有实时容器的混合临界系统中的轻量级时间和故障隔离",
        "year": "2018",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dsn/dsn2018w.html",
        "conf_title": "48th DSN 2018: Luxembourg - Workshops",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/8415929/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/DSN-W.2016.50",
        "title": "Code Change History and Software Vulnerabilities",
        "authors": "Marcus Pianco, Baldoino Fonseca, Nuno Antunes",
        "abstract": "Usually, the most critical modules of the system receive extra attention. But even these modules might be too large to be thoroughly inspected so it is useful to know where to apply the majority of the efforts. Thus, knowing which code changes are more prone to contain vulnerabilities may allow security experts to concentrate on a smaller subset of submitted code changes. In this paper we discuss the change history of functions and its impact on the existence of vulnerabilities. For this, we analyzed the commit history of two software projects widely exposed to attacks (Mozilla and Linux Kernel). Starting from security bugs, we analyzed more than 95k functions (with and without vulnerabilities), and systematized the changes in each function according to a subset of the patterns described in the Orthogonal Defects Classification. The results show that the frequency of changes can allow to distinguish functions more prone to have vulnerabilities.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "通常，系统中最关键的模块会受到额外的关注。但是即使是这些模块也可能太大而无法彻底检查，所以知道在哪里应用大部分工作是有用的。因此，知道哪些代码更改更容易包含漏洞可以允许安全专家专注于提交的代码更改的较小子集。在本文中，我们讨论了函数的变化历史及其对漏洞存在的影响。为此，我们分析了两个容易受到攻击的软件项目(Mozilla和Linux内核)的提交历史。从安全漏洞开始，我们分析了超过95k个函数(有和没有漏洞)，并根据正交缺陷分类中描述的模式子集，将每个函数中的变化系统化。结果表明，改变的频率可以允许区分更容易有漏洞的功能。",
        "title_zh": "代码更改历史和软件漏洞",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dsn/dsn2016w.html",
        "conf_title": "46th DSN 2016: Toulouse, France - Workshops",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/7575326/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/DSN.2017.49",
        "title": "ContainerLeaks: Emerging Security Threats of Information Leakages in Container Clouds",
        "authors": "Xing Gao, Zhongshu Gu, Mehmet Kayaalp, Dimitrios Pendarakis, Haining Wang",
        "abstract": "Container technology provides a lightweight operating system level virtual hosting environment. Its emergence profoundly changes the development and deployment paradigms of multi-tier distributed applications. However, due to the incomplete implementation of system resource isolation mechanisms in the Linux kernel, some security concerns still exist for multiple containers sharing an operating system kernel on a multi-tenancy container cloud service. In this paper, we first present the information leakage channels we discovered that are accessible within the containers. Such channels expose a spectrum of system-wide host information to the containers without proper resource partitioning. By exploiting such leaked host information, it becomes much easier for malicious adversaries (acting as tenants in the container clouds) to launch advanced attacks that might impact the reliability of cloud services. Additionally, we discuss the root causes of the containers' information leakages and propose a two-stage defense approach. As demonstrated in the evaluation, our solution is effective and incurs trivial performance overhead.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "容器技术提供了一个轻量级的操作系统级虚拟主机环境。它的出现深刻地改变了多层分布式应用程序的开发和部署模式。然而，由于Linux内核中系统资源隔离机制的不完全实现，在多租户容器云服务上共享操作系统内核的多个容器仍然存在一些安全问题。在本文中，我们首先介绍了我们发现的可以在容器中访问的信息泄漏通道。这种通道将一系列系统范围的主机信息暴露给容器，而没有适当的资源划分。通过利用这种泄露的主机信息，恶意对手(作为容器云中的租户)更容易发起可能影响云服务可靠性的高级攻击。此外，我们讨论了容器信息泄漏的根本原因，并提出了一个两阶段的防御方法。正如评估中所展示的，我们的解决方案是有效的，并且产生了微不足道的性能开销。",
        "title_zh": "集装箱漏洞:集装箱云中信息泄漏的新兴安全威胁",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dsn/dsn2017.html",
        "conf_title": "47th DSN 2017: Denver, CO, USA",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/8019912/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/DSN.2017.62",
        "title": "JMake: Dependable Compilation for Kernel Janitors",
        "authors": "Julia Lawall, Gilles Muller",
        "abstract": "The Linux kernel is highly configurable, and thus, in principle, any line of code can be included or excluded from the compiled kernel based on configuration operations. Configurability complicates the task of a kernel janitor, who cleans up faults across the code base. A janitor may not be familiar with the configuration options that trigger compilation of a particular code line, leading him to believe that a fix has been compile-checked when this is not the case. We propose JMake, a mutation-based tool for signaling changed lines that are not subjected to the compiler. JMake shows that for most of the 12,000 file-modifying commits between Linux v4.3 and v4.4 the configuration chosen by the kernel allyesconfig option is sufficient, once the janitor chooses the correct architecture. For most commits, this check requires only 30 seconds or less. We then characterize the situations in which changed code is not subjected to compilation in practice.",
        "files": {
            "openAccessPdf": "https://hal.inria.fr/hal-01555711/file/jmake.pdf"
        },
        "abstract_zh": "Linux内核是高度可配置的，因此，原则上，任何一行代码都可以根据配置操作包含在编译后的内核中，或者从编译后的内核中排除。可配置性使内核管理员的任务变得复杂，他负责清理代码库中的错误。管理员可能不熟悉触发特定代码行编译的配置选项，导致他认为已经对某个修复进行了编译检查，而事实并非如此。我们提出了JMake，一种基于突变的工具，用于发出不服从编译器的变更行的信号。JMake表明，对于Linux v4.3和v4.4之间的12，000个文件修改提交中的大多数，一旦管理员选择了正确的架构，内核allyesconfig选项选择的配置就足够了。对于大多数提交，这种检查只需要30秒或更少。然后，我们描述了在实践中修改后的代码没有经过编译的情况。",
        "title_zh": "JMake:内核监控程序的可靠编译",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/dsn/dsn2017.html",
        "conf_title": "47th DSN 2017: Denver, CO, USA",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/8019912/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1007/978-3-030-95484-0_28",
        "title": "Diminisher: A Linux Kernel Based Countermeasure for TAA Vulnerability",
        "authors": "Ameer Hamza, Maria Mushtaq, Khurram Bhatti, David Novo, Florent Bruguier, Pascal Benoit",
        "abstract": "",
        "files": {
            "openAccessPdf": "https://hal.archives-ouvertes.fr/hal-03372868/file/CPS4CIP_2021_paper_3.pdf"
        },
        "abstract_zh": "",
        "title_zh": "减小器：基于Linux内核的TAA漏洞的对策",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/esorics/cicps2021.html",
        "conf_title": "CyberICPS/SECPRE/ADIoT/SPOSE/CPS4CIP/CDT&SECOMANE@ESORICS 2021: Darmstadt, Germany",
        "conf_url": "https://doi.org/10.1007/978-3-030-95484-0",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TDSC.2022.3165368",
        "title": "Automatic Permission Check Analysis for Linux Kernel",
        "authors": "Jinmeng Zhou, Tong Zhang, Wenbo Shen, Dongyoon Lee, Changhee Jung, Ahmed M. Azab, Ruowen Wang, Peng Ning, Kui Ren",
        "abstract": "Permission checks play an essential role in operating system security by providing access control to privileged functionalities. However, it is challenging for kernel developers to scalably verify the soundness of existing checks due to the large codebase and complexity of the kernel. In fact, Linux kernel contains millions of lines of code with hundreds of permission checks, and even worse, its complexity is fast-growing. This paper presents PeX, a static Permission check error detector for LinuX, which takes as input a kernel source code and reports any missing, inconsistent, and redundant permission checks. PeX uses KIRIN (Kernel InteRface based Indirect call aNalysis), a novel, precise, and scalable indirect call analysis technique. Over the interprocedural control flow graph built by KIRIN, PeX automatically identifies permission checks and infers the mappings between permission checks and privileged functions. For each privileged function, PeX examines all possible paths to the function to check if necessary permission checks are correctly enforced. We evaluated PeX on the latest stable Linux kernel v4.18.5 for three types of permission checks: Discretionary Access Controls (DAC), Capabilities, and Linux Security Modules (LSM). PeX reported 45 new permission check errors, 17 of which have been confirmed by the kernel developers.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "通过提供对特权功能的访问控制，权限检查在操作系统安全中起着重要的作用。然而，由于庞大的代码库和内核的复杂性，对于内核开发人员来说，可扩展地验证现有检查的合理性是一个挑战。事实上，Linux内核包含了数百万行代码和数百次权限检查，更糟糕的是，它的复杂性正在快速增长。本文介绍了用于LinuX的静态权限检查错误检测器PeX，它将内核源代码作为输入，并报告任何缺失、不一致和冗余的权限检查。PeX使用KIRIN(基于内核接口的间接调用分析)，这是一种新颖、精确且可扩展的间接调用分析技术。通过KIRIN构建的过程间控制流图，PeX自动识别权限检查，并推断权限检查和特权函数之间的映射。对于每个特权函数，PeX会检查该函数的所有可能路径，以检查是否正确实施了必要的权限检查。我们在最新稳定的Linux内核v4.18.5上评估了PeX的三种权限检查类型:自主访问控制(DAC)、功能和Linux安全模块(LSM)。PeX报告了45个新的权限检查错误，其中17个已被内核开发人员确认。",
        "title_zh": "Linux内核的自动许可检查分析",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/tdsc/tdsc20.html",
        "conf_title": "IEEE Transactions on Dependable and Secure Computing, Volume 20",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TDSC.2022.3193327",
        "title": "Hawkeye: Eliminating Kernel Address Leakage in Normal Data Flows",
        "authors": "Zeyu Mi, Zhi Guo, Fuqian Huang, Haibo Chen",
        "abstract": "The confidentiality of the operating system kernel addresses is crucial to keeping the kernel secure from malicious users. To avoid leaking this position, researchers have proposed various techniques to defeat the exploits of abnormal data flows embedded in the kernel's memory safety loopholes, such as uninitialized memory read and buffer over-reads. However, this is far from complete. The kernel address can be leaked even in normal data flows without exploiting memory safety loopholes. We have designed a static analysis tool named Hawkeye to fill the gap. It searches for kernel address leakages in normal data flows that reveal the kernel address clues. Hawkeye precisely identifies the kernel addresses with minimum manual annotation and scales to analyze the whole kernel source code. It requires nearly ten times fewer memory resources and 40 times less inspection time than the state-of-the-art tool that analyzes kernel address leakage. Hawkeye unveils hundreds of leakages in various versioned kernels. It has even discovered 20 bugs in the mainline Linux kernel with the kernel pointer hashing mechanism already deployed and three bugs in FreeBSD. All the corresponding patches have been accepted by the developers.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "鹰眼:消除正常数据流中的内核地址泄漏",
        "abstract_zh": "操作系统内核地址的机密性对于防止恶意用户攻击内核至关重要。为了避免泄露这一位置，研究人员提出了各种技术来击败嵌入在内核内存安全漏洞中的异常数据流的利用，如未初始化的内存读取和缓冲区过度读取。然而，这还远远没有完成。即使在没有利用内存安全漏洞的正常数据流中，内核地址也可能被泄漏。我们设计了一个名为鹰眼的静态分析工具来填补这一空白。它在正常数据流中搜索内核地址泄漏，从而揭示内核地址线索。Hawkeye通过最少的人工注释精确地识别内核地址，并扩展到分析整个内核源代码。与分析内核地址泄漏的最先进工具相比，它需要的内存资源少了近十分之一，检查时间少了40倍。鹰眼揭露了各种版本内核中的数百个漏洞。它甚至在已经部署了内核指针散列机制的主线Linux内核中发现了20个错误，在FreeBSD中发现了3个错误。所有相应的补丁都已被开发者接受。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/tdsc/tdsc20.html",
        "conf_title": "IEEE Transactions on Dependable and Secure Computing, Volume 20",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TDSC.2018.2879605",
        "title": "A Study on the Security Implications of Information Leakages in Container Clouds",
        "authors": "Xing Gao, Benjamin Steenkamer, Zhongshu Gu, Mehmet Kayaalp, Dimitrios Pendarakis, Haining Wang",
        "abstract": "Container technology provides a lightweight operating system level virtual hosting environment. Its emergence profoundly changes the development and deployment paradigms of multi-tier distributed applications. However, due to the incomplete implementation of system resource isolation mechanisms in the Linux kernel, some security concerns still exist for multiple containers sharing an operating system kernel on a multi-tenancy container-based cloud service. In this paper, we first present the information leakage channels we discovered that are accessible within containers. Such channels expose a spectrum of system-wide host information to containers without proper resource partitioning. By exploiting such leaked host information, it becomes much easier for malicious adversaries (acting as tenants in a container cloud) to launch attacks that might impact the reliability of cloud services. We demonstrate that the information leakage channels could be exploited to infer private data, detect and verify co-residence, build covert channels, and launch more advanced cloud-based attacks. We discuss the root causes of the containers’ information leakage and propose a two-stage defense approach. As demonstrated in the evaluation, our defense is effective and incurs trivial performance overhead.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "容器技术提供了一个轻量级的操作系统级虚拟主机环境。它的出现深刻地改变了多层分布式应用程序的开发和部署模式。然而，由于Linux内核中系统资源隔离机制的不完全实现，在基于多租户容器的云服务上共享操作系统内核的多个容器仍然存在一些安全问题。在本文中，我们首先介绍了我们发现的可在容器中访问的信息泄漏通道。这种通道将一系列系统范围的主机信息暴露给容器，而没有适当的资源划分。通过利用这种泄露的主机信息，恶意对手(作为容器云中的租户)更容易发起可能影响云服务可靠性的攻击。我们证明，信息泄漏通道可以被用来推断私人数据，检测和验证共存，建立隐蔽通道，并发起更高级的基于云的攻击。我们讨论了容器信息泄漏的根本原因，并提出了两阶段防御方法。如评估所示，我们的防御是有效的，并且产生了微不足道的性能开销。",
        "title_zh": "一项有关容器云中信息泄漏的安全含义的研究",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/tdsc/tdsc18.html",
        "conf_title": "IEEE Transactions on Dependable and Secure Computing, Volume 18",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TDSC.2019.2915829",
        "title": "KALD: Detecting Direct Pointer Disclosure Vulnerabilities",
        "authors": "Brian Belleville, Wenbo Shen, Stijn Volckaert, Ahmed M. Azab, Michael Franz",
        "abstract": "Modern operating system kernels deploy Kernel Address Space Layout Randomization (KASLR) to mitigate control-flow hijacking attacks. KASLR randomizes the base addresses of the kernel's code and data segments. However, it randomizes both with a single offset and does not randomize the internal layout of either of these segments, so relative addresses remain known to adversaries. If the kernel discloses a single code or global data pointer, an adversary can therefore infer the entire layout of the kernel's code segment and bypass KASLR. In this paper, we present Kernel Address Leak Detector (KALD), a tool that finds direct disclosure vulnerabilities by statically analyzing the kernel source code. KALD can analyze the source code of modern operating system kernels and find previously unreported leaks. KALD compiles a list of functions that can leak information to user-space accessible locations, and it uses the results of a points-to analysis to determine whether individual invocations of such functions can disclose kernel pointers. We show that KALD successfully detects several direct disclosure vulnerabilities in the Linux kernel and that it is flexible enough to be useful in practice.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "现代操作系统内核部署内核地址空间布局随机化(KASLR)来减轻控制流劫持攻击。KASLR将内核代码和数据段的基址随机化。但是，它用单个偏移量随机化两者，并且不随机化这些段中任何一个的内部布局，因此相对地址仍然为对手所知。如果内核公开了单个代码或全局数据指针，对手就可以推断出内核代码段的整个布局并绕过KASLR。在本文中，我们介绍了内核地址泄漏检测器(KALD)，这是一种通过静态分析内核源代码来发现直接泄漏漏洞的工具。KALD可以分析现代操作系统内核的源代码，并发现以前未报告的漏洞。KALD编译了一个函数列表，这些函数会将信息泄漏到用户空间可访问的位置，它使用指向分析的结果来确定对这些函数的单独调用是否会泄漏内核指针。我们证明了KALD成功地检测到了Linux内核中的几个直接泄漏漏洞，并且它足够灵活，在实践中非常有用。",
        "title_zh": "卡尔德：检测直接指针披露漏洞",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/tdsc/tdsc18.html",
        "conf_title": "IEEE Transactions on Dependable and Secure Computing, Volume 18",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TDSC.2019.2946816",
        "title": "CATTmew: Defeating Software-Only Physical Kernel Isolation",
        "authors": "Yueqiang Cheng, Zhi Zhang, Surya Nepal, Zhi Wang",
        "abstract": "All the state-of-the-art rowhammer attacks can break the MMU-enforced inter-domain isolation because the physical memory owned by each domain is adjacent to each other. To mitigate these attacks, physical domain isolation, introduced by CATT [7] , physically separates each domain by dividing the physical memory into multiple partitions and keeping each partition occupied by only one domain. CATT implemented physical kernel isolation as the first generic and practical software-only defense to protect kernel from being rowhammered as kernel is one of the most appealing targets. In this paper, we develop a novel exploit that could effectively defeat the CATT implementation and gain both root and kernel privileges, indicating that the physical kernel isolation is not secure in practice. Our exploit can work without exhausting the page cache or the system memory, or relying on the information of the virtual-to-physical address mapping. The exploit is motivated by our key observation that the modern OSes have double-owned kernel buffers (e.g., video buffers and SCSI Generic buffers) owned concurrently by the kernel and user domains. The existence of such buffers invalidates the physical separation enforced by CATT and makes the rowhammer-based attack possible again. Existing conspicuous rowhammer attacks achieving the root/kernel privilege escalation exhaust the page cache or even the whole system memory. Instead, we propose a new technique, named Memory Ambush. It is able to place the hammerable double-owned kernel buffers physically adjacent to the target objects (e.g., page tables) with only a small amount of memory. As a result, our exploit is stealthier and has fewer memory footprints. We also replace the inefficient rowhammer algorithm that blindly picks up addresses to hammer with an efficient one. Our algorithm selects suitable addresses based on an existing timing channel [31] . We implement our exploit on the Linux kernel version 4.10.0. Our experiment results indicate that a successful attack could be done within 1 minute. The occupied memory is as low as 88 MB.",
        "files": {
            "openAccessPdf": "http://arxiv.org/pdf/1802.07060"
        },
        "abstract_zh": "所有最新的rowhammer攻击都可以打破MMU强制的域间隔离，因为每个域拥有的物理内存彼此相邻。为了减少这些攻击，由CATT [7]引入的物理域隔离通过将物理内存划分为多个分区并保持每个分区仅被一个域占用来物理地分隔每个域。CATT实现了物理内核隔离，作为第一个通用和实用的纯软件防御，以保护内核免受行攻击，因为内核是最有吸引力的目标之一。在本文中，我们开发了一个新的漏洞，可以有效地击败CATT实现，并获得root和内核权限，这表明物理内核隔离在实践中是不安全的。我们的利用可以在不耗尽页面缓存或系统内存的情况下工作，或者依赖于虚拟到物理地址映射的信息。这种利用的动机是我们的关键观察，即现代操作系统具有由内核和用户域同时拥有的双重内核缓冲区(例如，视频缓冲区和SCSI通用缓冲区)。这种缓冲区的存在使CATT实施的物理隔离失效，并使基于rowhammer的攻击再次成为可能。实现根/内核权限提升的现有明显的行锤攻击耗尽了页面缓存甚至整个系统内存。取而代之的是，我们提出了一种新的技术，叫做内存埋伏。它能够将可锤化的双重拥有的内核缓冲区放置在仅具有少量存储器的目标对象(例如，页表)附近。因此，我们的漏洞利用更加隐蔽，占用的内存也更少。我们还用高效的rowhammer算法替换了低效的row hammer算法，该算法盲目地选取地址进行锤击。我们的算法基于现有的定时通道选择合适的地址[31]。我们在Linux内核版本4.10.0上实现了我们的利用。我们的实验结果表明，一次成功的攻击可以在1分钟内完成。占用内存低至88 MB。",
        "title_zh": "CATTMEW：击败仅软件的物理内核隔离",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/tdsc/tdsc18.html",
        "conf_title": "IEEE Transactions on Dependable and Secure Computing, Volume 18",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP46214.2022.9833802",
        "title": "SpecHammer: Combining Spectre and Rowhammer for New Speculative Attacks",
        "authors": "Youssef Tobah, Andrew Kwong, Ingab Kang, Daniel Genkin, Kang G. Shin",
        "abstract": "The recent Spectre attacks have revealed how the performance gains from branch prediction come at the cost of weakened security. Spectre Variant 1 (v1) shows how an attacker-controlled variable passed to speculatively executed lines of code can leak secret information to an attacker. Numerous defenses have since been proposed to prevent Spectre attacks, each attempting to block all or some of the Spectre variants. In particular, defenses using taint-tracking are claimed to be the only way to protect against all forms of Spectre v1. However, we show that the defenses proposed thus far can be bypassed by combining Spectre with the well-known Rowhammer vulnerability. By using Rowhammer to modify victim values, we relax the requirement that the attacker needs to share a variable with the victim. Thus, defenses that rely on this requirement, such as taint-tracking, are no longer effective. Furthermore, without this crucial requirement, the number of gadgets that can potentially be used to launch a Spectre attack increases dramatically; those present in Linux kernel version 5.6 increases from about 100 to about 20,000 via Rowhammer bit-flips. Attackers can use these gadgets to steal sensitive information such as stack cookies or canaries, or use new triple gadgets to read any address in memory. We demonstrate two versions of the combined attack on example victims in both user and kernel spaces, showing the attack’s ability to leak sensitive data.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "最近的Spectre攻击揭示了分支预测带来的性能提升是如何以削弱安全性为代价的。Spectre Variant 1 (v1)展示了攻击者控制的变量如何传递给推测性执行的代码行，从而将秘密信息泄露给攻击者。此后，人们提出了许多防御措施来防止Spectre攻击，每种措施都试图阻止所有或部分Spectre变种。特别是，使用污点跟踪的防御被认为是抵御所有形式的Spectre v1的唯一方法。然而，我们表明，目前提出的防御措施可以通过将Spectre与众所周知的Rowhammer漏洞相结合来绕过。通过使用Rowhammer修改受害者值，我们放宽了攻击者需要与受害者共享一个变量的要求。因此，依赖于这种需求的防御，比如污点跟踪，不再有效。此外，如果没有这一关键要求，可能被用来发动幽灵攻击的小工具的数量会急剧增加；通过Rowhammer位翻转，Linux内核版本5.6中的内存从大约100个增加到大约20，000个。攻击者可以使用这些小工具来窃取敏感信息，如堆栈cookies或金丝雀，或者使用新的三重小工具来读取内存中的任何地址。我们在用户和内核空间展示了对示例受害者的组合攻击的两个版本，展示了攻击泄漏敏感数据的能力。",
        "title_zh": "SpecHammer:结合Spectre和Rowhammer进行新的投机性攻击",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2022.html",
        "conf_title": "43rd SP 2022: San Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP46214.2022",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP46214.2022.9833695",
        "title": "IRQDebloat: Reducing Driver Attack Surface in Embedded Devices",
        "authors": "Zhenghao Hu, Brendan Dolan-Gavitt",
        "abstract": "Embedded and IoT devices often come with a wide range of hardware functionality, but any particular end user may only use some small subset of these features. However, even unused hardware features are accompanied by potentially buggy driver code, which increases the attack surface of the device. In this paper, we introduce IRQDebloat, a system for disabling unwanted hardware features through automated firmware rewriting. Building on the insight that external inputs to the system are typically delivered through interrupt requests (IRQs), IRQDebloat systematically explores the interrupt handling code in the target firmware, identifies the handler function for each peripheral, and finally rewrites target firmware to disable the handlers that correspond to undesired hardware features. In our experiments we demonstrate IRQDebloat’s effectiveness and generality by identifying IRQ handlers across four different operating systems (Linux, FreeBSD, VxWorks, and RiscOS) and seven different embedded platforms, and disabling selected peripherals on real-world hardware (a Raspberry Pi and a Valve Steam Link). On the Steam Link, we survey the attack surface and find that disabling selected peripherals could block up to 44 CVEs found in the Linux kernel over the past five years.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "嵌入式和物联网设备通常具有广泛的硬件功能，但任何特定的最终用户可能只会使用其中的一小部分功能。然而，即使是未使用的硬件功能也伴随着潜在的错误驱动程序代码，这增加了设备的攻击面。在本文中，我们介绍了IRQDebloat，一个通过自动固件重写来禁用不需要的硬件功能的系统。基于对系统外部输入通常通过中断请求(IRQ)传递的认识，IRQDebloat系统地探索目标固件中的中断处理代码，识别每个外设的处理程序功能，并最终重写目标固件以禁用与不需要的硬件特性相对应的处理程序。在我们的实验中，我们通过在四个不同的操作系统(Linux、FreeBSD、VxWorks和RiscOS)和七个不同的嵌入式平台上识别IRQ处理程序，并在现实世界的硬件上禁用选定的外设(一个Raspberry Pi和一个Valve Steam Link)，来展示IRQDebloat的有效性和通用性。在Steam链接上，我们调查了攻击面，发现禁用选定的外设可以阻止过去五年中在Linux内核中发现的多达44个CVE。",
        "title_zh": "IRQDebloat:减少嵌入式设备中的驱动攻击面",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2022.html",
        "conf_title": "43rd SP 2022: San Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP46214.2022",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP46214.2022.9833683",
        "title": "GREBE: Unveiling Exploitation Potential for Linux Kernel Bugs",
        "authors": "Zhenpeng Lin, Yueqi Chen, Yuhang Wu, Dongliang Mu, Chensheng Yu, Xinyu Xing, Kang Li",
        "abstract": "Nowadays, dynamic testing tools have significantly expedited the discovery of bugs in the Linux kernel. When unveiling kernel bugs, they automatically generate reports, specifying the errors the Linux encounters. The error in the report implies the possible exploitability of the corresponding kernel bug. As a result, many security analysts use the manifested error to infer a bug’s exploitability and thus prioritize their exploit development effort. However, using the error in the report, security researchers might underestimate a bug’s exploitability. The error exhibited in the report may depend upon how the bug is triggered. Through different paths or under different contexts, a bug may manifest various error behaviors implying very different exploitation potentials. This work proposes a new kernel fuzzing technique to explore all the possible error behaviors that a kernel bug might bring about. Unlike conventional kernel fuzzing techniques concentrating on kernel code coverage, our fuzzing technique is more directed towards the buggy code fragment. It introduces an object-driven kernel fuzzing technique to explore various contexts and paths to trigger the reported bug, making the bug manifest various error behaviors. With the newly demonstrated errors, security researchers could better infer a bug’s possible exploitability. To evaluate our proposed technique’s effectiveness, efficiency, and impact, we implement our fuzzing technique as a tool GREBE and apply it to 60 real-world Linux kernel bugs. On average, GREBE could manifest 2+ additional error behaviors for each of the kernel bugs. For 26 kernel bugs, GREBE discovers higher exploitation potential. We report to kernel vendors some of the bugs – the exploitability of which was wrongly assessed and the corresponding patch has not yet been carefully applied – resulting in their rapid patch adoption.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "如今，动态测试工具极大地加快了Linux内核中错误的发现。当发现内核错误时，它们会自动生成报告，指出Linux遇到的错误。报告中的错误意味着相应的内核缺陷可能被利用。因此，许多安全分析师使用明显的错误来推断bug的可利用性，从而确定他们开发工作的优先级。然而，利用报告中的错误，安全研究人员可能会低估漏洞的可利用性。报告中显示的错误可能取决于错误的触发方式。通过不同的路径或在不同的上下文中，一个bug可能表现出各种错误行为，暗示着非常不同的利用潜力。这项工作提出了一种新的内核模糊化技术，以探索内核缺陷可能带来的所有可能的错误行为。与传统的关注内核代码覆盖的内核模糊化技术不同，我们的模糊化技术更多的是针对有缺陷的代码片段。它引入了一种对象驱动的内核模糊化技术，探索各种上下文和路径来触发所报告的bug，使bug表现出各种错误行为。有了新发现的错误，安全研究人员可以更好地推断出漏洞可能被利用的可能性。为了评估我们提出的技术的有效性、效率和影响，我们将我们的模糊化技术实现为一个工具GREBE，并将其应用于60个真实世界的Linux内核错误。平均来说，对于每个内核错误，GREBE可以表现出2+个额外的错误行为。对于26个内核错误，GREBE发现了更高的利用潜力。我们向内核供应商报告了一些错误——错误地评估了这些错误的可利用性，并且相应的补丁还没有被仔细地应用——导致他们迅速采用补丁。",
        "title_zh": "GREBE:揭示Linux内核漏洞的潜在利用",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2022.html",
        "conf_title": "43rd SP 2022: San Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP46214.2022",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SPW54247.2022.9833891",
        "title": "Abusing Trust: Mobile Kernel Subversion via TrustZone Rootkits",
        "authors": "Daniel Marth, Clemens Hlauschek, Christian Schanes, Thomas Grechenig",
        "abstract": "The Arm TrustZone is the de facto standard for hardware-backed Trusted Execution Environments (TEEs) on mobile devices, providing isolation for secure computations to be shielded from the normal world, and thus from the rest of the system. Most real-world TEEs are proprietary, difficult-to-inspect, and notoriously insecure: In the past years, it has been demonstrated over and over again that TEEs of millions of devices worldwide, and the Trusted Applications (TAs) they harbor, are often vulnerable to attacks such as control flow hijacking. Not only do we have to trust these TEEs to provide a secure environment for TAs such as keystore and Digital Rights Management (DRM), code running in the secure world provided by the Arm TrustZone also has full access to the memory of the regular operating system (OS). Since Thomas Roth first proposed a TrustZone-based rootkit in 2013, progress regarding such rootkits seems to have stalled in the offensive research community. The biggest challenge for TrustZone rootkits is that no interpretation of normal world memory is available in the secure world. Automated reverse engineering of kernel data structures at runtime is one way to implement rootkit functions. We present mechanisms to engineer the interpretation of Linux kernel memory for malicious subversion and the circumvention of basic protection mechanisms from the secure world. We provide a fully working proof-of-concept rootkit located in the Arm TrustZone to demonstrate the proposed mechanisms. We evaluate and show compatibility of the rootkit across different versions of the Linux kernel despite changing data structures. Our results highlight the feasibility of TrustZone rootkits that potentially survive kernel updates and raise awareness about the real danger of having to put trust into unvetted proprietary vendor code, which, as we show, can easily be abused.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "Arm TrustZone是移动设备上硬件支持的可信执行环境(TEEs)的事实上的标准，为安全计算提供隔离，使其与正常世界隔离，从而与系统的其余部分隔离。大多数真实世界的tee都是专有的，难以检查，并且出了名的不安全:在过去的几年中，一次又一次地证明了全球数百万设备的tee以及它们所承载的可信应用程序(ta)通常容易受到诸如控制流劫持之类的攻击。我们不仅要信任这些tee为密钥库和数字版权管理(DRM)等ta提供安全环境，在Arm TrustZone提供的安全环境中运行的代码还可以完全访问常规操作系统(OS)的内存。自从Thomas Roth在2013年首次提出基于TrustZone的rootkit以来，关于此类rootkit的进展似乎在攻击性研究社区中停滞不前。TrustZone rootkits面临的最大挑战是，在安全世界中没有对正常世界内存的解释。运行时内核数据结构的自动化逆向工程是实现rootkit功能的一种方式。我们提出了一些机制来设计对Linux内核内存的解释，用于恶意颠覆和规避安全世界的基本保护机制。我们在Arm TrustZone中提供了一个完全有效的概念验证rootkit来演示所提出的机制。我们评估并展示了rootkit在不同版本的Linux内核上的兼容性，尽管数据结构不断变化。我们的结果强调了TrustZone rootkitss的可行性，这些rootkit有可能在内核更新后存活下来，并提高了人们对不得不信任未经审查的专有供应商代码的真正危险的认识，正如我们所展示的那样，这些代码很容易被滥用。",
        "title_zh": "滥用信任:通过TrustZone Rootkits颠覆移动内核",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2022w.html",
        "conf_title": "43rd SP 2022: San Francisco, CA, USA - Workshops",
        "conf_url": "https://doi.org/10.1109/SPW54247.2022",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP40000.2020.00041",
        "title": "xMP: Selective Memory Protection for Kernel and User Space",
        "authors": "Sergej Proskurin, Marius Momeu, Seyedhamed Ghavamnia, Vasileios P. Kemerlis, Michalis Polychronakis",
        "abstract": "Attackers leverage memory corruption vulnerabilities to establish primitives for reading from or writing to the address space of a vulnerable process. These primitives form the foundation for code-reuse and data-oriented attacks. While various defenses against the former class of attacks have proven effective, mitigation of the latter remains an open problem. In this paper, we identify various shortcomings of the x86 architecture regarding memory isolation, and leverage virtualization to build an effective defense against data-oriented attacks. Our approach, called xMP, provides (in-guest) selective memory protection primitives that allow VMs to isolate sensitive data in user or kernel space in disjoint xMP domains. We interface the Xen altp2m subsystem with the Linux memory management system, lending VMs the flexibility to define custom policies. Contrary to conventional approaches, xMP takes advantage of virtualization extensions, but after initialization, it does not require any hypervisor intervention. To ensure the integrity of in-kernel management information and pointers to sensitive data within isolated domains, xMP protects pointers with HMACs bound to an immutable context, so that integrity validation succeeds only in the right context. We have applied xMP to protect the page tables and process credentials of the Linux kernel, as well as sensitive data in various user-space applications. Overall, our evaluation shows that xMP introduces minimal overhead for real-world workloads and applications, and offers effective protection against data-oriented attacks.",
        "files": {
            "openAccessPdf": "https://ieeexplore.ieee.org/ielx7/9144328/9152199/09152671.pdf"
        },
        "abstract_zh": "攻击者利用内存损坏漏洞来建立从易受攻击进程的地址空间读取或写入的原语。这些原语构成了代码重用和面向数据攻击的基础。虽然针对前一类攻击的各种防御措施已经被证明是有效的，但是减轻后一类攻击仍然是一个公开的问题。在本文中，我们确定了x86体系结构在内存隔离方面的各种缺点，并利用虚拟化来构建针对面向数据的攻击的有效防御。我们的方法称为xMP，提供(来宾)选择性内存保护原语，允许虚拟机在不相交的xMP域中隔离用户或内核空间中的敏感数据。我们将Xen altp2m子系统与Linux内存管理系统相连接，为虚拟机提供了定义自定义策略的灵活性。与传统方法相反，xMP利用了虚拟化扩展，但是在初始化之后，它不需要任何管理程序的干预。为了确保内核管理信息和指向隔离域中敏感数据的指针的完整性，xMP使用绑定到不可变上下文的HMACs来保护指针，以便完整性验证只在正确的上下文中成功。我们已经应用xMP来保护Linux内核的页表和进程凭证，以及各种用户空间应用程序中的敏感数据。总的来说，我们的评估表明，xMP为真实世界的工作负载和应用程序引入了最小的开销，并提供了针对面向数据的攻击的有效保护。",
        "title_zh": "xMP:内核和用户空间的选择性内存保护",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2020.html",
        "conf_title": "41st SP 2020: San Francisco, CA, USA",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/9144328/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP40000.2020.00075",
        "title": "Flaw Label: Exploiting IPv6 Flow Label",
        "authors": "Jonathan Berger, Amit Klein, Benny Pinkas",
        "abstract": "The IPv6 protocol was designed with security in mind. One of the changes that IPv6 has introduced over IPv4 is a new 20-bit flow label field in its protocol header.We show that remote servers can use the flow label field in order to assign a unique ID to each device when communicating with machines running Windows 10 (versions 1703 and higher), and Linux and Android (kernel versions 4.3 and higher). The servers are then able to associate the respective device IDs with subsequent transmissions sent from those machines. This identification is done by exploiting the flow label field generation logic and works across all browsers regardless of network changes. Furthermore, a variant of this attack also works passively, namely without actively triggering traffic from those machines.To design the attack we reverse-engineered and cryptanalyzed the Windows flow label generation code and inspected the Linux kernel flow label generation code. We provide a practical technique to partially extract the key used by each of these algorithms, and observe that this key can identify individual devices across networks, VPNs, browsers and privacy settings. We deployed a demo (for both Windows and Linux/Android) showing that key extraction and machine fingerprinting works in the wild, and tested it from networks around the world.",
        "files": {
            "openAccessPdf": "https://ieeexplore.ieee.org/ielx7/9144328/9152199/09152759.pdf"
        },
        "abstract_zh": "IPv6协议的设计考虑到了安全性。IPv6在IPv4上引入的变化之一是在其协议报头中新增了一个20位流标签字段。我们展示了远程服务器可以使用流标签字段，以便在与运行Windows 10(版本1703和更高版本)、Linux和Android(内核版本4.3和更高版本)的机器通信时，为每个设备分配唯一的ID。然后，服务器能够将相应的设备id与从这些机器发送的后续传输相关联。这种识别是通过利用流标签字段生成逻辑来完成的，并且不管网络如何变化，都可以跨所有浏览器工作。此外，这种攻击的变体也是被动工作的，即不主动触发来自这些机器的流量。为了设计攻击，我们对Windows流标签生成代码进行了逆向工程和密码分析，并检查了Linux内核流标签生成代码。我们提供了一种实用的技术来部分提取这些算法所使用的密钥，并观察到该密钥可以跨网络、VPN、浏览器和隐私设置来识别各个设备。我们部署了一个演示程序(针对Windows和Linux/Android ),展示了密钥提取和机器指纹识别在野外的工作情况，并在世界各地的网络中进行了测试。",
        "title_zh": "缺陷标签:利用IPv6流标签",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2020.html",
        "conf_title": "41st SP 2020: San Francisco, CA, USA",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/9144328/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP40001.2021.00063",
        "title": "PLATYPUS: Software-based Power Side-Channel Attacks on x86",
        "authors": "Moritz Lipp, Andreas Kogler, David F. Oswald, Michael Schwarz, Catherine Easdon, Claudio Canella, Daniel Gruss",
        "abstract": "Power side-channel attacks exploit variations in power consumption to extract secrets from a device, e.g., cryptographic keys. Prior attacks typically required physical access to the target device and specialized equipment such as probes and a high-resolution oscilloscope.In this paper, we present PLATYPUS attacks, which are novel software-based power side-channel attacks on Intel server, desktop, and laptop CPUs. We exploit unprivileged access to the Intel Running Average Power Limit (RAPL) interface that exposes values directly correlated with power consumption, forming a low-resolution side channel.We show that with sufficient statistical evaluation, we can observe variations in power consumption, which distinguish different instructions and different Hamming weights of operands and memory loads. This enables us to not only monitor the control flow of applications but also to infer data and extract cryptographic keys. We demonstrate how an unprivileged attacker can leak AES-NI keys from Intel SGX and the Linux kernel, break kernel address-space layout randomization (KASLR), infer secret instruction streams, and establish a timing-independent covert channel. We also present a privileged attack on mbed TLS, utilizing precise execution control to recover RSA keys from an SGX enclave. We discuss countermeasures and show that mitigating these attacks in a privileged context is not trivial.",
        "files": {
            "openAccessPdf": "http://pure-oai.bham.ac.uk/ws/files/115385754/platypus.pdf"
        },
        "abstract_zh": "功率旁道攻击利用功耗的变化从设备中提取秘密，例如密钥。以前的攻击通常需要物理接触目标设备和专用设备，如探头和高分辨率示波器。在本文中，我们介绍了鸭嘴兽攻击，这是一种针对英特尔服务器、台式机和笔记本电脑CPU的基于软件的新型电源侧信道攻击。我们利用了对英特尔运行平均功耗限制(RAPL)接口的非特权访问，该接口公开了与功耗直接相关的值，形成了一个低分辨率的侧通道。我们表明，通过充分的统计评估，我们可以观察到功耗的变化，这区分了不同的指令以及操作数和内存负载的不同汉明权重。这使得我们不仅可以监控应用程序的控制流，还可以推断数据和提取密钥。我们展示了无特权攻击者如何从SGX和Linux内核泄漏AES-NI密钥，破坏内核地址空间布局随机化(KASLR)，推断秘密指令流，并建立一个与时间无关的隐蔽通道。我们还展示了对mbed TLS的特权攻击，利用精确的执行控制从SGX飞地恢复RSA密钥。我们讨论了对策，并表明在特权环境中减轻这些攻击并不简单。",
        "title_zh": "PLATYPUS:x86上基于软件的功率旁路攻击",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2021.html",
        "conf_title": "42nd SP 2021: San Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP40001.2021",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP40001.2021.00054",
        "title": "Cross Layer Attacks and How to Use Them (for DNS Cache Poisoning, Device Tracking and More)",
        "authors": "Amit Klein",
        "abstract": "We analyze the prandom pseudo random number generator (PRNG) in use in the Linux kernel (which is the kernel of the Linux operating system, as well as of Android) and demonstrate that this PRNG is weak. The prandom PRNG is in use by many \"consumers\" in the Linux kernel. We focused on three consumers at the network level – the UDP source port generation algorithm, the IPv6 flow label generation algorithm and the IPv4 ID generation algorithm. The flawed prandom PRNG is shared by all these consumers, which enables us to mount \"cross layer attacks\" against the Linux kernel. In these attacks, we infer the internal state of the prandom PRNG from one OSI layer, and use it to either predict the values of the PRNG employed by the other OSI layer, or to correlate it to an internal state of the PRNG inferred from the other protocol.Using this approach we can mount a very efficient DNS cache poisoning attack against Linux. We collect TCP/IPv6 flow label values, or UDP source ports, or TCP/IPv4 IP ID values, reconstruct the internal PRNG state, then predict an outbound DNS query UDP source port, which speeds up the attack by a factor of x3000 to x6000. This attack works remotely, but can also be mounted locally, across Linux users and across containers, and (depending on the stub resolver) can poison the cache with an arbitrary DNS record. Additionally, we can identify and track Linux and Android devices – we collect TCP/IPv6 flow label values and/or UDP source port values and/or TCP/IPv4 ID fields, reconstruct the PRNG internal state and correlate this new state to previously extracted PRNG states to identify the same device.",
        "files": {
            "openAccessPdf": "http://arxiv.org/pdf/2012.07432"
        },
        "abstract_zh": "我们分析了在Linux内核(这是Linux操作系统以及Android的内核)中使用的prandom伪随机数生成器(PRNG ),并且证明了该PRNG是脆弱的。许多Linux内核的“消费者”都在使用prandom PRNG。我们重点关注了网络层的三个消费者UDP源端口生成算法、IPv6流标签生成算法和IPv4 ID生成算法。有缺陷的prandom PRNG被所有这些消费者共享，这使我们能够对Linux内核发起“跨层攻击”。在这些攻击中，我们从一个OSI层推断prandom PRNG的内部状态，并使用它来预测另一个OSI层使用的PRNG的值，或者将其与从另一个协议推断的PRNG的内部状态相关联。使用这种方法，我们可以对Linux发起非常有效的DNS缓存中毒攻击。我们收集TCP/IPv6流标签值或UDP源端口或TCP/IPv4 IP ID值，重建内部PRNG状态，然后预测出站DNS查询UDP源端口，这将攻击速度提高了x3000到x6000倍。这种攻击远程进行，但也可以在本地安装，跨Linux用户和跨容器，并且(取决于存根解析器)可以用任意DNS记录毒害缓存。此外，我们可以识别和跟踪Linux和Android设备–我们收集TCP/IPv6流标签值和/或UDP源端口值和/或TCP/IPv4 ID字段，重建PRNG内部状态，并将此新状态与之前提取的PRNG状态相关联，以识别同一设备。",
        "title_zh": "跨层攻击以及如何使用它们(针对DNS缓存中毒、设备跟踪等)",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2021.html",
        "conf_title": "42nd SP 2021: San Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP40001.2021",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP40001.2021.00090",
        "title": "ARBITRAR: User-Guided API Misuse Detection",
        "authors": "Ziyang Li, Aravind Machiry, Binghong Chen, Mayur Naik, Ke Wang, Le Song",
        "abstract": "Software APIs exhibit rich diversity and complexity which not only renders them a common source of programming errors but also hinders program analysis tools for checking them. Such tools either expect a precise API specification, which requires program analysis expertise, or presume that correct API usages follow simple idioms that can be automatically mined from code, which suffers from poor accuracy. We propose a new approach that allows regular programmers to find API misuses. Our approach interacts with the user to classify valid and invalid usages of each target API method. It minimizes user burden by employing an active learning algorithm that ranks API usages by their likelihood of being invalid. We implemented our approach in a tool called ARBITRAR for C/C++ programs, and applied it to check the uses of 18 API methods in 21 large real-world programs, including OpenSSL and Linux Kernel. Within just 3 rounds of user interaction on average per API method, ARBITRAR found 40 new bugs, with patches accepted for 18 of them. Moreover, ARBITRAR finds all known bugs reported by a state-of-the-art tool APISAN in a benchmark suite comprising 92 bugs with a false positive rate of only 51.5% compared to APISAN’s 87.9%.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "软件API表现出丰富的多样性和复杂性，这不仅使它们成为编程错误的常见来源，而且阻碍了用于检查它们的程序分析工具。这种工具要么期望精确的API规范，这需要程序分析专业知识，要么假设正确的API用法遵循简单的习惯用法，这些习惯用法可以从代码中自动挖掘出来，但准确性较差。我们提出了一种新的方法，允许普通程序员发现API误用。我们的方法与用户交互，对每个目标API方法的有效和无效用法进行分类。它通过采用一种主动学习算法来最小化用户负担，该算法根据API使用无效的可能性对其进行排序。我们在一个名为ARBITRAR for C/C++ programs的工具中实现了我们的方法，并应用它检查了21个大型真实世界程序中18个API方法的使用，包括OpenSSL和Linux内核。在平均每个API方法的3轮用户交互中，ARBITRAR发现了40个新错误，其中18个被接受了补丁。此外，ARBITRAR在由92个错误组成的基准测试套件中找到了由最先进的工具APISAN报告的所有已知错误，与APISAN的87.9%相比，误报率仅为51.5%。",
        "title_zh": "ARBITRAR:用户导向的API误用检测",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2021.html",
        "conf_title": "42nd SP 2021: San Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP40001.2021",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP.2019.00017",
        "title": "Razzer: Finding Kernel Race Bugs through Fuzzing",
        "authors": "Dae R. Jeong, Kyungtae Kim, Basavesh Shivakumar, Byoungyoung Lee, Insik Shin",
        "abstract": "A data race in a kernel is an important class of bugs, critically impacting the reliability and security of the associated system. As a result of a race, the kernel may become unresponsive. Even worse, an attacker may launch a privilege escalation attack to acquire root privileges. In this paper, we propose Razzer, a tool to find race bugs in kernels. The core of Razzer is in guiding fuzz testing towards potential data race spots in the kernel. Razzer employs two techniques to find races efficiently: a static analysis and a deterministic thread interleaving technique. Using a static analysis, Razzer identifies over-approximated potential data race spots, guiding the fuzzer to search for data races in the kernel more efficiently. Using the deterministic thread interleaving technique implemented at the hypervisor, Razzer tames the non-deterministic behavior of the kernel such that it can deterministically trigger a race. We implemented a prototype of Razzer and ran the latest Linux kernel (from v4.16-rc3 to v4.18-rc3) using Razzer. As a result, Razzer discovered 30 new races in the kernel, with 16 subsequently confirmed and accordingly patched by kernel developers after they were reported.",
        "files": {
            "openAccessPdf": "https://ieeexplore.ieee.org/ielx7/8826229/8835208/08835326.pdf"
        },
        "abstract_zh": "内核中的数据竞争是一类重要的错误，严重影响相关系统的可靠性和安全性。作为竞争的结果，内核可能变得没有响应。更糟糕的是，攻击者可能会发起权限提升攻击来获取根权限。在这篇文章中，我们提出了Razzer，一个在内核中寻找种族错误的工具。Razzer的核心是将模糊测试引向内核中潜在的数据竞争点。Razzer使用两种技术来有效地发现竞争:静态分析和确定性线程交错技术。使用静态分析，Razzer识别过度近似的潜在数据竞争点，指导fuzzer更有效地在内核中搜索数据竞争。Razzer使用在管理程序中实现的确定性线程交错技术，驯服了内核的非确定性行为，使其能够确定性地触发竞争。我们实现了一个Razzer的原型，并使用Razzer运行了最新的Linux内核(从v4.16-rc3到v4.18-rc3)。结果，Razzer在内核中发现了30个新的种族，其中16个随后得到了确认，并在报告后由内核开发人员进行了相应的修补。",
        "title_zh": "Razzer:通过模糊化发现内核竞争错误",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2019.html",
        "conf_title": "40th SP 2019: San Francisco, CA, USA",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/8826229/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP.2019.00035",
        "title": "Fuzzing File Systems via Two-Dimensional Input Space Exploration",
        "authors": "Wen Xu, Hyungon Moon, Sanidhya Kashyap, Po-Ning Tseng, Taesoo Kim",
        "abstract": "File systems, a basic building block of an OS, are too big and too complex to be bug free. Nevertheless, file systems rely on regular stress-testing tools and formal checkers to find bugs, which are limited due to the ever-increasing complexity of both file systems and OSes. Thus, fuzzing, proven to be an effective and a practical approach, becomes a preferable choice, as it does not need much knowledge about a target. However, three main challenges exist in fuzzing file systems: mutating a large image blob that degrades overall performance, generating image-dependent file operations, and reproducing found bugs, which is difficult for existing OS fuzzers. Hence, we present JANUS, the first feedback-driven fuzzer that explores the two-dimensional input space of a file system, i.e., mutating metadata on a large image, while emitting image-directed file operations. In addition, JANUS relies on a library OS rather than on traditional VMs for fuzzing, which enables JANUS to load a fresh copy of the OS, thereby leading to better reproducibility of bugs. We evaluate JANUS on eight file systems and found 90 bugs in the upstream Linux kernel, 62 of which have been acknowledged. Forty-three bugs have been fixed with 32 CVEs assigned. In addition, JANUS achieves higher code coverage on all the file systems after fuzzing 12 hours, when compared with the state-of-the-art fuzzer Syzkaller for fuzzing file systems. JANUS visits 4.19x and 2.01x more code paths in Btrfs and ext4, respectively. Moreover, JANUS is able to reproduce 88–100% of the crashes, while Syzkaller fails on all of them.",
        "files": {
            "openAccessPdf": "https://ieeexplore.ieee.org/ielx7/8826229/8835208/08835267.pdf"
        },
        "abstract_zh": "文件系统是操作系统的基本组成部分，它太大太复杂，不可能没有错误。然而，文件系统依赖常规的压力测试工具和正式的检查器来发现错误，由于文件系统和操作系统的复杂性不断增加，这是有限的。因此，模糊化被证明是一种有效和实用的方法，成为一种更好的选择，因为它不需要太多关于目标的知识。然而，在模糊文件系统中存在三个主要挑战:使降低整体性能的大图像斑点变异、生成依赖于图像的文件操作、以及再现所发现的缺陷，这对于现有的OS模糊器来说是困难的。因此，我们提出了JANUS，第一个反馈驱动的fuzzer，它探索了文件系统的二维输入空间，即在大图像上改变元数据，同时发出图像导向的文件操作。此外，骏利依靠库操作系统而不是传统的虚拟机来进行模糊处理，这使得骏利能够加载操作系统的新副本，从而更好地重现错误。我们在八个文件系统上评估了JANUS，在上游Linux内核中发现了90个bug，其中62个已经被确认。43个bug已经被修复，分配了32个CVE。此外，在fuzzing 12小时后，与用于fuzzing文件系统的最先进的fuzzer Syzkaller相比，JANUS在所有文件系统上实现了更高的代码覆盖率。骏利在Btrfs和ext4中分别多访问了4.19倍和2.01倍的代码路径。此外，骏利能够重现88–100%的崩溃，而Syzkaller却无法重现所有崩溃。",
        "title_zh": "通过二维输入空间探索模糊化文件系统",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2019.html",
        "conf_title": "40th SP 2019: San Francisco, CA, USA",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/8826229/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP.2019.00041",
        "title": "LBM: A Security Framework for Peripherals within the Linux Kernel",
        "authors": "Dave Jing Tian, Grant Hernandez, Joseph I. Choi, Vanessa Frost, Peter C. Johnson, Kevin R. B. Butler",
        "abstract": "Modern computer peripherals are diverse in their capabilities and functionality, ranging from keyboards and printers to smartphones and external GPUs. In recent years, peripherals increasingly connect over a small number of standardized communication protocols, including USB, Bluetooth, and NFC. The host operating system is responsible for managing these devices; however, malicious peripherals can request additional functionality from the OS resulting in system compromise, or can craft data packets to exploit vulnerabilities within OS software stacks. Defenses against malicious peripherals to date only partially cover the peripheral attack surface and are limited to specific protocols (e.g., USB). In this paper, we propose Linux (e)BPF Modules (LBM), a general security framework that provides a unified API for enforcing protection against malicious peripherals within the Linux kernel. LBM leverages the eBPF packet filtering mechanism for performance and extensibility and we provide a high-level language to facilitate the development of powerful filtering functionality. We demonstrate how LBM can provide host protection against malicious USB, Bluetooth, and NFC devices; we also instantiate and unify existing defenses under the LBM framework. Our evaluation shows that the overhead introduced by LBM is within 1 μs per packet in most cases, application and system overhead is negligible, and LBM outperforms other state-of-the-art solutions. To our knowledge, LBM is the first security framework designed to provide comprehensive protection against malicious peripherals within the Linux kernel.",
        "files": {
            "openAccessPdf": "https://ieeexplore.ieee.org/ielx7/8826229/8835208/08835285.pdf"
        },
        "abstract_zh": "现代计算机外围设备的能力和功能多种多样，从键盘和打印机到智能手机和外部GPU。近年来，外设越来越多地通过少量标准化通信协议进行连接，包括USB、蓝牙和NFC。主机操作系统负责管理这些设备；但是，恶意外围设备可以从操作系统请求额外的功能，从而导致系统受损，或者可以编制数据包来利用操作系统软件堆栈中的漏洞。迄今为止，针对恶意外围设备的防御仅部分覆盖了外围设备攻击面，并且局限于特定的协议(例如，USB)。在本文中，我们提出了Linux (e)BPF模块(LBM)，这是一个通用的安全框架，它提供了一个统一的API，用于在Linux内核中实施针对恶意外设的保护。LBM利用eBPF包过滤机制来提高性能和可扩展性，并且我们提供高级语言来促进强大过滤功能的开发。我们演示了LBM如何提供针对恶意USB、蓝牙和NFC设备的主机保护；我们还在LBM框架下实例化和统一现有的防御。我们的评估显示，在大多数情况下，LBM引入的开销在每个数据包1 μs以内，应用和系统开销可以忽略不计，LBM优于其他一流的解决方案。据我们所知，LBM是第一个安全框架，旨在为Linux内核中的恶意外设提供全面的保护。",
        "title_zh": "LBM:Linux内核中外围设备的安全框架",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2019.html",
        "conf_title": "40th SP 2019: San Francisco, CA, USA",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/8826229/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP.2016.32",
        "title": "No Pardon for the Interruption: New Inference Attacks on Android Through Interrupt Timing Analysis",
        "authors": "Wenrui Diao, Xiangyu Liu, Zhou Li, Kehuan Zhang",
        "abstract": "Many new specialized hardware components have been integrated into Android smartphones to improve mobility and usability, such as touchscreen, Bluetooth module, and NFC controller. At the system level, the kernel of Android is built on Linux and inherits its device management mechanisms. However, the security implications surfaced from the integration of new hardware components and the tailored Linux kernel are not fully understood. In this paper, we make the first attempt to evaluate such implications. As a result, we identify a critical information leakage channel from the interrupt handling mechanism, which can be exploited to launch inference attacks without any permission. On Android, all reported interrupts are counted by Linux kernel and the statistical information is logged in a system file /proc/interrupts, which is public to any process. Such statistical information reveals the running status of all integrated devices, and could be exploited by attackers to infer sensitive information passing through them. To assess this new threat, we propose a general attack approach -- interrupt timing analysis and apply it to interrupt logs. As showcases, we present two concrete inference attacks against user's unlock pattern and foreground app status respectively. Through analyzing the interrupt time series produced from touchscreen controller, attacker's chance of cracking user's unlock pattern is increased substantially. The interrupt time series produced from Display Sub-System reveals unique UI refreshing patterns and could be leveraged as fingerprints to identify the app running in the foreground. Such information can serve as the stepping stone for the subsequent phishing attacks. The experiment results suggest our inference attacks are highly effective, and the risks should be mitigated immediately.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "许多新的专业硬件组件已集成到Android智能手机中，以提高移动性和可用性，例如触摸屏，蓝牙模块和NFC控制器。 在系统级别上，Android的内核建立在Linux上，并继承其设备管理机制。 但是，新硬件组件和量身定制的Linux内核的集成所产生的安全含义尚未完全了解。 在本文中，我们首次尝试评估这种含义。 结果，我们从中断处理机制中确定了关键信息泄漏渠道，该通道可以在未经任何许可的情况下被利用以启动推理攻击。 在Android上，所有报告的中断都由Linux内核计数，并且统计信息在系统文件 /PROC /中断中记录在任何过程中。 这样的统计信息揭示了所有集成设备的运行状态，并且可以被攻击者利用以推断通过它们的敏感信息。 为了评估这一新威胁，我们提出了一种通用攻击方法 - 中断定时分析并将其应用于中断日志。 作为展示，我们分别针对用户的解锁模式和前景应用程序状态提出了两次具体推理攻击。 通过分析触摸屏控制器产生的中断时间序列，攻击者破解用户解锁模式的机会大大增加了。 从显示子系统产生的中断时间序列揭示了独特的UI刷新模式，并且可以用作指纹识别在前景中运行的应用程序。 这些信息可以用作随后的网络钓鱼攻击的垫脚石。 实验结果表明我们的推论攻击非常有效，应立即降低风险。",
        "title_zh": "不原谅中断:通过中断时序分析对Android的新推理攻击",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2016.html",
        "conf_title": "37th S&P 2016: San Jose, CA, USA",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/7528194/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SPW.2016.38",
        "title": "Research Report: Analysis of Software for Restricted Computational Environment Applicability",
        "authors": "Jacob I. Torrey, Jonathan Miodownik",
        "abstract": "Preliminary experiment design and research goals are presented to measure the applicability of restricted computational complexity environments in general purpose development efforts. The Linux kernel is examined through the lens of LangSec in order to gain insight into the make-up of the kernel code vis-à-vis the complexity class of recognizer for input to each component on the Chomsky Hierarchy. Manual analysis is assisted with LLVM Passes and comparison with the real-time Linux fork. This paper describes an on-going effort with the goals of justifying further research in the field of restricted computational environments.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "提出了初步的实验设计和研究目标，以衡量限制计算复杂性环境在通用开发工作中的适用性。 通过Langsec的镜头对Linux内核进行了检查，以深入了解内核代码相对于Chomsky层次结构上每个组件的识别器的复杂性类别的构成。 通过LLVM通过并与实时Linux叉进行了帮助。 本文描述了一项持续的努力，其目标是证明在受限计算环境领域的进一步研究。",
        "title_zh": "研究报告:受限计算环境适用性的软件分析",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/spw2016.html",
        "conf_title": "37th S&P 2016: San Jose, CA, USA - Workshops",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/7517741/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP46215.2023.10179412",
        "title": "Practical Program Modularization with Type-Based Dependence Analysis",
        "authors": "Kangjie Lu",
        "abstract": "Today's software programs are bloating and have become extremely complex. As there is typically no internal isolation among modules in a program, a vulnerability can be exploited to corrupt the memory and take control of the whole program. Program modularization is thus a promising security mechanism that splits a complex program into smaller modules, so that memory-access instructions can be constrained from corrupting irrelevant modules. A general approach to realizing program modularization is dependence analysis which determines if an instruction is independent of specific code or data; and if so, it can be modularized. Unfortunately, dependence analysis in complex programs is generally considered infeasible, due to problems in data-flow analysis, such as unknown indirect-call targets, pointer aliasing, and path explosion. As a result, we have not seen practical automated program modularization built on dependence analysis.This paper presents a breakthrough—Type-based dependence analysis for Program Modularization (TyPM). Its goal is to determine which modules in a program can never pass a type of object (including references) to a memory-access instruction; therefore, objects of this type that are created by these modules can never be valid targets of the instruction. The idea is to employ a type-based analysis to first determine which types of data flows can take place between two modules, and then transitively resolve all dependent modules of a memory-access instruction, with respect to the specific type. Such an approach avoids the data-flow analysis and can be practical. We develop two important security applications based on TyPM: refining indirect-call targets and protecting critical data structures. We extensively evaluate TyPM with various system software, including an OS kernel, a hypervisor, UEFI firmware, and a browser. Results show that on average TyPM additionally refines indirect-call targets produced by the state of the art by 31%-91%. TyPM can also remove 99.9% of modules for memory-write instructions to prevent them from corrupting critical data structures in the Linux kernel.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "基于类型依赖分析的实用程序模块化",
        "abstract_zh": "今天的软件程序正在膨胀，变得极其复杂。由于程序中的模块之间通常没有内部隔离，因此可以利用漏洞来破坏内存并控制整个程序。因此，程序模块化是一种很有前途的安全机制，它将复杂的程序分割成较小的模块，这样就可以限制内存访问指令破坏不相关的模块。实现程序模块化的一般方法是依赖分析，它确定指令是否独立于特定的代码或数据；如果有，它可以模块化。不幸的是，由于数据流分析中的问题，例如未知的间接调用目标、指针别名和路径爆炸，复杂程序中的依赖分析通常被认为是不可行的。因此，我们还没有看到基于依赖分析的实际自动化程序模块化。本文提出了一个突破性的方法——基于类型的程序模块化依赖分析。它的目标是确定程序中的哪些模块永远不能将对象类型(包括引用)传递给内存访问指令；因此，由这些模块创建的这种类型的对象永远不会是指令的有效目标。其思想是采用基于类型的分析，首先确定两个模块之间可以发生哪些类型的数据流，然后根据特定的类型，传递性地解析内存访问指令的所有相关模块。这种方法避免了数据流分析，是可行的。我们基于TyPM开发了两个重要的安全应用程序:细化间接调用目标和保护关键数据结构。我们使用各种系统软件广泛评估TyPM，包括操作系统内核、管理程序、UEFI固件和浏览器。结果显示，平均而言，TyPM还将现有技术产生的间接调用目标细化了31%-91%。TyPM还可以删除99.9%的内存写指令模块，以防止它们破坏Linux内核中的关键数据结构。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2023.html",
        "conf_title": "44th SP 2023:\nSan Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP46215.2023",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP46215.2023.10179366",
        "title": "Precise Detection of Kernel Data Races with Probabilistic Lockset Analysis",
        "authors": "Gabriel Ryan, Abhishek Shah, Dongdong She, Suman Jana",
        "abstract": "Finding data races is critical for ensuring security in modern kernel development. However, finding data races in the kernel is challenging because it requires jointly searching over possible combinations of system calls and concurrent execution schedules. Kernel race testing systems typically perform this search by executing groups of fuzzer seeds from a corpus and applying a combination of schedule fuzzing and dynamic race prediction on traces. However, predicting which combinations of seeds can expose races in the kernel is difficult as fuzzer seeds will usually follow different execution paths when executed concurrently due to inter-thread communications and synchronization.To address this challenge, we introduce a new analysis for kernel race prediction, Probabilistic Lockset Analysis (PLA) that addresses the challenges posed by race prediction for the kernel. PLA leverages the observation that system calls almost always perform certain memory accesses to shared memory to perform their function. PLA uses randomized concurrent trace sampling to identify memory accesses that are performed consistently and estimates the probability of races between them subject to kernel lock synchronization. By prioritizing high probability races, PLA is able to make accurate predictions.We evaluate PLA against comparable kernel race testing methods and show it finds races at a 3× higher rate over 24 hours. We use PLA to find 183 races in linux kernel v5.18-rc5, including 102 harmful races. PLA is able to find races that have severe security impact in heavily tested core kernel modules, including use-after-free in memory management, OOB write in network cryptography, and leaking kernel heap memory information. Some of these vulnerabilities have been overlooking by existing systems for years: one of the races found by PLA involving an OOB write has been present in the kernel since 2013 (version v3.14-rc1) and has been designated a high severity CVE.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "通过概率锁定分析对内核数据进行的精确检测",
        "abstract_zh": "寻找数据竞赛对于确保现代内核开发中的安全至关重要。 但是，在内核中找到数据竞赛是具有挑战性的，因为它需要共同搜索系统调用和并发执行时间表的可能组合。 内核竞赛测试系统通常通过从语料库中执行模糊种子的组并在痕迹上应用时间表模糊和动态种族预测的组合来执行模糊种子。 但是，预测种子的组合可以在内核中暴露种族很难暴露在内核中，因为由于跨线程通信和同步同时执行时，模糊种子通常会遵循不同的执行路径。要解决这一挑战，我们引入了内核种族预测的新分析 ，概率锁定分析（PLA）解决了种族预测对内核的挑战。 PLA利用了系统调用几乎总是执行某些内存访问以执行其功能的观察。 PLA使用随机并发跟踪采样来识别始终执行的内存访问，并估计它们之间的种族概率受内核锁定的同步。 通过优先考虑较高的概率种族，PLA能够进行准确的预测。我们评估PLA针对可比的内核种族测试方法，并表明它在24小时内以3倍的速度发现了种族。 我们使用PLA在Linux内核V5.18-RC5中找到183场比赛，其中包括102场有害比赛。 PLA能够找到在经过严格测试的核心内核模块中具有严重安全性影响的种族，包括在内存管理中无使用，在网络加密中写入OOB以及泄漏内核堆内存信息。 这些漏洞中的某些漏洞已被现有系统忽略了多年：自2013年以来，涉及OOB写入的PLA发现的种族之一（V3.14-RC1版本）已在内核中存在，并已被指定为高度严重性CVE。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2023.html",
        "conf_title": "44th SP 2023:\nSan Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP46215.2023",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP46215.2023.10179286",
        "title": "AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities",
        "authors": "Zheyue Jiang, Yuan Zhang, Jun Xu, Xinqian Sun, Zhuang Liu, Min Yang",
        "abstract": "This paper studies the problem of cross-version exploitability assessment for Linux kernels. Specifically, given an exploit demonstrating the exploitability of a vulnerability on a specific kernel version, we aim to understand the exploitability of the same vulnerability on other kernel versions. To tackle cross-version exploitability assessment, automated exploit generation (AEG), a recently popular topic, is the only existing, applicable solution. However, AEG is not well-suited due to its template-driven nature and ignorance of the capabilities offered by the available exploit.In this work, we introduce a new method, automated exploit migration (AEM), to facilitate cross-version exploitability assessment for Linux kernels. The key insight of AEM is the observation that the strategy adopted by the exploit is often applicable to other exploitable kernel versions. Technically, we consider the kernel version where the exploit works as a reference and adjust the exploit to force the other kernel versions to align with the reference. This way, we can reproduce the exploiting behaviors on the other versions. To reduce the cost and increase the feasibility, we strategically identify execution points that truly affect the exploitation and only enforce alignment at those points. We have designed and implemented a prototype of AEM. In our evaluation of 67 cases where exploit migration is needed, our prototype successfully migrates the exploit for 56 cases, producing a success rate of 83.5%.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "AEM：促进Linux内核脆弱性的跨越可剥削性评估",
        "abstract_zh": "本文研究了Linux内核的交叉剥削性评估问题。 具体而言，考虑到在特定内核版本上证明漏洞的可剥削性的利用，我们旨在了解其他内核版本上相同漏洞的可剥削性。 为了解决交叉可利用性评估，最近流行的主题是自动化的利用生成（AEG），是唯一现有的适用解决方案。 但是，由于AEG的模板驱动的性质和对可用利用的功能的无知。 对于Linux内核。 AEM的关键见解是观察到，利用采用的策略通常适用于其他可剥削的内核版本。 从技术上讲，我们考虑利用功能作为参考的内核版本，并调整利用来迫使其他内核版本与参考保持一致。 这样，我们可以在其他版本上复制剥削行为。 为了降低成本并提高可行性，我们从战略上确定了真正影响剥削的执行点，并且仅在这些点执行一致性。 我们设计并实施了AEM的原型。 在我们对需要剥削迁移的67个情况的评估中，我们的原型成功地迁移了56例案例的利用，成功率为83.5％。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2023.html",
        "conf_title": "44th SP 2023:\nSan Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP46215.2023",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP46215.2023.10179286",
        "title": "AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities",
        "authors": "Zheyue Jiang, Yuan Zhang, Jun Xu, Xinqian Sun, Zhuang Liu, Min Yang",
        "abstract": "This paper studies the problem of cross-version exploitability assessment for Linux kernels. Specifically, given an exploit demonstrating the exploitability of a vulnerability on a specific kernel version, we aim to understand the exploitability of the same vulnerability on other kernel versions. To tackle cross-version exploitability assessment, automated exploit generation (AEG), a recently popular topic, is the only existing, applicable solution. However, AEG is not well-suited due to its template-driven nature and ignorance of the capabilities offered by the available exploit.In this work, we introduce a new method, automated exploit migration (AEM), to facilitate cross-version exploitability assessment for Linux kernels. The key insight of AEM is the observation that the strategy adopted by the exploit is often applicable to other exploitable kernel versions. Technically, we consider the kernel version where the exploit works as a reference and adjust the exploit to force the other kernel versions to align with the reference. This way, we can reproduce the exploiting behaviors on the other versions. To reduce the cost and increase the feasibility, we strategically identify execution points that truly affect the exploitation and only enforce alignment at those points. We have designed and implemented a prototype of AEM. In our evaluation of 67 cases where exploit migration is needed, our prototype successfully migrates the exploit for 56 cases, producing a success rate of 83.5%.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "AEM：促进Linux内核脆弱性的跨越可剥削性评估",
        "abstract_zh": "本文研究了Linux内核的交叉剥削性评估问题。 具体而言，考虑到在特定内核版本上证明漏洞的可剥削性的利用，我们旨在了解其他内核版本上相同漏洞的可剥削性。 为了解决交叉可利用性评估，最近流行的主题是自动化的利用生成（AEG），是唯一现有的适用解决方案。 但是，由于AEG的模板驱动的性质和对可用利用的功能的无知。 对于Linux内核。 AEM的关键见解是观察到，利用采用的策略通常适用于其他可剥削的内核版本。 从技术上讲，我们考虑利用功能作为参考的内核版本，并调整利用来迫使其他内核版本与参考保持一致。 这样，我们可以在其他版本上复制剥削行为。 为了降低成本并提高可行性，我们从战略上确定了真正影响剥削的执行点，并且仅在这些点执行一致性。 我们设计并实施了AEM的原型。 在我们对需要剥削迁移的67个情况的评估中，我们的原型成功地迁移了56例案例的利用，成功率为83.5％。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2023.html",
        "conf_title": "44th SP 2023:\nSan Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP46215.2023",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP46215.2023.10179356",
        "title": "When Top-down Meets Bottom-up: Detecting and Exploiting Use-After-Cleanup Bugs in Linux Kernel",
        "authors": "Lin Ma, Duoming Zhou, Hanjie Wu, Yajin Zhou, Rui Chang, Hao Xiong, Lei Wu, Kui Ren",
        "abstract": "When a device is detached from the system, Use-After-Cleanup (UAC) bugs can occur because a running kernel thread may be unaware of the device detachment and attempt to use an object that has been released by the cleanup thread. Our investigation suggests that an attacker can exploit the UAC bugs to obtain the capability of arbitrary code execution and privilege escalation, which receives little attention from the community. While existing tools mainly focus on well-known concurrency bugs like data race, few target UAC bugs.In this paper, we propose a tool named UACatcher to systematically detect UAC bugs. UACatcher consists of three main phases. It first scans the entire kernel to find target layers. Next, it adopts the context- and flow-sensitive inter-procedural analysis and the points-to analysis to locate possible free (deallocation) sites in the bottom-up cleanup thread and use (dereference) sites in the top-down kernel thread that can cause UAC bugs. Then, UACatcher uses the routine switch point algorithm which counts on the synchronizations and path constraints to detect UAC bugs among these sites and estimate exploitable ones. For exploitable bugs, we leverage the pseudoterminal-based device emulation technique to develop practical exploits.We have implemented a prototype of UACatcher and evaluated it on 5.11 Linux kernel. As a result, our tool successfully detected 346 UAC bugs, which were reported to the community (277 have been confirmed and fixed and 15 CVEs have been assigned). Additionally, 13 bugs are exploitable, which can be used to develop working exploits that gain the arbitrary code execution primitive in kernel space and achieve the privilege escalation. Finally, we discuss UACatcher’s limitations and propose possible solutions to fix and prevent UAC bugs.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "自上而下时：在Linux内核中检测和利用使用后清洁错误",
        "abstract_zh": "当设备与系统分离时，可能会发生使用后清洁（UAC）错误，因为运行的内核线程可能不知道设备拆卸，并且尝试使用清理线程已发布的对象。 我们的调查表明，攻击者可以利用UAC错误来获得任意代码执行和特权升级的能力，这很少受到社区的关注。 现有工具主要集中于诸如数据竞赛之类的众所周知的并发错误，但很少有针对UAC错误。在本文中，我们提出了一个名为Uacatcher的工具来系统地检测UAC错误。 Uacatcher由三个主要阶段组成。 它首先扫描整个内核以找到目标层。 接下来，它采用上下文和流动敏感的过程间分析以及点对点分析，以在自下而上的清理线程中找到可能的免费（DealLocation）站点，并在自上而下的内核线程中找到（解除）站点 可能导致UAC错误。 然后，Uacatcher使用常规开关点算法，该算法算上同步和路径约束来检测这些站点之间的UAC错误并估算可利用的错误。 对于可利用的错误，我们利用基于伪的设备仿真技术来开发实用的利用。我们已经实施了Uacatcher的原型，并在5.11 Linux内核上进行了评估。 结果，我们的工具成功检测到了346个UAC错误，这些错误已报告给社区（已确认并固定了277个，已分配了15个CVE）。 此外，可利用13个错误，可用于开发工作利用，以获得内核空间中的任意代码执行并实现特权升级。 最后，我们讨论了Uacatcher的局限性，并提出了解决方案，以解决和防止UAC错误。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2023.html",
        "conf_title": "44th SP 2023:\nSan Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP46215.2023",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/SP46215.2023.10179298",
        "title": "SyzDescribe: Principled, Automated, Static Generation of Syscall Descriptions for Kernel Drivers",
        "authors": "Yu Hao, Guoren Li, Xiaochen Zou, Weiteng Chen, Shitong Zhu, Zhiyun Qian, Ardalan Amiri Sani",
        "abstract": "Fuzz testing operating system kernels has been effective overall in recent years. For example, syzkaller manages to find thousands of bugs in the Linux kernel since 2017. One necessary component of syzkaller is a collection of syscall descriptions that are often provided by human experts. However, to our knowledge, current syscall descriptions are largely written manually, which is both time-consuming and error-prone. It is especially challenging considering that there are many kernel drivers (for new hardware devices and beyond) that are continuously being developed and evolving over time. In this paper, we present a principled solution for generating syscall descriptions for Linux kernel drivers. At its core, we summarize and model the key invariants or programming conventions, extracted from the \"contract\" between the core kernel and drivers. This allows us to understand programmatically how a kernel driver is initialized and how its associated interfaces are constructed. With this insight, we have developed a solution in a tool called SyzDescribe that has been tested for over hundreds of kernel drivers. We show that the syscall descriptions produced by SyzDescribe are competitive to manually-curated ones, and much better than prior work (i.e., DIFUZE and KSG). Finally, we analyze the gap between our descriptions and the ground truth and point to future improvement opportunities.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "syzdeScribe：原则上，自动化，静态的syscall描述，用于内核驱动程序",
        "abstract_zh": "近年来，模糊测试操作系统内核总体上一直有效。 例如，Syzkaller自2017年以来设法在Linux内核中找到了数千个错误。Syzkaller的一个必要组成部分是SYSCALL描述的集合，这些描述通常由人类专家提供。 但是，据我们所知，当前的SYSCALL描述在很大程度上是手动编写的，这既耗时又容易出错。 考虑到随着时间的流逝，有许多内核驱动程序（对于新硬件设备及其他地区）正在不断开发和发展，这尤其具有挑战性。 在本文中，我们提出了一种用于生成Linux内核驱动程序的SYSCALL描述的原则解决方案。 从本质上讲，我们总结并建模了主要不变式或编程惯例，这些约定是从核心内核和驱动程序之间的“合同”中提取的。 这使我们能够以编程方式了解内核驱动程序的初始化以及如何构建其相关接口。 有了这个见解，我们已经在一种名为SyzdeScribe的工具中开发了一个解决方案，该工具已经测试了数百多个内核驱动程序。 我们表明，SyzdeScribe制作的SYSCALL描述对手动策划的描述具有竞争力，并且比先前的工作（即Difuze和KSG）好得多。 最后，我们分析了我们的描述与基础真理之间的差距，并指出了未来的改进机会。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sp/sp2023.html",
        "conf_title": "44th SP 2023:\nSan Francisco, CA, USA",
        "conf_url": "https://doi.org/10.1109/SP46215.2023",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3488932.3527293",
        "title": "Enabling Attribute-Based Access Control in Linux Kernel",
        "authors": "H. O. Sai Varshith, Shamik Sural, Jaideep Vaidya, Vijayalakshmi Atluri",
        "abstract": "Linux has built-in security features based on discretionary access control that can be enhanced using the Linux Security Module (LSM) framework. However, so far there has been no reported work on strengthening Linux with Attribute-Based Access Control (ABAC), which is gaining in popularity in recent years due to its flexibility and dynamic nature. In this paper, a method for enabling ABAC for Linux file system objects using LSM is proposed. We report initial experimental results and also share our public repository links for integrating ABAC in any Linux installation.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "Linux具有基于自主访问控制的内置安全特性，可以使用Linux安全模块(LSM)框架来增强这些特性。然而，到目前为止，还没有关于使用基于属性的访问控制(ABAC)来增强Linux的工作的报道，基于属性的访问控制由于其灵活性和动态性，近年来越来越受欢迎。提出了一种使用LSM为Linux文件系统对象启用ABAC的方法。我们报告了初步的实验结果，并分享了我们的公共库链接，用于在任何Linux安装中集成ABAC。",
        "title_zh": "在Linux内核中启用基于属性的访问控制",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/asiaccs/asiaccs2022.html",
        "conf_title": "17th AsiaCCS 2022: Nagasaki, Japan",
        "conf_url": "https://doi.org/10.1145/3488932?",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3433210.3453115",
        "title": "Bran: Reduce Vulnerability Search Space in Large Open Source Repositories by Learning Bug Symptoms",
        "authors": "Dongyu Meng, Michele Guerriero, Aravind Machiry, Hojjat Aghakhani, Priyanka Bose, Andrea Continella, Christopher Kruegel, Giovanni Vigna",
        "abstract": "Software is continually increasing in size and complexity, and therefore, vulnerability discovery would benefit from techniques that identify potentially vulnerable regions within large code bases, as this allows for easing vulnerability detection by reducing the search space. Previous work has explored the use of conventional code-quality and complexity metrics in highlighting suspicious sections of (source) code. Recently, researchers also proposed to reduce the vulnerability search space by studying code properties with neural networks. However, previous work generally failed in leveraging the rich metadata that is available for long-running, large code repositories. In this paper, we present an approach, named Bran, to reduce the vulnerability search space by combining conventional code metrics with fine-grained repository metadata. Bran locates code sections that are more likely to contain vulnerabilities in large code bases, potentially improving the efficiency of both manual and automatic code audits. In our experiments on four large code bases, Bran successfully highlights potentially vulnerable functions, outperforming several baselines, including state-of-art vulnerability prediction tools. We also assess Bran's effectiveness in assisting automated testing tools. We use Bran to guide syzkaller, a known kernel fuzzer, in fuzzing a recent version of the Linux kernel. The guided fuzzer identifies 26 bugs (10 are zero-day flaws), including arbitrary writes and reads.",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3433210.3453115"
        },
        "abstract_zh": "软件的大小和复杂性不断增加，因此，漏洞发现将受益于识别大型代码库中潜在易受攻击区域的技术，因为这允许通过减少搜索空间来简化漏洞检测。先前的工作已经探索了使用传统的代码质量和复杂性度量来突出(源)代码的可疑部分。最近，研究人员还提出通过用神经网络研究代码属性来缩小漏洞搜索空间。然而，以前的工作通常无法利用可用于长期运行的大型代码库的丰富元数据。在本文中，我们提出了一种称为Bran的方法，通过结合传统的代码度量和细粒度的存储库元数据来减少漏洞搜索空间。Bran定位大型代码库中更有可能包含漏洞的代码部分，潜在地提高了手动和自动代码审计的效率。在我们对四个大型代码库的实验中，Bran成功地突出了潜在的易受攻击的函数，超过了几个基准，包括最先进的漏洞预测工具。我们还评估了Bran在辅助自动化测试工具方面的有效性。我们使用Bran来指导syzkaller(一个著名的内核模糊化器)模糊化一个最新版本的Linux内核。制导引信识别出26个漏洞(10个是零日漏洞)，包括任意读写。",
        "title_zh": "麸皮：通过学习错误症状来减少大型开源存储库中的脆弱性搜索空间",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/asiaccs/asiaccs2021.html",
        "conf_title": "16th AsiaCCS 2021: Virtual Event, Hong Kong",
        "conf_url": "https://doi.org/10.1145/3433210",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3579856.3590331",
        "title": "Multi-Tag: A Hardware-Software Co-Design for Memory Safety based on Multi-Granular Memory Tagging",
        "authors": "Martin Unterguggenberger, David Schrammel, Pascal Nasahl, Robert Schilling, Lukas Lamster, Stefan Mangard",
        "abstract": "Memory safety vulnerabilities are a severe threat to modern computer systems allowing adversaries to leak or modify security-critical data. To protect systems from this attack vector, full memory safety is required. As software-based countermeasures tend to induce significant runtime overheads, which is not acceptable for production code, hardware assistance is needed. Tagged memory architectures, e.g., already offered by the ARM MTE and SPARC ADI extensions, assign meta-information to memory objects, thus allowing to implement memory safety policies. However, due to the high tag collision probability caused by the small tag sizes, the protection guarantees of these schemes are limited. This paper presents Multi-Tag, the first hardware-software co-design utilizing a multi-granular tagging structure that provides strong protection against spatial and temporal memory safety violations. By combining object-granular memory tags with page-granular tags stored in the page table entries, Multi-Tag overcomes the limitation of small tag sizes. Introducing page-granular tags significantly enhances the probabilistic protection capabilities of memory tagging without increasing the memory overhead or the system’s complexity. We develop a prototype implementation comprising a gem5 model of the tagged architecture, a Linux kernel extension, and an LLVM-based compiler toolchain. The simulated performance overhead for the SPEC CPU2017 and nbench-byte benchmarks highlights the practicability of our design.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "多标签:一种基于多粒度存储标签的软硬件协同设计",
        "abstract_zh": "内存安全漏洞是对现代计算机系统的严重威胁，它允许对手泄漏或修改安全关键数据。为了保护系统免受这种攻击，需要完全的内存安全。由于基于软件的对策往往会导致显著的运行时开销，这对于生产代码来说是不可接受的，因此需要硬件辅助。例如，ARM MTE和SPARC ADI扩展已经提供的标记存储器架构将元信息分配给存储器对象，从而允许实施存储器安全策略。然而，由于小标签尺寸导致的高标签冲突概率，这些方案的保护保证是有限的。本文介绍了Multi-Tag，这是第一个利用多粒度标记结构的软硬件协同设计，可针对空间和时间内存安全违规提供强大的保护。通过将存储在页表条目中的对象粒度存储器标签与页粒度标签相结合，多标签克服了小标签尺寸的限制。引入页面粒度标记显著增强了存储器标记的概率保护能力，而不增加存储器开销或系统的复杂性。我们开发了一个原型实现，包括一个标记架构的gem5模型、一个Linux内核扩展和一个基于LLVM的编译器工具链。SPEC CPU2017和nbench-byte基准的模拟性能开销凸显了我们设计的实用性。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/asiaccs/asiaccs2023.html",
        "conf_title": "18th AsiaCCS 2023:\nMelbourne, VIC, Australia",
        "conf_url": "https://doi.org/10.1145/3579856",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3507657.3528548",
        "title": "On the Robustness of Wi-Fi Deauthentication Countermeasures",
        "authors": "Domien Schepers, Aanjhan Ranganathan, Mathy Vanhoef",
        "abstract": "With the introduction of WPA3 and Wi-Fi 6, an increased usage of Wi-Fi Management Frame Protection (MFP) is expected. Wi-Fi MFP, defined in IEEE 802.11w, protects robust management frames by providing data confidentiality, integrity, origin authenticity, and replay protection. One of its key goals is to prevent deauthentication attacks in which an adversary forcibly disconnects a client from the network. In this paper, we inspect the standard and its implementations for their robustness and protection against deauthentication attacks. In our standard analysis, we inspect the rules for processing robust management frames on their completeness, consistency, and security, leading to the discovery of unspecified cases, contradictory rules, and revealed insecure rules that lead to new denial-of-service vulnerabilities. We then inspect implementations and identify vulnerabilities in clients and access points running on the latest versions of the Linux kernel, hostap, IWD, Apple (i.e., macOS, iOS, iPadOS), Windows, and Android. Altogether, these vulnerabilities allow an adversary to disconnect any client from personal and enterprise networks despite the usage of MFP. Our work highlights that management frame protection is insufficient to prevent deauthentication attacks, and therefore more care is needed to mitigate attacks of this kind. In order to address the identified shortcomings, we worked with industry partners to propose updates to the IEEE 802.11 standard.",
        "files": {
            "openAccessPdf": "https://lirias.kuleuven.be/bitstream/20.500.12942/697745/2/wisec2022.pdf"
        },
        "abstract_zh": "随着WPA3和Wi-Fi 6的推出，预计Wi-Fi管理帧保护(MFP)的使用将会增加。IEEE 802.11w中定义的Wi-Fi MFP通过提供数据机密性、完整性、来源真实性和重放保护来保护健壮的管理帧。它的主要目标之一是防止身份验证攻击，在这种攻击中，对手会强行断开客户端与网络的连接。在本文中，我们检查了该标准及其实现的健壮性和对解除认证攻击的保护。在我们的标准分析中，我们检查用于处理健壮管理帧的规则的完整性、一致性和安全性，从而发现未指定的情况、矛盾的规则以及导致新的拒绝服务漏洞的不安全规则。然后，我们检查实施情况，并识别在最新版本的Linux内核、hostap、IWD、苹果(即macOS、iOS、iPadOS)、Windows和Android上运行的客户端和接入点中的漏洞。总之，尽管使用了MFP，这些漏洞仍允许对手断开任何客户端与个人和企业网络的连接。我们的工作强调了管理帧保护不足以防止去认证攻击，因此需要更加小心来减轻这种攻击。为了解决已确定的缺点，我们与行业合作伙伴一起提出了IEEE 802.11标准的更新。",
        "title_zh": "Wi-Fi认证对抗措施的鲁棒性研究",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/wisec/wisec2022.html",
        "conf_title": "15th WISEC 2022: San Antonio, TX, USA",
        "conf_url": "https://doi.org/10.1145/3507657",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1016/j.cose.2018.08.011",
        "title": "Freeze and Crypt: Linux kernel support for main memory encryption",
        "authors": "Manuel Huber, Julian Horsch, Junaid Ali, Sascha Wessel",
        "abstract": "",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "",
        "title_zh": "冻结和加密:Linux内核对主内存加密的支持",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/compsec/compsec86.html",
        "conf_title": "Computers & Security, Volume 86",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/woot20/presentation/cho",
        "title": "Exploiting Uses of Uninitialized Stack Variables in Linux Kernels to Leak Kernel Pointers",
        "authors": "Haehyun Cho, Jinbum Park, Joonwon Kang, Tiffany Bao, Ruoyu Wang, Yan Shoshitaishvili, Adam Doupé, Gail-Joon Ahn",
        "abstract": "Information leaks are the most prevalent type of vulnerabilities among all known vulnerabilities in Linux kernel. Many of them are caused by the use of uninitialized variables or data structures. It is generally believed that the majority of information leaks in Linux kernel are low-risk and do not have severe impact due to the difﬁculty (or even the impos-sibility) of exploitation. As a result, developers and security analysts do not pay enough attention to mitigating these vulnerabilities. Consequently, these vulnerabilities are usually assigned low CVSS scores or without any CVEs assigned. Moreover, many patches that address uninitialized data use bugs in Linux kernel are not accepted, leaving billions of Linux systems vulnerable. Nonetheless, information leak vulnerabilities in Linux kernel are not as low-risk as people believe. In this paper, we present a generic approach that converts stack-based information leaks in Linux kernel into kernel-pointer leaks, which can be used to defeat modern security defenses such as KASLR. Taking an exploit that triggers an information leak in Linux kernel, our approach automatically converts it into a highly impactful exploit that leaks pointers to either kernel functions or the kernel stack. We evaluate our approach on four known CVEs and one security patch in Linux kernel and demonstrate its effectiveness. Our ﬁndings provide solid evidence for Linux kernel developers and security analysts to treat information leaks in Linux kernel more seriously.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "信息泄漏是Linux内核中所有已知漏洞中最普遍的一种。其中许多是由于使用了未初始化的变量或数据结构造成的。人们普遍认为，Linux内核中的大多数信息泄漏都是低风险的，由于利用的难度(甚至是不可能的)而不会产生严重影响。因此，开发人员和安全分析师没有足够重视减少这些漏洞。因此，这些漏洞通常被赋予较低的CVSS分数，或者没有任何CVE。此外，许多解决Linux内核中未初始化数据使用错误的补丁不被接受，导致数十亿Linux系统易受攻击。尽管如此，Linux内核中的信息泄露漏洞并不像人们认为的那样低风险。在本文中，我们提出了一种通用的方法，将Linux内核中基于堆栈的信息泄漏转换为内核指针泄漏，这种方法可以用来击败现代安全防御，如KASLR。以一个在Linux内核中触发信息泄漏的漏洞为例，我们的方法自动将其转换为一个高度有效的漏洞，该漏洞会泄漏指向内核函数或内核堆栈的指针。我们在四个已知的CVEs和一个Linux内核安全补丁上评估了我们的方法，并证明了它的有效性。我们的发现为Linux内核开发者和安全分析师更严肃地对待Linux内核中的信息泄漏提供了坚实的证据。",
        "title_zh": "利用Linux内核中未初始化的堆栈变量来泄漏内核指针",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/woot/woot2020.html",
        "conf_title": "14th WOOT @ USENIX Security Symposium 2020",
        "conf_url": "https://www.usenix.org/conference/woot20",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity20/presentation/chen-weiteng",
        "title": "KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities",
        "authors": "Weiteng Chen, Xiaochen Zou, Guoren Li, Zhiyun Qian",
        "abstract": "The monolithic nature of modern OS kernels leads to a constant stream of bugs being discovered. It is often unclear which of these bugs are worth fixing, as only a subset of them may be serious enough to lead to security takeovers (i.e., privilege escalations). Therefore, researchers have recently started to develop automated exploit generation techniques (for UAF bugs) to assist the bug triage process. In this paper, we investigate another top memory vulnerability in Linux kernel — out-of-bounds (OOB) memory write from heap. We design KOOBE to assist the analysis of such vulnerabilities based on two observations: (1) Surprisingly often, different OOB vulnerability instances exhibit a wide range of capabilities. (2) Kernel exploits are multi-interaction in nature (i.e., multiple syscalls are involved in an exploit) which allows the exploit crafting process to be modular. Specifically, we focus on the extraction of capabilities of an OOB vulnerability which will feed the subsequent exploitability evaluation process. Our system builds on several building blocks, including a novel capability-guided fuzzing solution to uncover hidden capabilities, and a way to compose capabilities together to further enhance the likelihood of successful exploitations. In our evaluation, we demonstrate the applicability of KOOBE by exhaustively analyzing 17 most recent Linux kernel OOB vulnerabilities (where only 5 of them have publicly available exploits), for which KOOBE successfully generated candidate exploit strategies for 11 of them (including 5 that do not even have any CVEs assigned). Subsequently from these strategies, we are able to construct fully working exploits for",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "现代操作系统内核的整体性导致不断发现错误。通常不清楚这些错误中哪些值得修复，因为只有其中的一部分可能严重到足以导致安全接管(即权限提升)。因此，研究人员最近开始开发自动漏洞利用生成技术(针对UAF漏洞)来帮助漏洞分类过程。在本文中，我们研究了Linux内核中的另一个顶级内存漏洞——从堆中进行越界(OOB)内存写入。我们设计KOOBE是为了基于两个观察来帮助分析这种漏洞:(1)令人惊讶的是，不同的OOB漏洞实例通常表现出各种各样的能力。(2)内核漏洞利用本质上是多交互的(即，在一个漏洞利用中涉及多个系统调用)，这允许漏洞利用制作过程模块化。具体来说，我们专注于提取OOB漏洞的能力，这将为后续的可利用性评估过程提供信息。我们的系统建立在几个构建模块上，包括一个新颖的能力导向的模糊解决方案，以发现隐藏的能力，以及一种将能力组合在一起的方法，以进一步提高成功利用的可能性。在我们的评估中，我们通过详尽分析17个最新的Linux内核OOB漏洞(其中只有5个漏洞具有公开可用的漏洞)，证明了KOOBE的适用性，KOOBE成功地为其中11个漏洞(包括5个甚至没有分配任何CVE的漏洞)生成了候选漏洞利用策略。随后从这些策略，我们能够构建完全工作的利用",
        "title_zh": "KOOBE:促进内核越界写入漏洞的利用",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2020.html",
        "conf_title": "29th USENIX Security Symposium 2020",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity20",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity20/presentation/ghavamnia",
        "title": "Temporal System Call Specialization for Attack Surface Reduction",
        "authors": "Seyedhamed Ghavamnia, Tapti Palit, Shachee Mishra, Michalis Polychronakis",
        "abstract": "Attack surface reduction through the removal of unnecessary application features and code is a promising technique for improving security without incurring any additional overhead. Recent software debloating techniques consider an application’s entire lifetime when extracting its code requirements, and reduce the attack surface accordingly. In this paper, we present temporal specialization , a novel approach for limiting the set of system calls available to a process depending on its phase of execution. Our approach is tailored to server applications, which exhibit distinct initialization and serving phases with different system call requirements. We present novel static analysis techniques for improving the precision of extracting the application’s call graph for each execution phase, which is then used to pinpoint the system calls used in each phase. We show that requirements change throughout the lifetime of servers, and many dangerous system calls (such as execve ) can be disabled after the completion of the initialization phase. We have implemented a prototype of temporal specialization on top of the LLVM compiler, and evaluated its effectiveness with six popular server applications. Our results show that it disables 51% more security-critical system calls compared to existing library specialization approaches, while offering the additional beneﬁt of neutralizing 13 more Linux kernel vulnerabilities that could lead to privilege escalation.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "通过删除不必要的应用程序功能和代码来减少攻击面是一种很有前途的技术，可以在不增加任何额外开销的情况下提高安全性。最近的软件去模糊技术在提取其代码需求时考虑了应用程序的整个生命周期，并相应地减少了攻击面。在本文中，我们提出了时间专门化，这是一种根据进程的执行阶段来限制进程可用的系统调用集的新方法。我们的方法是为服务器应用程序量身定制的，这些应用程序展示了不同的初始化和服务阶段以及不同的系统调用需求。我们提出了新的静态分析技术，用于提高提取每个执行阶段的应用程序调用图的精度，然后使用它来查明每个阶段中使用的系统调用。我们表明需求在服务器的整个生命周期中是变化的，在初始化阶段完成后，许多危险的系统调用(如execve)可以被禁用。我们在LLVM编译器上实现了一个时态专门化的原型，并用六个流行的服务器应用程序评估了它的有效性。我们的结果表明，与现有的库专门化方法相比，它禁用了51%以上的安全关键系统调用，同时提供了额外的好处，即消除了13个以上可能导致权限提升的Linux内核漏洞。",
        "title_zh": "用于攻击面缩减的时态系统调用专门化",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2020.html",
        "conf_title": "29th USENIX Security Symposium 2020",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity20",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity20/presentation/peng",
        "title": "USBFuzz: A Framework for Fuzzing USB Drivers by Device Emulation",
        "authors": "Hui Peng, Mathias Payer",
        "abstract": "The Universal Serial Bus (USB) connects external devices to a host. This interface exposes the OS kernels and device drivers to attacks by malicious devices. Unfortunately, kernels and drivers were developed under a security model that implicitly trusts connected devices. Drivers expect faulty hardware but not malicious attacks. Similarly, security testing drivers is challenging as input must cross the hardware/software barrier. Fuzzing, the most widely used bug finding technique, relies on providing random data to programs. However, fuzzing device drivers is challenging due to the difficulty in crossing the hardware/software barrier and providing random device data to the driver under test. We present USBFuzz, a portable, flexible, and modular framework for fuzz testing USB drivers. At its core, USBFuzz uses a software-emulated USB device to provide random device data to drivers (when they perform IO operations). As the emulated USB device works at the device level, porting it to other platforms is straight-forward. Using the USBFuzz framework, we apply (i) coverage-guided fuzzing to a broad range of USB drivers in the Linux kernel; (ii) dumb fuzzing in FreeBSD, MacOS, and Windows through cross-pollination seeded by the Linux inputs; and (iii) focused fuzzing of a USB webcam driver. USBFuzz discovered a total of 26 new bugs, including 16 memory bugs of high security impact in various Linux subsystems (USB core, USB sound, and network), one bug in FreeBSD, three in MacOS (two resulting in an unplanned reboot and one freezing the system), and four in Windows 8 and Windows 10 (resulting in Blue Screens of Death), and one bug in the Linux USB host controller driver and another one in a USB camera driver. From the Linux bugs, we have fixed and upstreamed 11 bugs and received 10 CVEs.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "通用串行总线(USB)将外部设备连接到主机。该接口将OS内核和设备驱动程序暴露给恶意设备的攻击。不幸的是，内核和驱动程序是在隐式信任连接设备的安全模型下开发的。驱动程序期待有故障的硬件，但不是恶意攻击。同样，安全测试驱动程序也很有挑战性，因为输入必须跨越硬件/软件障碍。Fuzzing是最广泛使用的bug查找技术，它依赖于向程序提供随机数据。然而，模糊设备驱动程序是具有挑战性的，因为很难跨越硬件/软件障碍，并向测试中的驱动程序提供随机设备数据。我们提出了USBFuzz，一个可移植的、灵活的、模块化的框架，用于模糊测试USB驱动程序。其核心是，USBFuzz使用软件模拟的USB设备向驱动程序提供随机设备数据(当它们执行IO操作时)。由于仿真USB设备在设备级工作，因此将其移植到其他平台非常简单。使用USBFuzz框架，我们将(I)覆盖引导模糊化应用于Linux内核中广泛的USB驱动程序；(ii)在FreeBSD、MacOS和Windows中，通过由Linux输入播下的交叉授粉产生的哑模糊；以及(iii)USB网络摄像头驱动程序的集中模糊化。USBFuzz总共发现了26个新错误，包括各种Linux子系统(USB核心、USB声音和网络)中的16个高安全性影响的内存错误，FreeBSD中的一个错误，MacOS中的三个错误(两个导致计划外重启，一个导致系统冻结)，Windows 8和Windows 10中的四个错误(导致蓝屏死机)，Linux USB主机控制器驱动程序中的一个错误和USB摄像头驱动程序中的另一个错误。从Linux的错误，我们已经修复和上游11个错误，并收到10个CVE。",
        "title_zh": "USBFuzz:通过设备仿真模糊USB驱动程序的框架",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2020.html",
        "conf_title": "29th USENIX Security Symposium 2020",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity20",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity21/presentation/wu-qiushi",
        "title": "Understanding and Detecting Disordered Error Handling with Precise Function Pairing",
        "authors": "Qiushi Wu, Aditya Pakki, Navid Emamdoost, Stephen McCamant, Kangjie Lu",
        "abstract": "Software programs may frequently encounter various errors such as allocation failures. Error handling aims to gracefully deal with the errors to avoid security and reliability issues, thus it is prevalent and vital. However, because of its complexity and corner cases, error handling itself is often erroneous, and prior research has primarily focused on finding bugs in the handling part, such as incorrect error-code returning or missing error propagation. In this paper, we propose and investigate a class of bugs in error-handling code from a different perspective. In particular, we find that programs often perform “cleanup” operations before the actual error handling, such as freeing memory or decreasing refcount. Critical bugs occur when these operations are performed (1) in an incorrect order, (2) redundantly, or (3) inadequately. We refer to such bugs as Disordered Error Handling (DiEH). Our investigation reveals that DiEH bugs are not only common but can also cause security problems such as privilege escalation, memory corruption, and denial-of-service. Based on the findings from the investigation, we then develop a system, HERO (Handling ERrors Orderly), to automatically detect DiEH. The core of HERO is a novel technique that precisely pairs both common and custom functions based on the unique error-handling structures, which allows us to infer expected cleanup functions. With HERO, we found 239 DiEH bugs in the Linux kernel, the FreeBSD kernel, and OpenSSL, which can cause security and reliability issues. The evaluation results show that DiEH is critical and widely exists in system software, and HERO is effective in detecting DiEH. We also believe that the precise function pairing is of independent interest in other research areas such as temporal-rule inference and race detection.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "软件程序可能经常遇到各种错误，例如分配失败。错误处理旨在优雅地处理错误，以避免安全和可靠性问题，因此它是普遍和重要的。然而，由于其复杂性和极端情况，错误处理本身经常是错误的，先前的研究主要集中在寻找处理部分的错误，例如不正确的错误代码返回或丢失错误传播。在本文中，我们从不同的角度提出并研究了错误处理代码中的一类错误。特别是，我们发现程序经常在实际的错误处理之前执行“清理”操作，比如释放内存或减少refcount。当这些操作(1)以不正确的顺序执行，(2)冗余地执行，或(3)不充分地执行时，就会出现严重的错误。我们把这种错误称为无序错误处理(DiEH)。我们的调查显示，DiEH bugs不仅很常见，还会导致安全问题，如权限提升、内存损坏和拒绝服务。基于调查结果，我们开发了一个系统HERO(有序处理错误)来自动检测DiEH。HERO的核心是一种新颖的技术，它基于独特的错误处理结构精确地配对公共函数和定制函数，这允许我们推断出预期的清理函数。使用HERO，我们在Linux内核、FreeBSD内核和OpenSSL中发现了239个DiEH bugs，这些bug会导致安全性和可靠性问题。评估结果表明，DiEH是关键的，广泛存在于系统软件中，HERO检测DiEH是有效的。我们还认为，精确的函数配对在其他研究领域，如时序规则推理和竞争检测中也是独立的。",
        "title_zh": "通过精确的函数配对来理解和检测无序的错误处理",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2021.html",
        "conf_title": "30th USENIX Security Symposium 2021",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity21",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity21/presentation/kirzner",
        "title": "An Analysis of Speculative Type Confusion Vulnerabilities in the Wild",
        "authors": "Ofek Kirzner, Adam Morrison",
        "abstract": "Spectre v1 attacks, which exploit conditional branch misprediction, are often identified with attacks that bypass array bounds checking to leak data from a victim’s memory. Generally, however, Spectre v1 attacks can exploit any conditional branch misprediction that makes the victim execute code incorrectly. In this paper, we investigate speculative type confusion, a Spectre v1 attack vector in which branch mispredictions make the victim execute with variables holding values of the wrong type and thereby leak memory content. We observe that speculative type confusion can be inadvertently introduced by a compiler, making it extremely hard for programmers to reason about security and manually apply Spectre mitigations. We thus set out to determine the extent to which speculative type confusion affects the Linux kernel. Our analysis finds exploitable and potentially-exploitable arbitrary memory disclosure vulnerabilities. We also find many latent vulnerabilities, which could become exploitable due to innocuous system changes, such as coding style changes. Our results suggest that Spectre mitigations which rely on statically/manually identifying “bad” code patterns need to be rethought, and more comprehensive mitigations are needed.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "利用条件分支错误预测的Spectre v1攻击通常被认为是绕过数组边界检查从受害者内存中泄漏数据的攻击。但是，一般来说，Spectre v1攻击可以利用任何条件分支预测失误，使受害者错误地执行代码。在本文中，我们研究了推测性类型混淆，这是一种Spectre v1攻击载体，在这种载体中，分支错误预测使受害者执行包含错误类型值的变量，从而泄漏内存内容。我们观察到，编译器可能会无意中引入推测性的类型混淆，这使得程序员很难考虑安全性并手动应用Spectre缓解措施。因此，我们开始确定推测性类型混淆对Linux内核的影响程度。我们的分析发现了可利用和潜在可利用的任意内存泄漏漏洞。我们还发现了许多潜在的漏洞，由于无害的系统更改，如编码风格的更改，这些漏洞可能会被利用。我们的结果表明，依赖于静态/手动识别“坏”代码模式的Spectre缓解需要重新考虑，并且需要更全面的缓解。",
        "title_zh": "野外推测型混淆漏洞分析",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2021.html",
        "conf_title": "30th USENIX Security Symposium 2021",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity21",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity21/presentation/tan",
        "title": "Detecting Kernel Refcount Bugs with Two-Dimensional Consistency Checking",
        "authors": "Xin Tan, Yuan Zhang, Xiyu Yang, Kangjie Lu, Min Yang",
        "abstract": "In the Linux kernel, reference counting (refcount) has be-come a default mechanism that manages resource objects. A refcount of a tracked object is incremented when a new reference is assigned and decremented when a reference becomes invalid. Since the kernel manages a large number of shared resources, refcount is prevalent. Due to the inherent complexity of the kernel and resource sharing, developers often fail to properly update refcounts, leading to refcount bugs. Researchers have shown that refcount bugs can cause critical security impacts like privilege escalation; however, the detection of refcount bugs remains an open problem. In this paper, we propose CID , a new mechanism that employs two-dimensional consistency checking to automatically detect refcount bugs. By checking if callers consistently use a refcount function, CID detects deviating cases as potential bugs, and by checking how a caller uses a refcount function, CID infers the condition-aware rules for the function to corre-spondingly operate the refcount, and thus a violating case is a potential bug. More importantly, CID ’s consistency checking does not require complicated semantic understanding, inter-procedural data-ﬂow tracing, or refcount-operation reasoning. CID also features an automated mechanism that systematically identiﬁes refcount ﬁelds and functions in the whole kernel. We implement CID and apply it to the Linux kernel. The tool found 44 new refcount bugs that may cause severe security issues, most of which have been conﬁrmed by the maintainers.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "在Linux内核中，引用计数(refcount)已经成为管理资源对象的默认机制。被跟踪对象的refcount在新引用被赋值时递增，在引用变得无效时递减。由于内核管理着大量的共享资源，所以refcount很普遍。由于内核和资源共享固有的复杂性，开发人员经常无法正确更新引用计数，从而导致引用计数错误。研究人员已经表明，引用计数错误会导致严重的安全影响，如权限提升；然而，检测引用计数错误仍然是一个公开的问题。在本文中，我们提出了CID，一种采用二维一致性检查来自动检测引用计数错误的新机制。通过检查调用者是否一致地使用refcount函数，CID将偏离的情况检测为潜在的错误，并且通过检查调用者如何使用refcount函数，CID推断该函数的条件感知规则以相应地操作refcount，因此违反的情况是潜在的错误。更重要的是，CID的一致性检查不需要复杂的语义理解、过程间数据流跟踪或引用操作推理。CID还具有自动机制，可以系统地识别整个内核中的引用计数字段和函数。我们实现了CID并将其应用于Linux内核。该工具发现了44个新的refcount错误，可能会导致严重的安全问题，其中大多数已经由维护人员确认。",
        "title_zh": "利用二维一致性检查检测内核引用计数错误",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2021.html",
        "conf_title": "30th USENIX Security Symposium 2021",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity21",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity21/presentation/wang-daimeng",
        "title": "SyzVegas: Beating Kernel Fuzzing Odds with Reinforcement Learning",
        "authors": "Daimeng Wang, Zheng Zhang, Hang Zhang, Zhiyun Qian, Srikanth V. Krishnamurthy, Nael B. Abu-Ghazaleh",
        "abstract": "Fuzzing embeds a large number of decisions requiring finetuned and hard-coded parameters to maximize its efficiency. This is especially true for kernel fuzzing due to (1) OS kernels’ sheer size and complexity, (2) a unique syscall interface that requires special handling (e.g., encoding explicit dependencies among syscalls), and (3) behaviors of inputs (i.e., test cases) are often not reproducible due to the stateful nature of OS kernels. Hence, Syzkaller [14], the state-of-art gray-box kernel fuzzer, incorporates numerous procedures, decision points, and hard-coded parameters master-crafted by domain experts. Unfortunately, hard-coded strategies cannot adjust to factors such as different fuzzing environments/targets and the dynamically changing potency of tasks and/or seeds, limiting the overall effectiveness of the fuzzer. In this paper, we propose SYZVEGAS, a fuzzer that dynamically and automatically adapts two of the most critical decision points in Syzkaller, task selection and seed selection, to remarkably improve coverage reached per unit-time. SYZVEGAS’s adaptation leverages multi-armed-bandit (MAB) algorithms along with a novel reward assessment model. Our extensive evaluations of SYZVEGAS on the latest Linux Kernel and its subsystems demonstrate that it (i) finds up to 38.7% more coverage than the default Syzkaller, (ii) better discovers bugs/crashes (8 more unique crashes) and (iii) has very low 2.1% performance overhead. We reported our findings to Google’s Syzkaller team and are actively working on pushing our changes upstream.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "Fuzzing嵌入了大量需要微调和硬编码参数的决策，以最大化其效率。由于(1) OS内核的庞大规模和复杂性，(2)需要特殊处理的独特的系统调用接口(例如，对系统调用之间的显式依赖性进行编码)，以及(3)由于OS内核的状态性质，输入的行为(即，测试用例)通常是不可再现的，这对于内核模糊化来说尤其如此。因此，Syzkaller [14]是最先进的灰盒内核模糊器，它包含了由领域专家精心制作的大量过程、决策点和硬编码参数。不幸的是，硬编码策略不能适应各种因素，如不同的引信环境/目标以及任务和/或种子的动态变化能力，从而限制了引信的整体效能。在本文中，我们提出了SYZVEGAS，它是一个fuzzer，可以动态地自动适应Syzkaller中两个最关键的决策点，任务选择和种子选择，以显著提高单位时间内的覆盖率。SYZVEGAS的改编利用了多臂土匪(MAB)算法以及一种新颖的奖励评估模型。我们在最新的Linux内核及其子系统上对SYZVEGAS进行了广泛的评估，结果表明，它(I)比默认的Syzkaller多发现了38.7%的覆盖率，(ii)更好地发现了错误/崩溃(多了8个独特的崩溃)，以及(iii)具有非常低的2.1%的性能开销。我们向谷歌的Syzkaller团队报告了我们的发现，并积极推动我们的变革。",
        "title_zh": "SyzVegas:用强化学习击败内核模糊几率",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2021.html",
        "conf_title": "30th USENIX Security Symposium 2021",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity21",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity22/presentation/zeng",
        "title": "Playing for K(H)eaps: Understanding and Improving Linux Kernel Exploit Reliability",
        "authors": "Kyle Zeng, Yueqi Chen, Haehyun Cho, Xinyu Xing, Adam Doupé, Yan Shoshitaishvili, Tiffany Bao",
        "abstract": "The dynamic of the Linux kernel heap layout signiﬁcantly impacts the reliability of kernel heap exploits, making exploitability assessment challenging. Though techniques have been proposed to stabilize exploits in the past, little scientiﬁc research has been conducted to evaluate their effectiveness and explore their working conditions. In this paper, we present a systematic study of the kernel heap exploit reliability problem. We ﬁrst interview kernel security experts, gathering commonly adopted exploitation stabilization techniques and expert opinions about these techniques. We then evaluate these stabilization techniques on 17 real-world kernel heap exploits. The results indicate that many kernel security experts have incorrect opinions on exploitation stabilization techniques. To help the security community better understand exploitation stabilization, we inspect our experiment results and design a generic kernel heap exploit model. We use the proposed exploit model to interpret the exploitation unreliability issue and analyze why stabilization techniques succeed or fail. We also leverage the model to propose a new exploitation technique. Our experiment indicates that the new stabilization technique improves Linux kernel exploit reliability by 14.87% on average. Combining this newly proposed technique with existing stabilization approaches produces a composite stabilization method that achieves a 135.53% exploitation reliability improvement on average, outperforming exploit stabilization by professional security researchers by 67.86%.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "Linux内核堆布局的动态性显著影响内核堆利用的可靠性，使得可利用性评估具有挑战性。虽然在过去已经提出了稳定开采的技术，但是很少进行科学研究来评估它们的有效性和探索它们的工作条件。本文对内核堆利用可靠性问题进行了系统的研究。我们首先采访内核安全专家，收集普遍采用的漏洞利用稳定技术和专家对这些技术的看法。然后，我们在17个真实世界的内核堆漏洞上评估这些稳定技术。结果表明，许多内核安全专家对利用稳定技术有不正确的看法。为了帮助安全社区更好地理解利用稳定性，我们检查了我们的实验结果，并设计了一个通用的内核堆利用模型。我们使用提出的利用模型来解释利用不可靠性问题，并分析稳定技术成功或失败的原因。我们还利用该模型提出了一种新的开发技术。实验表明，新的稳定技术平均提高了Linux内核开发可靠性14.87%。将这种新提出的技术与现有的稳定方法相结合，产生了一种复合稳定方法，平均实现了135.53%的利用可靠性改进，优于专业安全研究人员67.86%的利用稳定性。",
        "title_zh": "为K(H)eaps而战:理解和提高Linux内核漏洞利用的可靠性",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2022.html",
        "conf_title": "31st USENIX Security Symposium 2022",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity22",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity22/presentation/liu-jian",
        "title": "LinKRID: Vetting Imbalance Reference Counting in Linux kernel with Symbolic Execution",
        "authors": "Jian Liu, Lin Yi, Weiteng Chen, Chengyu Song, Zhiyun Qian, Qiuping Yi",
        "abstract": "Linux kernel employs reference counters, which record the number of references to a shared kernel object, to track its lifecycle and prevent memory errors like use-after-free. How-ever, the usage of reference counters can be tricky and often error-prone, especially considering unique kernel conventions of managing reference counters (e.g., external vs. internal reference counters). In this paper, we aim to automatically discover incorrect usage of reference counters, overcoming two key challenges: (1) scalability and (2) the aforementioned unique kernel conventions. Specifically, we develop a tiered program analysis based solution to efficiently and precisely check the imbalances between the change in the actual number of references and the corresponding reference counter. We apply our tool to the 4.14.0 kernel (with allyesconfig) and find 118 bugs, out of which 87 are new. The result shows our tool is scalable and effective.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "Linux内核使用引用计数器来记录对共享内核对象的引用次数，以跟踪其生命周期并防止像释放后使用这样的内存错误。然而，引用计数器的使用可能很棘手，而且经常容易出错，尤其是考虑到管理引用计数器的独特内核约定(例如，外部与内部引用计数器)。在本文中，我们的目标是自动发现引用计数器的不正确使用，克服两个关键挑战:(1)可伸缩性和(2)上述独特的内核约定。具体来说，我们开发了一个基于分层程序分析的解决方案，以有效和精确地检查实际引用数和相应的引用计数器之间的不平衡。我们将我们的工具应用于4.14.0内核(使用allyesconfig ),发现了118个bug，其中87个是新的。结果表明我们的工具是可扩展的和有效的。",
        "title_zh": "LinKRID:用符号执行检查Linux内核中的不平衡引用计数",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2022.html",
        "conf_title": "31st USENIX Security Symposium 2022",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity22",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity22/presentation/wu-qiushi",
        "title": "OS-Aware Vulnerability Prioritization via Differential Severity Analysis",
        "authors": "Qiushi Wu, Yue Xiao, Xiaojing Liao, Kangjie Lu",
        "abstract": "The Linux kernel is quickly evolving and extensively cus-tomized. This results in thousands of versions and derivatives. Unfortunately, the Linux kernel is quite vulnerable. Each year, thousands of bugs are reported, and hundreds of them are security-related bugs. Given the limited resources, the kernel maintainers have to prioritize patching the more severe vulnerabilities. In practice, Common Vulnerability Scoring System (CVSS) [1] has become the standard for characterizing vulnerability severity. However, a fundamental problem exists when CVSS meets Linux—it is used in a “one for all” manner. The severity of a Linux vulnerability is assessed for only the mainstream Linux, and all affected versions and derivatives will simply honor and reuse the CVSS score. Such an undistinguished CVSS usage results in underestimation or overestimation of severity, which further results in delayed and ignored patching or wastes of the precious resources. In this paper, we propose OS-aware vulnerability prioritization (namely D IFF CVSS), which employs differential severity analysis for vulnerabilities. Specifically, given a severity-assessed vulnerability, as well as the mainstream version and a target version of Linux, D IFF CVSS employs multiple new techniques based on static program analysis and natural language processing to differentially identify whether the vulnerability manifests a higher or lower severity in the target version. A unique strength of this approach is that it transforms the challenging and laborious CVSS calculation into automatable differential analysis. We implement D IFF CVSS and apply it to the mainstream Linux and downstream Android systems. The evaluation and user-study results show that D IFF CVSS is able to precisely perform the differential severity analysis, and offers a precise and effective way to identify vulnerabilities that deserve a severity reevaluation.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "Linux内核正在快速发展并被广泛定制。这导致了数以千计的版本和衍生物。不幸的是，Linux内核非常脆弱。每年都有成千上万的错误被报告，其中数百个是与安全相关的错误。鉴于资源有限，内核维护人员必须优先修补更严重的漏洞。在实践中，通用漏洞评分系统(CVSS) [1]已经成为描述漏洞严重性的标准。然而，当CVSS遇到Linux时，存在一个根本的问题——它是以“一个对所有”的方式使用的。Linux漏洞的严重性仅针对主流Linux进行评估，所有受影响的版本和衍生版本将简单地遵守和重用CVSS评分。这种不加区分的CVSS使用导致低估或高估严重性，这进一步导致宝贵资源的延迟和被忽略的修补或浪费。在本文中，我们提出了操作系统感知的漏洞优先级(即CVSS)，它采用不同的严重性分析漏洞。具体来说，给定一个严重性评估漏洞，以及Linux的主流版本和目标版本，CVSS敌我识别工具采用多种基于静态程序分析和自然语言处理的新技术，来区别识别漏洞在目标版本中表现出更高还是更低的严重性。这种方法的独特优势在于，它将具有挑战性且费力的CVSS计算转化为可自动化的微分分析。我们实现了CVSS，并将其应用于主流的Linux和下游的Android系统。评估和用户研究结果表明，CVSS迪夫能够精确地执行不同的严重性分析，并提供了一种精确和有效的方法来识别漏洞，值得严重性重新评估。",
        "title_zh": "通过不同严重性分析确定操作系统感知漏洞优先级",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2022.html",
        "conf_title": "31st USENIX Security Symposium 2022",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity22",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity22/presentation/lipp",
        "title": "AMD Prefetch Attacks through Power and Time",
        "authors": "Moritz Lipp, Daniel Gruss, Michael Schwarz",
        "abstract": "Modern operating systems fundamentally rely on the strict isolation of user applications from the kernel. This isolation is enforced by the hardware. On Intel CPUs, this isolation has been shown to be imperfect, for instance, with the prefetch side-channel. With Meltdown, it was even completely circum-vented. Both the prefetch side channel and Meltdown have been mitigated with the same software patch on Intel. As AMD is believed to be not vulnerable to these attacks, this software patch is not active by default on AMD CPUs. In this paper, we show that the isolation on AMD CPUs suffers from the same type of side-channel leakage. We discover timing and power variations of the prefetch instruction that can be observed from unprivileged user space. In contrast to previous work on prefetch attacks on Intel, we show that the prefetch instruction on AMD leaks even more information. We demonstrate the signiﬁcance of this side channel with multiple case studies in real-world scenarios. We demonstrate the ﬁrst microarchitectural break of (ﬁne-grained) KASLR on AMD CPUs. We monitor kernel activity, e.g., if audio is played over Bluetooth, and establish a covert channel. Finally, we even leak kernel memory with 52 . 85 B / s with simple Spectre gadgets in the Linux kernel. We show that stronger page table isolation should be activated on AMD CPUs by default to mitigate our presented attacks successfully.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "现代操作系统从根本上依赖于用户应用程序与内核的严格隔离。这种隔离是由硬件实施的。在Intel CPUs上，这种隔离已经被证明是不完美的，例如，对于预取边通道。随着熔毁，它甚至完全被包围。英特尔上的同一个软件补丁缓解了预取旁路和熔化问题。由于AMD被认为不易受到这些攻击，该软件补丁在AMD CPUs上默认是不活动的。在本文中，我们表明AMD CPUs上的隔离会遭受相同类型的侧通道泄漏。我们发现可以从非特权用户空间观察到的预取指令的时序和功率变化。与之前对英特尔预取攻击的研究相比，我们发现AMD的预取指令泄漏了更多的信息。我们通过现实场景中的多个案例研究，证明了这种旁道的重要性。我们展示了AMD CPUs上(细粒度)KASLR的首次微架构突破。我们监控内核活动，例如，音频是否通过蓝牙播放，并建立一个隐蔽通道。最后，我们甚至用52泄漏内核内存。85 B / s，Linux内核中有简单的Spectre小工具。我们表明，更强的页表隔离应该在AMD CPUs上默认激活，以成功缓解我们提出的攻击。",
        "title_zh": "AMD通过功率和时间预取攻击",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2022.html",
        "conf_title": "31st USENIX Security Symposium 2022",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity22",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity22/presentation/zou",
        "title": "SyzScope: Revealing High-Risk Security Impacts of Fuzzer-Exposed Bugs in Linux kernel",
        "authors": "Xiaochen Zou, Guoren Li, Weiteng Chen, Hang Zhang, Zhiyun Qian",
        "abstract": "Fuzzing has become one of the most effective bug ﬁnding approach for software. In recent years, 24*7 continuous fuzzing platforms have emerged to test critical pieces of software, e.g., Linux kernel. Though capable of discovering many bugs and providing reproducers ( e.g., proof-of-concepts), a major problem is that they neglect a critical function that should have been built-in, i.e., evaluation of a bug’s security impact. It is well-known that the lack of understanding of security impact can lead to delayed bug ﬁxes as well as patch propagation. In this paper, we develop SyzScope, a system that can automatically uncover new “high-risk” impacts given a bug with seemingly “low-risk” impacts. From analyzing over a thousand low-risk bugs on syzbot, SyzScope successfully determined that 183 low-risk bugs (more than 15%) in fact contain high-risk impacts, e.g., control ﬂow hijack and arbitrary memory write, some of which still do not have patches available yet.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "模糊化已经成为软件最有效的缺陷发现方法之一。近年来，出现了24*7连续模糊化平台来测试软件的关键部分，例如Linux内核。虽然能够发现许多bug并提供再现器(例如，概念证明)，但主要问题是它们忽略了一个本应内置的关键功能，即评估bug的安全影响。众所周知，缺乏对安全影响的理解会导致延迟的缺陷和补丁传播。在本文中，我们开发了SyzScope，这是一个可以自动发现新的“高风险”影响的系统，给出了一个看似“低风险”影响的bug。通过分析syzbot上的一千多个低风险错误，SyzScope成功确定了183个低风险错误(超过15%)实际上包含高风险影响，例如控制流劫持和任意内存写入，其中一些仍然没有可用的补丁。",
        "title_zh": "SyzScope:揭示Linux内核中暴露于Fuzzer的漏洞的高风险安全影响",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2022.html",
        "conf_title": "31st USENIX Security Symposium 2022",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity22",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity22/presentation/wikner",
        "title": "RETBLEED: Arbitrary Speculative Code Execution with Return Instructions",
        "authors": "Johannes Wikner, Kaveh Razavi",
        "abstract": "Modern operating systems rely on software defenses against hardware attacks. These defenses are, however, as good as the assumptions they make on the underlying hardware. In this paper, we invalidate some of the key assumptions behind retpoline , a widely deployed mitigation against Spectre Branch Target Injection (BTI) that converts vulnerable indirect branches to protected returns. We present R ETBLEED , a new Spectre-BTI attack that leaks arbitrary kernel memory on fully patched Intel and AMD systems. Two insights make R ETBLEED possible: ﬁrst, we show that return instructions behave like indirect branches under certain microarchitecture-dependent conditions, which we reverse engineer. Our dynamic analysis framework discovers many exploitable return instructions inside the Linux kernel, reach-able through unprivileged system calls. Second, we show how an unprivileged attacker can arbitrarily control the predicted target of such return instructions by branching into kernel memory. R ETBLEED leaks privileged memory at the rate of 219 bytes/s on Intel Coffee Lake and 3.9 kB/s on AMD Zen 2. Abstract Speculative execution attacks that exploit branch target injection (Spectre-BTI) have so far been limited to indirect branch instructions. R ETBLEED extends Spectre-BTI to return instructions. During our research into R ETBLEED , we discovered that certain AMD CPUs are also vulnerable to a new class of speculative execution attacks that we refer to as P HANTOM JMP S — incorrect branch target prediction in the absence of a corresponding branch instruction. Our investiga-tion so far shows that P HANTOM JMP S signiﬁcantly increases the attack surface of Spectre-BTI, but it is more difﬁcult to exploit under real-world conditions. This addendum brieﬂy discusses our ﬁndings and directions for future research.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "现代操作系统依靠软件防御硬件攻击。然而，这些防御措施与它们对底层硬件所做的假设一样好。在本文中，我们使retpoline背后的一些关键假设无效，ret poline是一种广泛部署的针对Spectre分支目标注入(BTI)的缓解措施，可将脆弱的间接分支转换为受保护的回报。我们提出了一种新的幽灵BTI攻击R ETBLEED，它在完全修补的Intel和AMD系统上泄漏任意内核内存。两个见解使R ETBLEED成为可能:首先，我们表明在某些微体系结构相关的条件下，返回指令的行为类似于间接分支，我们对此进行了逆向工程。我们的动态分析框架在Linux内核中发现了许多可利用的返回指令，这些指令可以通过非特权系统调用到达。其次，我们展示了无特权攻击者如何通过分支进入内核内存来任意控制这种返回指令的预测目标。R ETBLEED在Intel Coffee Lake上泄漏特权内存的速率为219字节/秒，在AMD Zen 2上为3.9 kB/秒。摘要利用分支目标注入(Spectre-BTI)的推测性执行攻击目前仅限于间接分支指令。R ETBLEED扩展Spectre-BTI返回指令。在我们对R ETBLEED的研究中，我们发现某些AMD CPUs也容易受到一种新的推测性执行攻击，我们称之为P HANTOM JMP攻击，即在没有相应分支指令的情况下不正确的分支目标预测。到目前为止，我们的调查显示，汉托姆·JMP显著增加了BTI幽灵的攻击面，但在现实条件下更难以利用。本附录简要讨论了我们的发现和未来研究的方向。",
        "title_zh": "RETBLEED:带有返回指令的任意推测性代码执行",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2022.html",
        "conf_title": "31st USENIX Security Symposium 2022",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity22",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity22/presentation/patel",
        "title": "Using Trātṛ to tame Adversarial Synchronization",
        "authors": "Yuvraj Patel, Chenhao Ye, Akshat Sinha, Abigail Matthews, Andrea C. Arpaci-Dusseau, Michael M. Swift",
        "abstract": "We show that Linux containers are vulnerable to a new class of attacks – synchronization attacks – that exploit kernel synchronization to harm application performance, where an unprivileged attacker can control the duration of kernel critical sections to stall victims running in other containers on the same operating system. Furthermore, a subset of these attacks – framing attacks – persistently harm performance by expanding data structures even after the attacker quiesces. We demonstrate three such attacks on the Linux kernel involving the inode cache, the directory cache, and the futex table. We design Tr ¯ atr . , a Linux kernel extension, to detect and mitigate synchronization and framing attacks with low overhead, prevent attacks from worsening, and recover by repairing data structures to their pre-attack state. Using microbenchmarks and real-world workloads, we show that Tr ¯ atr . can detect an attack within seconds and recover instantaneously, guaranteeing similar performance to baseline. Our experiments show that Tr¯atr . can detect simultaneous attacks and mitigate them with minimal overhead.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "我们表明，Linux容器容易受到一种新的攻击——同步攻击——这种攻击利用内核同步来损害应用程序的性能，在这种攻击中，无特权的攻击者可以控制内核关键部分的持续时间，以阻止受害者在同一操作系统上的其他容器中运行。此外，这些攻击的一个子集——帧攻击——通过扩展数据结构持续损害性能，即使在攻击者静止后也是如此。我们演示了Linux内核上的三种这样的攻击，涉及inode缓存、目录缓存和futex表。我们设计Tr atr。，一个Linux内核扩展，以低开销检测和减轻同步和成帧攻击，防止攻击恶化，并通过将数据结构修复到攻击前的状态来恢复。使用微基准测试和真实工作负载，我们展示了Tr atr。可以在几秒钟内检测到攻击并立即恢复，保证性能与基准相当。我们的实验表明Tr atr。可以检测同时发生的攻击，并以最小的开销缓解它们。",
        "title_zh": "利用Trātṛ驯服对抗性同步",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2022.html",
        "conf_title": "31st USENIX Security Symposium 2022",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity22",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity19/presentation/klein",
        "title": "From IP ID to Device ID and KASLR Bypass",
        "authors": "Amit Klein, Benny Pinkas",
        "abstract": "IP headers include a 16-bit ID field. Our work examines the generation of this field in Windows (versions 8 and higher), Linux and Android, and shows that the IP ID field enables remote servers to assign a unique ID to each device and thus be able to identify subsequent transmissions sent from that device. This identification works across all browsers and over network changes. In modern Linux and Android versions, this field leaks a kernel address, thus we also break KASLR. \nOur work includes reverse-engineering of the Windows IP ID generation code, and a cryptanalysis of this code and of the Linux kernel IP ID generation code. It provides practical techniques to partially extract the key used by each of these algorithms, overcoming different implementation issues, and observing that this key can identify individual devices. We deployed a demo (for Windows) showing that key extraction and machine fingerprinting works in the wild, and tested it from networks around the world.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "IP报头包括一个16位的ID字段。我们的工作检查了该字段在Windows(版本8和更高版本)、Linux和Android中的生成，并表明IP id字段使远程服务器能够为每个设备分配唯一的ID，从而能够识别从该设备发送的后续传输。这种识别适用于所有浏览器和网络变化。在现代的Linux和Android版本中，这个字段泄漏了一个内核地址，因此我们也破坏了KASLR。\n我们的工作包括Windows IP ID生成代码的逆向工程，以及对该代码和Linux内核IP ID生成代码的密码分析。它提供了部分提取这些算法所使用的密钥的实用技术，克服了不同的实现问题，并观察到该密钥可以识别各个设备。我们部署了一个演示程序(针对Windows ),展示了密钥提取和机器指纹识别在野外的工作情况，并在世界各地的网络中进行了测试。",
        "title_zh": "从IP ID到设备ID和KASLR旁路",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2019.html",
        "conf_title": "28th USENIX Security Symposium 2019: Santa Clara, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity19",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity19/presentation/wu-wei",
        "title": "KEPLER: Facilitating Control-flow Hijacking Primitive Evaluation for Linux Kernel Vulnerabilities",
        "authors": "Wei Wu, Yueqi Chen, Xinyu Xing, Wei Zou",
        "abstract": "Automatic exploit generation is a challenging problem. A challenging part of the task is to connect an identified exploitable state (exploit primitive) to trigger execution of codereuse (e.g., ROP) payload. A control-flow hijacking primitive is one of the most common capabilities for exploitation. However, due to the challenges of widely deployed exploit mitigations, pitfalls along an exploit path, and ill-suited primitives, it is difficult to even manually craft an exploit with a control-flow hijacking primitive for an off-the-shelf modern Linux kernel. We propose KEPLER to facilitate exploit generation by automatically generating a “single-shot” exploitation chain. KEPLER accepts as input a control-flow hijacking primitive and bootstraps any kernel ROP payload by symbolically stitching an exploit chain taking advantage of prevalent kernel coding style and corresponding gadgets. Comparisons with previous automatic exploit generation techniques and previous kernel exploit techniques show KEPLER effectively facilitates evaluation of control-flow hijacking primitives in the Linux kernel.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "漏洞自动生成是一个具有挑战性的问题。该任务的一个挑战部分是连接识别的可利用状态(利用原语)以触发代码重用(例如ROP)有效载荷的执行。控制流劫持原语是最常见的攻击手段之一。然而，由于广泛部署的漏洞利用缓解措施的挑战、漏洞利用路径上的陷阱以及不合适的原语，甚至很难用现成的现代Linux内核的控制流劫持原语来手工制造漏洞利用。我们建议开普勒通过自动生成“单次”利用链来促进利用生成。开普勒接受控制流劫持原语作为输入，并利用流行的内核编码风格和相应的小工具，通过象征性地缝合利用链来引导任何内核ROP有效载荷。与以前的自动利用生成技术和以前的内核利用技术的比较表明，KEPLER有效地促进了对Linux内核中控制流劫持原语的评估。",
        "title_zh": "开普勒:促进Linux内核漏洞的控制流劫持原语评估",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2019.html",
        "conf_title": "28th USENIX Security Symposium 2019: Santa Clara, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity19",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity19/presentation/zhang-tong",
        "title": "PeX: A Permission Check Analysis Framework for Linux Kernel",
        "authors": "Tong Zhang, Wenbo Shen, Dongyoon Lee, Changhee Jung, Ahmed M. Azab, Ruowen Wang",
        "abstract": "Permission checks play an essential role in operating system security by providing access control to privileged functionalities. However, it is particularly challenging for kernel developers to correctly apply new permission checks and to scalably verify the soundness of existing checks due to the large code base and complexity of the kernel. In fact, Linux kernel contains millions of lines of code with hundreds of permission checks, and even worse its complexity is fast-growing. This paper presents PeX, a static Permission check error detector for LinuX, which takes as input a kernel source code and reports any missing, inconsistent, and redundant permission checks. PeX uses KIRIN (Kernel InteRface based Indirect call aNalysis), a novel, precise, and scalable indirect call analysis technique, leveraging the common programming paradigm used in kernel abstraction interfaces. Over the interprocedural control flow graph built by KIRIN, PeX automatically identifies all permission checks and infers the mappings between permission checks and privileged functions. For each privileged function, PeX examines all possible paths to the function to check if necessary permission checks are correctly enforced before it is called. We evaluated PeX on the latest stable Linux kernel v4.18.5 for three types of permission checks: Discretionary Access Controls (DAC), Capabilities, and Linux Security Modules (LSM). PeX reported 36 new permission check errors, 14 of which have been confirmed by the kernel developers.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "通过提供对特权功能的访问控制，权限检查在操作系统安全中起着重要的作用。然而，由于庞大的代码库和内核的复杂性，对于内核开发人员来说，正确地应用新的权限检查并可扩展地验证现有检查的合理性尤其具有挑战性。事实上，Linux内核包含了数百万行代码和数百个权限检查，更糟糕的是它的复杂性还在快速增长。本文介绍了用于LinuX的静态权限检查错误检测器PeX，它将内核源代码作为输入，并报告任何缺失、不一致和冗余的权限检查。PeX使用KIRIN(基于内核接口的间接调用分析)，这是一种新颖、精确且可扩展的间接调用分析技术，利用了内核抽象接口中使用的通用编程范式。通过KIRIN构建的过程间控制流图，PeX自动识别所有权限检查，并推断权限检查和特权函数之间的映射。对于每个特权函数，PeX会检查该函数的所有可能路径，以检查在调用之前是否正确执行了必要的权限检查。我们在最新稳定的Linux内核v4.18.5上评估了PeX的三种权限检查类型:自主访问控制(DAC)、功能和Linux安全模块(LSM)。PeX报告了36个新的权限检查错误，其中14个已被内核开发人员确认。",
        "title_zh": "PeX:一个Linux内核权限检查分析框架",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2019.html",
        "conf_title": "28th USENIX Security Symposium 2019: Santa Clara, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity19",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity19/presentation/vahldiek-oberwagner",
        "title": "ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK)",
        "authors": "Anjo Vahldiek-Oberwagner, Eslam Elnikety, Nuno O. Duarte, Michael Sammler, Peter Druschel, Deepak Garg",
        "abstract": "Isolating sensitive state and data can increase the security and robustness of many applications. Examples include protecting cryptographic keys against exploits like OpenSSL’s Heartbleed bug or protecting a language runtime from native libraries written in unsafe languages. When runtime references across isolation boundaries occur relatively infrequently, then conventional page-based hardware isolation can be used, because the cost of kernelor hypervisormediated domain switching is tolerable. However, some applications, such as the isolation of cryptographic session keys in network-facing services, require very frequent domain switching. In such applications, the overhead of kernelor hypervisor-mediated domain switching is prohibitive. In this paper, we present ERIM, a novel technique that provides hardware-enforced isolation with low overhead on x86 CPUs, even at high switching rates (ERIM’s measured overhead is less than 1% for 100,000 switches per second). The key idea is to combine protection keys (MPKs), a feature recently added to x86 that allows protection domain switches in userspace, with binary inspection to prevent circumvention. We show that ERIM can be applied with little effort to new and existing applications, doesn’t require compiler changes, can run on a stock Linux kernel, and has low runtime overhead even at high domain switching rates.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "隔离敏感状态和数据可以提高许多应用程序的安全性和健壮性。例子包括保护密钥免受OpenSSL的Heartbleed错误之类的攻击，或者保护语言运行时免受用不安全语言编写的本机库的攻击。当跨越隔离边界的运行时引用相对较少时，可以使用传统的基于页面的硬件隔离，因为内核或虚拟机管理程序介导的域切换的成本是可以接受的。然而，一些应用，例如面向网络的服务中的加密会话密钥的隔离，需要非常频繁的域切换。在这样的应用中，内核或管理程序介导的域切换的开销是令人望而却步的。在本文中，我们介绍了ERIM，这是一种在x86 CPUs上以低开销提供硬件强制隔离的新技术，即使在高切换速率下也是如此(ERIM测量的每秒100，000次切换的开销不到1%)。关键思想是将保护密钥(mpk)与二进制检查结合起来，保护密钥是最近添加到x86中的一个特性，允许在用户空间中进行保护域切换，以防止规避。我们证明了ERIM可以轻松地应用于新的和现有的应用程序，不需要改变编译器，可以在普通的Linux内核上运行，即使在高域切换速率下也具有较低的运行时开销。",
        "title_zh": "ERIM:带保护密钥的安全、高效的进程内隔离(MPK)",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2019.html",
        "conf_title": "28th USENIX Security Symposium 2019: Santa Clara, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity19",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity19/presentation/lu",
        "title": "Detecting Missing-Check Bugs via Semantic- and Context-Aware Criticalness and Constraints Inferences",
        "authors": "Kangjie Lu, Aditya Pakki, Qiushi Wu",
        "abstract": "Missing a security check is a class of semantic bugs in software programs where erroneous execution states are not validated. Missing-check bugs are particularly common in OS kernels because they frequently interact with external untrusted user space and hardware, and carry out error-prone computation. Missing-check bugs may cause a variety of critical security consequences, including permission bypasses, out-of-bound accesses, and system crashes. While missingcheck bugs are common and critical, only a few research works have attempted to detect them, which is arguably because of the inherent challenges in the detection—whether a variable requires a security check depends on its semantics, contexts and developer logic, and understanding them is a hard problem. In this paper, we present CRIX, a system for detecting missing-check bugs in OS kernels. CRIX can scalably and precisely evaluate whether any security checks are missing for critical variables, using an inter-procedural, semanticand context-aware analysis. In particular, CRIX’s modeling and cross-checking of the semantics of conditional statements in the peer slices of critical variables infer their criticalness, which allows CRIX to effectively detect missing-check bugs. Evaluation results show that CRIX finds missing-check bugs with reasonably low false-report rates. Using CRIX, we have found 278 new missing-check bugs in the Linux kernel that can cause security issues. We submitted patches for all these bugs; Linux maintainers have accepted 151 of them. The promising results show that missing-check bugs are a common occurrence, and CRIX is effective and scalable in detecting missing-check bugs in OS kernels.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "遗漏安全检查是软件程序中的一类语义错误，其中错误的执行状态没有被验证。遗漏检查错误在操作系统内核中特别常见，因为它们经常与外部不可信的用户空间和硬件交互，并执行容易出错的计算。遗漏检查错误可能会导致各种严重的安全后果，包括权限绕过、越界访问和系统崩溃。虽然遗漏检查错误是常见和关键的，但只有少数研究工作试图检测它们，这可以说是因为检测中的固有挑战——变量是否需要安全检查取决于其语义、上下文和开发人员逻辑，理解它们是一个困难的问题。在本文中，我们介绍了CRIX，一个用于检测操作系统内核中的漏检错误的系统。CRIX可以使用过程间、语义和上下文感知分析，可扩展地、精确地评估关键变量是否缺少任何安全检查。特别地，CRIX对关键变量的对等切片中的条件语句的语义的建模和交叉检查推断出它们的关键性，这允许CRIX有效地检测遗漏检查错误。评估结果表明，CRIX以相当低的误报率发现了漏检错误。使用CRIX，我们在Linux内核中发现了278个新的遗漏检查错误，这些错误可能会导致安全问题。我们提交了所有这些错误的补丁；Linux维护者已经接受了其中的151个。令人鼓舞的结果表明，遗漏检查错误是一种常见现象，CRIX在检测操作系统内核中的遗漏检查错误方面是有效的和可扩展的。",
        "title_zh": "通过语义和上下文感知的关键度和约束推理检测遗漏检查错误",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2019.html",
        "conf_title": "28th USENIX Security Symposium 2019: Santa Clara, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity19",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/woot19/presentation/maier",
        "title": "Unicorefuzz: On the Viability of Emulation for Kernelspace Fuzzing",
        "authors": "Dominik Christian Maier, Benedikt Radtke, Bastian Harren",
        "abstract": "Fuzzing uncovers an ever-growing number of critical vulnerabilities. Despite the simple concept — execute the target until it crashes — setting up fuzz tests can pose complex challenges. This is especially true for code that cannot run as part of a userland process on desktop operating systems — for example device drivers and kernel components. In this paper, we explore the use of CPU emulation to fuzz arbitrary parsers in kernelspace with coverage-based feedback. We propose and open-source Unicorefuzz and explain merits and pitfalls of emulation-based fuzzing approaches. The viability of the approach is evaluated against artificial Linux kernel modules, the Open vSwitch network virtualization component as well as bugs originally uncovered by syzkaller. Emulator-based fuzzing of kernel code is not very complex to set up and can even be used to fuzz operating systems and devices for which no source code is available.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "Fuzzing揭示了越来越多的关键漏洞。尽管这个概念很简单——执行目标直到它崩溃——但是设置模糊测试会带来复杂的挑战。对于不能在桌面操作系统上作为用户域进程的一部分运行的代码来说尤其如此，例如设备驱动程序和内核组件。在本文中，我们探索了在基于覆盖率的反馈下，使用CPU仿真来模糊kernelspace中的任意解析器。我们提出并开源了Unicorefuzz，并解释了基于仿真的模糊化方法的优点和缺陷。针对人工Linux内核模块、开放式vSwitch网络虚拟化组件以及最初由syzkaller发现的错误，对该方法的可行性进行了评估。基于仿真器的内核代码模糊化设置起来并不复杂，甚至可以用来模糊没有源代码的操作系统和设备。",
        "title_zh": "Unicorefuzz:核空间模糊化仿真的可行性",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/woot/woot2019.html",
        "conf_title": "13th WOOT @ USENIX Security Symposium 2019: Santa Clara, CA, USA",
        "conf_url": "https://www.usenix.org/conference/woot19",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/woot17/workshop-program/presentation/patrick-evans",
        "title": "POTUS: Probing Off-The-Shelf USB Drivers with Symbolic Fault Injection",
        "authors": "James Patrick-Evans, Lorenzo Cavallaro, Johannes Kinder",
        "abstract": "USB client device drivers are a haven for software bugs, due to the sheer variety of devices and the tendency of maintenance to slip as devices age. At the same time, the high privilege level of drivers makes them a prime target for exploitation. We present the design and implementation of POTUS, a system for automatically finding vulnerabilities in USB device drivers for Linux, which is based on fault injection, concurrency fuzzing, and symbolic execution. Built on the S2E framework, POTUS exercises the driver under test in a complete virtual machine. It includes a generic USB device that can impersonate arbitrary devices and implements a symbolic fault model. With our prototype implementation, we found and confirmed two previously undiscovered zero-days in the mainline Linux kernel. Furthermore, we show that one of these vulnerabilities can lead to a data-only exploit affecting even hardened systems protected with the latest software and hardware defenses.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "USB客户端设备驱动程序是软件错误的天堂，因为设备种类繁多，而且随着设备的老化，维护工作也越来越薄弱。同时，驱动程序的高特权级别使它们成为主要的攻击目标。本文介绍了POTUS的设计和实现，这是一个基于故障注入、并发模糊和符号执行的Linux USB设备驱动程序漏洞自动发现系统。POTUS基于S2E框架，在一个完整的虚拟机中测试驱动程序。它包括一个通用USB设备，可以模拟任意设备并实现一个符号故障模型。通过我们的原型实现，我们在主线Linux内核中发现并确认了两个以前没有发现的零日。此外，我们还展示了这些漏洞中的一个会导致纯数据利用，甚至会影响受最新软件和硬件防御保护的加固系统。",
        "title_zh": "POTUS:用符号故障注入探测现成的USB驱动程序",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/woot/woot2017.html",
        "conf_title": "11th WOOT @ USENIX Security Symposium 2017: Vancouver, BC, Canada",
        "conf_url": "https://www.usenix.org/conference/woot17",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/wang-pengfei",
        "title": "How Double-Fetch Situations turn into Double-Fetch Vulnerabilities: A Study of Double Fetches in the Linux Kernel",
        "authors": "Pengfei Wang, Jens Krinke, Kai Lu, Gen Li, Steve Dodier-Lazaro",
        "abstract": "We present the first static approach that systematically \ndetects potential double-fetch vulnerabilities in the Linux kernel. Using a pattern-based analysis, we identified 90 \ndouble fetches in the Linux kernel. 57 of these occur \nin drivers, which previous dynamic approaches were unable \nto detect without access to the corresponding hardware. \nWe manually investigated the 90 occurrences, and \ninferred three typical scenarios in which double fetches \noccur. We discuss each of them in detail. We further developed \na static analysis, based on the Coccinelle matching \nengine, that detects double-fetch situations which can \ncause kernel vulnerabilities. When applied to the Linux, \nFreeBSD, and Android kernels, our approach found six \npreviously unknown double-fetch bugs, four of them in \ndrivers, three of which are exploitable double-fetch vulnerabilities. \nAll of the identified bugs and vulnerabilities \nhave been confirmed and patched by maintainers. Our \napproach has been adopted by the Coccinelle team and \nis currently being integrated into the Linux kernel patch \nvetting. Based on our study, we also provide practical solutions \nfor anticipating double-fetch bugs and vulnerabilities. \nWe also provide a solution to automatically patch \ndetected double-fetch bugs.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "我们提出了第一个静态方法，它系统地\n检测Linux内核中潜在的双重提取漏洞。使用基于模式的分析，我们确定了90个\nLinux内核中的双重获取。其中57起发生在\n在驱动程序中，以前的动态方法不能\n无需访问相应的硬件即可进行检测。\n我们手动调查了90个事件，并且\n推断出两次提取的三种典型情况\n发生。我们将详细讨论它们中的每一个。我们进一步发展了\n基于瓢虫匹配的静态分析\n引擎，检测双重提取的情况，可以\n造成内核漏洞。当应用于Linux时，\nFreeBSD和Android内核，我们的方法找到了六个\n以前未知的双取错误，其中四个在\n驱动程序，其中三个是可利用的双重提取漏洞。\n所有已识别的错误和漏洞\n已经被维护人员确认并打了补丁。我们的\n方法已经被Coccinelle团队采用\n目前正被集成到Linux内核补丁中\n审查。基于我们的研究，我们还提供了切实可行的解决方案\n用于预测双重获取错误和漏洞。\n我们还提供了自动修补的解决方案\n检测到双重提取错误。",
        "title_zh": "双重提取情形如何变成双重提取漏洞:Linux内核中双重提取的研究",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2017.html",
        "conf_title": "26th USENIX Security Symposium 2017: Vancouver, BC, Canada",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity17",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/ning",
        "title": "Ninja: Towards Transparent Tracing and Debugging on ARM",
        "authors": "Zhenyu Ning, Fengwei Zhang",
        "abstract": "Existing malware analysis platforms leave detectable fingerprints like uncommon string properties in QEMU, signatures in Android Java virtual machine, and artifacts in Linux kernel profiles. Since these fingerprints provide the malware a chance to split its behavior depending on whether the analysis system is present or not, existing analysis systems are not sufficient to analyze the sophisticated malware. In this paper, we propose NINJA, a transparent malware analysis framework on ARM platform with low artifacts. NINJA leverages a hardware-assisted isolated execution environment TrustZone to transparently trace and debug a target application with the help of Performance Monitor Unit and Embedded Trace Macrocell. NINJA does not modify system software and is OS-agnostic on ARM platform. We implement a prototype of NINJA (i.e., tracing and debugging subsystems), and the experiment results show that NINJA is efficient and transparent for malware analysis.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "现有的恶意软件分析平台会留下可检测的指纹，如QEMU中不常见的字符串属性、Android Java虚拟机中的签名以及Linux内核配置文件中的工件。由于这些指纹为恶意软件提供了根据分析系统是否存在来分割其行为的机会，所以现有的分析系统不足以分析复杂的恶意软件。本文提出了NINJA，一个基于ARM平台的透明恶意软件分析框架，具有低伪像。NINJA利用硬件辅助的隔离执行环境TrustZone，在性能监控单元和嵌入式跟踪宏单元的帮助下，透明地跟踪和调试目标应用程序。NINJA不修改系统软件，在ARM平台上与操作系统无关。我们实现了一个NINJA原型(即跟踪和调试子系统)，实验结果表明NINJA对于恶意软件分析是高效和透明的。",
        "title_zh": "Ninja:在ARM上实现透明跟踪和调试",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2017.html",
        "conf_title": "26th USENIX Security Symposium 2017: Vancouver, BC, Canada",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity17",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/machiry",
        "title": "DR. CHECKER: A Soundy Analysis for Linux Kernel Drivers",
        "authors": "Aravind Machiry, Chad Spensky, Jake Corina, Nick Stephens, Christopher Kruegel, Giovanni Vigna",
        "abstract": "While kernel drivers have long been know to poses huge security risks, due to their privileged access and lower code quality, bug-finding tools for drivers are still greatly lacking both in quantity and effectiveness. This is because the pointer-heavy code in these drivers present some of the hardest challenges to static analysis, and their tight coupling with the hardware make dynamic analysis infeasible in most cases. In this work, we present DR. CHECKER, a soundy (i.e., mostly sound) bug-finding tool for Linux kernel drivers that is based on well-known program analysis techniques. We are able to overcome many of the inherent limitations of static analysis by scoping our analysis to only the most bug-prone parts of the kernel (i.e., the drivers), and by only sacrificing soundness in very few cases to ensure that our technique is both scalable and precise. DR. CHECKER is a fully-automated static analysis tool capable of performing general bug finding using both pointer and taint analyses that are flow-sensitive, context-sensitive, and fieldsensitive on kernel drivers. To demonstrate the scalability and efficacy of DR. CHECKER, we analyzed the drivers of nine production Linux kernels (3.1 million LOC), where it correctly identified 158 critical zero-day bugs with an overall precision of 78%.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "虽然内核驱动程序很早就被认为会带来巨大的安全风险，但由于它们的特权访问和较低的代码质量，用于驱动程序的bug查找工具在数量和效率方面仍然非常缺乏。这是因为这些驱动程序中的大量指针代码给静态分析带来了一些最大的挑战，并且它们与硬件的紧密耦合使得动态分析在大多数情况下不可行。在这篇文章中，我们介绍了DR. CHECKER，这是一个基于众所周知的程序分析技术的、用于Linux内核驱动程序的可靠的(也就是大部分可靠的)缺陷查找工具。通过将我们的分析限定在内核中最容易出现错误的部分(即驱动程序)，并且通过在极少数情况下牺牲可靠性来确保我们的技术既可伸缩又精确，我们能够克服静态分析的许多固有限制。DR. CHECKER是一个全自动的静态分析工具，能够使用内核驱动程序上的流敏感、上下文敏感和字段敏感的指针和污点分析来执行一般的bug查找。为了展示DR. CHECKER的可扩展性和有效性，我们分析了9个生产Linux内核(310万个LOC)的驱动程序，其中它正确识别了158个关键的零日错误，总体准确率为78%。",
        "title_zh": "CHECKER博士:对Linux内核驱动程序的合理分析",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2017.html",
        "conf_title": "26th USENIX Security Symposium 2017: Vancouver, BC, Canada",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity17",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity18/presentation/pailoor",
        "title": "MoonShine: Optimizing OS Fuzzer Seed Selection with Trace Distillation",
        "authors": "Shankara Pailoor, Andrew Aday, Suman Jana",
        "abstract": "OS fuzzers primarily test the system-call interface between the OS kernel and user-level applications for security vulnerabilities. The effectiveness of all existing evolutionary OS fuzzers depends heavily on the quality and diversity of their seed system call sequences. However, generating good seeds for OS fuzzing is a hard problem as the behavior of each system call depends heavily on the OS kernel state created by the previously executed system calls. Therefore, popular evolutionary OS fuzzers often rely on hand-coded rules for generating valid seed sequences of system calls that can bootstrap the fuzzing process. Unfortunately, this approach severely restricts the diversity of the seed system call sequences and therefore limits the effectiveness of the fuzzers. In this paper, we develop MoonShine, a novel strategy for distilling seeds for OS fuzzers from system call traces of real-world programs while still preserving the dependencies across the system calls. MoonShine leverages light-weight static analysis for efficiently detecting dependencies across different system calls. We designed and implemented MoonShine as an extension to Syzkaller, a state-of-the-art evolutionary fuzzer for the Linux kernel. Starting from traces containing 2.8 million system calls gathered from 3,220 real-world programs, MoonShine distilled down to just over 14,000 calls while preserving 86% of the original code coverage. Using these distilled seed system call sequences, MoonShine was able to improve Syzkaller’s achieved code coverage for the Linux kernel by 13% on average. MoonShine also found 17 new vulnerabilities in the Linux kernel that were not found by Syzkaller.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "OS fuzzers主要测试OS内核和用户级应用程序之间的系统调用接口的安全漏洞。所有现存的进化操作系统模糊器的有效性很大程度上依赖于它们的种子系统调用序列的质量和多样性。然而，为OS fuzzing生成良好的种子是一个困难的问题，因为每个系统调用的行为严重依赖于由先前执行的系统调用创建的OS内核状态。因此，流行的进化操作系统模糊化器通常依赖手工编码的规则来生成有效的系统调用种子序列，从而引导模糊化过程。不幸的是，这种方法严重限制了种子系统调用序列的多样性，因此限制了模糊化器的有效性。在本文中，我们开发了MoonShine，这是一种从真实世界程序的系统调用跟踪中提取OS模糊器种子的新策略，同时仍然保留跨系统调用的依赖性。MoonShine利用轻量级静态分析来有效地检测不同系统调用之间的依赖性。我们设计并实现了MoonShine，作为Syzkaller的扩展，syz kaller是一个用于Linux内核的最新进化模糊器。从包含从3，220个真实世界程序中收集的280万个系统调用的跟踪开始，MoonShine精简到仅超过14，000个调用，同时保留86%的原始代码覆盖率。使用这些提取的种子系统调用序列，MoonShine能够将Syzkaller实现的Linux内核代码覆盖率平均提高13%。MoonShine还在Linux内核中发现了17个Syzkaller没有发现的新漏洞。",
        "title_zh": "月光:用微量蒸馏优化OS Fuzzer种子选择",
        "year": "2018",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2018.html",
        "conf_title": "27th USENIX Security Symposium 2018: Baltimore, MD, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity18",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity18/presentation/sun",
        "title": "Security Namespace: Making Linux Security Frameworks Available to Containers",
        "authors": "Yuqiong Sun, David Safford, Mimi Zohar, Dimitrios Pendarakis, Zhongshu Gu, Trent Jaeger",
        "abstract": "Lightweight virtualization (i.e., containers) offers a virtual host environment for applications without the need for a separate kernel, enabling better resource utilization and improved efficiency. However, the shared kernel also prevents containers from taking advantage of security features that are available to traditional VMs and hosts. Containers cannot apply local policies to govern integrity measurement, code execution, mandatory access control, etc. to prevent application-specific security problems. Changes have been proposed to make kernel security mechanisms available to containers, but such changes are often adhoc and expose the challenges of trusting containers to make security decisions without compromising host system or other containers. In this paper, we propose security namespaces, a kernel abstraction that enables containers to have an autonomous control over their security. The security namespace relaxes the global and mandatory assumption of kernel security frameworks, thus enabling containers to independently define security policies and apply them to a limited scope of processes. To preserve security, we propose a routing mechanism that can dynamically dispatch an operation to a set of containers whose security might be affected by the operation, therefore ensuring the security decision made by one container cannot compromise the host or other containers. We demonstrate security namespace by developing namespaces for integrity measurement and mandatory access control in the Linux kernel for use by Docker containers. Results show that security namespaces can effectively mitigate security problems within containers (e.g., malicious code execution) with less than 0.7% additional latency to system call and almost identical application throughput. As a result, security namespaces enable containers to obtain autonomous control over their security without compromising the security of other containers or the host system.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "轻量级虚拟化(即容器)为应用程序提供了虚拟主机环境，无需单独的内核，从而实现了更好的资源利用率和更高的效率。然而，共享内核也阻止容器利用传统虚拟机和主机可用的安全特性。容器不能应用本地策略来管理完整性度量、代码执行、强制访问控制等。以防止特定于应用程序的安全问题。已经提出了使内核安全机制可用于容器的改变，但是这种改变通常是临时的，并且暴露了信任容器做出安全决定而不危及主机系统或其他容器的挑战。在本文中，我们提出了安全名称空间，这是一个内核抽象，它使容器能够自主控制它们的安全性。安全命名空间放松了内核安全框架的全局和强制性假设，从而使容器能够独立定义安全策略，并将它们应用于有限的进程范围。为了保证安全性，我们提出了一种路由机制，该机制可以动态地将操作分派给一组安全性可能受到操作影响的容器，从而确保一个容器做出的安全决策不会危及主机或其他容器。我们通过为Docker容器使用的Linux内核中的完整性度量和强制访问控制开发名称空间来演示安全名称空间。结果表明，安全命名空间可以有效地缓解容器内的安全问题(例如，恶意代码执行)，而系统调用的额外延迟小于0.7%，并且应用程序吞吐量几乎相同。因此，安全命名空间使容器能够获得对其安全性的自主控制，而不会危及其他容器或主机系统的安全性。",
        "title_zh": "安全名称空间:使Linux安全框架对容器可用",
        "year": "2018",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2018.html",
        "conf_title": "27th USENIX Security Symposium 2018: Baltimore, MD, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity18",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/cao",
        "title": "Off-Path TCP Exploits: Global Rate Limit Considered Dangerous",
        "authors": "Yue Cao, Zhiyun Qian, Zhongjie Wang, Tuan Dao, Srikanth V. Krishnamurthy, Lisa M. Marvel",
        "abstract": "In this paper, we report a subtle yet serious side channel vulnerability (CVE-2016-5696) introduced in a recent TCP specification. The specification is faithfully implemented in Linux kernel version 3.6 (from 2012) and beyond, and affects a wide range of devices and hosts. In a nutshell, the vulnerability allows a blind off-path attacker to infer if any two arbitrary hosts on the Internet are communicating using a TCP connection. Further, if the connection is present, such an off-path attacker can also infer the TCP sequence numbers in use, from both sides of the connection; this in turn allows the attacker to cause connection termination and perform data injection attacks. We illustrate how the attack can be leveraged to disrupt or degrade the privacy guarantees of an anonymity network such as Tor, and perform web connection hijacking. Through extensive experiments, we show that the attack is fast and reliable. On average, it takes about 40 to 60 seconds to finish and the success rate is 88% to 97%. Finally, we propose changes to both the TCP specification and implementation to eliminate the root cause of the problem.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "在本文中，我们报告了一个在最近的TCP规范中引入的微妙而严重的侧信道漏洞(CVE-2016-5696)。该规范在Linux内核版本3.6(从2012年开始)和更高版本中得到了忠实的实现，并影响了广泛的设备和主机。简而言之，该漏洞允许盲目的路径外攻击者推断互联网上的任意两台主机是否正在使用TCP连接进行通信。此外，如果连接存在，这样的路径外攻击者还可以从连接的两端推断出正在使用的TCP序列号；这反过来允许攻击者导致连接终止并执行数据注入攻击。我们举例说明了如何利用攻击来破坏或降低t or等匿名网络的隐私保证，并执行web连接劫持。通过大量的实验，我们证明了攻击的快速性和可靠性。平均来说，大约需要40到60秒才能完成，成功率为88%到97%。最后，我们建议对TCP规范和实现进行修改，以消除问题的根源。",
        "title_zh": "路径外TCP漏洞:全球速率限制被认为是危险的",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2016.html",
        "conf_title": "25th USENIX Security Symposium 2016: Washington, D.C., USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity16",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/yun",
        "title": "APISan: Sanitizing API Usages through Semantic Cross-Checking",
        "authors": "Insu Yun, Changwoo Min, Xujie Si, Yeongjin Jang, Taesoo Kim, Mayur Naik",
        "abstract": "API misuse is a well-known source of bugs. Some of them (e.g., incorrect use of SSL API, and integer overflow of memory allocation size) can cause serious security vulnerabilities (e.g., man-in-the-middle (MITM) attack, and privilege escalation). Moreover, modern APIs, which are large, complex, and fast evolving, are error-prone. However, existing techniques to help finding bugs require manual effort by developers (e.g., providing specification or model) or are not scalable to large real-world software comprising millions of lines of code. In this paper, we present APISAN, a tool that automatically infers correct API usages from source code without manual effort. The key idea in APISAN is to extract likely correct usage patterns in four different aspects (e.g., causal relation, and semantic relation on arguments) by considering semantic constraints. APISAN is tailored to check various properties with security implications. We applied APISAN to 92 million lines of code, including Linux Kernel, and OpenSSL, found 76 previously unknown bugs, and provided patches for all the bugs.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "API误用是众所周知的错误来源。其中一些(例如，SSL API的不正确使用和内存分配大小的整数溢出)会导致严重的安全漏洞(例如，中间人(MITM)攻击和权限提升)。此外，大型、复杂且快速发展的现代API容易出错。然而，帮助发现缺陷的现有技术需要开发者的人工努力(例如，提供规范或模型)，或者不可扩展到包括数百万行代码的大型现实世界软件。在本文中，我们介绍了APISAN，这是一个无需人工操作就能从源代码中自动推断正确的API用法的工具。APISAN中的关键思想是通过考虑语义约束来提取四个不同方面(例如，因果关系和论元的语义关系)的可能正确的使用模式。APISAN专门用于检查各种具有安全隐患的属性。我们将APISAN应用于9200万行代码，包括Linux内核和OpenSSL，发现了76个以前未知的错误，并为所有错误提供了补丁。",
        "title_zh": "APISan:通过语义交叉检查净化API使用",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2016.html",
        "conf_title": "25th USENIX Security Symposium 2016: Washington, D.C., USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity16",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/woot15/workshop-program/presentation/xu",
        "title": "Own Your Android! Yet Another Universal Root",
        "authors": "Wen Xu, Yubin Fu",
        "abstract": "In recent years, to find a universal root solution for Android becomes harder and harder due to rare vulnerabilities in the Linux kernel base and also the exploit mitigations applied on the devices by various vendors. \n \nIn this paper, we will present our universal root solution. The related vulnerability CVE-2015-3636, a typical use-after-free bug in Linux kernel is discussed in detail. Exploiting such a use-after-free in Linux kernel is truly difficult due to the separated allocation from the kernel allocator. We will show how we leverage this kernel use-after-free bug to achieve privilege promotion on most popular Android devices on market which have a version not less than 4.3, including the first 64bit root case in the world. In short, we will present a generic way to exploit use-after-free vulnerabilities in Linux kernel, which means one exploit applies to devices of all brands. All the current mitigations in the kernel like PXN are circumvented by this approach. And most importantly our unique and undocumented exploitation technique targeting kernel use-after-free bugs features stability and accuracy.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "近年来，由于Linux内核基础中罕见的漏洞以及各个供应商在设备上应用的漏洞缓解措施，为Android找到一个通用的根解决方案变得越来越困难。\n\n在本文中，我们将提出我们的通用根解决方案。详细讨论了相关漏洞CVE-2015-3636，这是一个典型的Linux内核释放后使用漏洞。在Linux内核中利用这种先用后免的特性确实很困难，因为分配是从内核分配器中分离出来的。我们将展示我们如何利用这个释放后使用内核的错误，在市场上最受欢迎的版本不低于4.3的Android设备上实现特权提升，包括世界上第一个64位root case。简而言之，我们将介绍一种利用Linux内核中释放后使用漏洞的通用方法，这意味着一次利用适用于所有品牌的设备。内核中所有当前的缓解措施，如PXN，都被这种方法规避了。最重要的是，我们针对内核释放后使用错误的独特和未记录的利用技术具有稳定性和准确性。",
        "title_zh": "拥有您的Android！另一个普遍的根源",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/woot/woot2015.html",
        "conf_title": "9th WOOT 2015: Washington, DC, USA",
        "conf_url": "https://www.usenix.org/conference/woot15",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/ramos",
        "title": "Under-Constrained Symbolic Execution: Correctness Checking for Real Code",
        "authors": "David A. Ramos, Dawson R. Engler",
        "abstract": "Software bugs are a well-known source of security vulnerabilities. One technique for finding bugs, symbolic execution, considers all possible inputs to a program but suffers from scalability limitations. This paper uses a variant, under-constrained symbolic execution, that improves scalability by directly checking individual functions, rather than whole programs. We present UC-KLEE, a novel, scalable framework for checking C/C++ systems code, along with two use cases. First, we use UC-KLEE to check whether patches introduce crashes. We check over 800 patches from BIND and OpenSSL and find 12 bugs, including two OpenSSL denial-of-service vulnerabilities. We also verify (with caveats) that 115 patches do not introduce crashes. Second, we use UC-KLEE as a generalized checking framework and implement checkers to find memory leaks, uninitialized data, and unsafe user input. We evaluate the checkers on over 20,000 functions from BIND, OpenSSL, and the Linux kernel, find 67 bugs, and verify that hundreds of functions are leak free and that thousands of functions do not access uninitialized data.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "众所周知，软件缺陷是安全漏洞的来源。一种寻找bug的技术——符号执行——考虑了程序所有可能的输入，但是受到可伸缩性的限制。本文使用了一种变体，欠约束符号执行，它通过直接检查单个函数而不是整个程序来提高可伸缩性。我们介绍了UC-KLEE，一个新颖的、可扩展的用于检查C/C++系统代码的框架，以及两个用例。首先，我们使用UC-KLEE来检查补丁是否会导致崩溃。我们检查了来自BIND和OpenSSL的800多个补丁，发现了12个错误，包括两个OpenSSL拒绝服务漏洞。我们还验证了115个补丁不会导致崩溃。其次，我们使用UC-KLEE作为通用的检查框架，并实现检查器来查找内存泄漏、未初始化的数据和不安全的用户输入。我们评估了来自BIND、OpenSSL和Linux内核的20，000多个函数的检查器，发现了67个错误，并验证了数百个函数没有泄漏，数千个函数没有访问未初始化的数据。",
        "title_zh": "欠约束符号执行:真实代码的正确性检查",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2015.html",
        "conf_title": "24th USENIX Security Symposium 2015: Washington, D.C., USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity15",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/bates",
        "title": "Trustworthy Whole-System Provenance for the Linux Kernel",
        "authors": "Adam Bates, Dave Tian, Kevin R. B. Butler, Thomas Moyer",
        "abstract": "In a provenance-aware system, mechanisms gather and report metadata that describes the history of each object being processed on the system, allowing users to understand how data objects came to exist in their present state. However, while past work has demonstrated the usefulness of provenance, less attention has been given to securing provenance-aware systems. Provenance itself is a ripe attack vector, and its authenticity and integrity must be guaranteed before it can be put to use. \n \nWe present Linux Provenance Modules (LPM), the first general framework for the development of provenance-aware systems. We demonstrate that LPM creates a trusted provenance-aware execution environment, collecting complete whole-system provenance while imposing as little as 2.7% performance overhead on normal system operation. LPM introduces new mechanisms for secure provenance layering and authenticated communication between provenance-aware hosts, and also interoperates with existing mechanisms to provide strong security assurances. To demonstrate the potential uses of LPM, we design a Provenance-Based Data Loss Prevention (PB-DLP) system. We implement PBDLP as a file transfer application that blocks the transmission of files derived from sensitive ancestors while imposing just tens of milliseconds overhead. LPM is the first step towards widespread deployment of trustworthy provenance-aware applications.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "在起源感知系统中，机制收集并报告描述系统上正在处理的每个对象的历史的元数据，允许用户理解数据对象如何以其当前状态存在。然而，尽管过去的工作已经证明了起源的有用性，但是对于保护起源感知系统的关注较少。出处本身就是一个成熟的攻击载体，必须保证其真实性和完整性才能投入使用。\n\n我们介绍了Linux起源模块(LPM)，这是开发起源感知系统的第一个通用框架。我们证明，LPM创建了一个可信起源感知的执行环境，收集完整的全系统起源，同时对正常的系统操作施加少至2.7%的性能开销。LPM为安全起源分层和起源感知主机之间的认证通信引入了新的机制，并且还与现有机制互操作以提供强大的安全保证。为了展示LPM的潜在用途，我们设计了一个基于起源的数据丢失防护(PB-DLP)系统。我们将PBDLP实现为一个文件传输应用程序，它可以阻止来自敏感祖先的文件的传输，而只需要几十毫秒的开销。LPM是广泛部署可信的来源感知应用程序的第一步。",
        "title_zh": "可信的Linux内核全系统起源",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2015.html",
        "conf_title": "24th USENIX Security Symposium 2015: Washington, D.C., USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity15",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity23/presentation/cai-yuandao",
        "title": "Place Your Locks Well: Understanding and Detecting Lock Misuse Bugs",
        "authors": "Yuandao Cai, Peisen Yao, Chengfeng Ye, Charles Zhang",
        "abstract": "Modern multi-threaded software systems commonly leverage locks to prevent concurrency bugs. Neverthe-less, due to the complexity of writing the correct concurrent code, using locks itself is often error-prone. In this work, we investigate a general variety of lock mis-uses. Our characteristic study of existing CVE IDs reveals that lock misuses can inﬂict concurrency errors and even severe security issues, such as denial-of-service and memory corruption. To alleviate the threats, we present a practical static analysis framework, namely L OCK - PICK , which consists of two core stages to effectively detect misused locks. More speciﬁcally, L OCKPICK ﬁrst conducts path-sensitive typestate analysis, tracking lock-state transitions and interactions to identify sequential typestate violations. Guided by the preceding results, L OCKPICK then performs concurrency-aware detection to pinpoint various lock misuse errors, effectively reasoning about the thread interleavings of interest. The results are encouraging — we have used L OCKPICK to uncover 203 unique and conﬁrmed lock misuses across a broad spectrum of impactful open-source systems, such as OpenSSL, the Linux kernel, PostgreSQL, MariaDB, FFmpeg, Apache HTTPd, and FreeBSD. Three exciting results are that those conﬁrmed lock misuses are long-latent, hiding for 7.4 years on average; in total, 16 CVE IDs have been assigned for the severe errors uncovered; and L OCKPICK can ﬂag many real bugs missed by the previous tools with signiﬁcantly fewer false positives.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "放置好锁：理解和检测锁滥用错误",
        "abstract_zh": "现代多线程软件系统通常利用锁来防止并发错误。 从未有过，由于编写正确的并发代码的复杂性，使用锁本身通常容易出错。 在这项工作中，我们研究了一般的锁定误用。 我们对现有CVE ID的特征研究表明，锁定滥用可能会影响并发错误甚至严重的安全问题，例如拒绝服务和记忆腐败。 为了减轻威胁，我们提出了一个实用的静态分析框架，即p pick，该框架由两个核心阶段组成，可有效检测滥用的锁。 更具体地说，第一次进行路径敏感的典型分析，跟踪锁定状态过渡和相互作用，以识别顺序的典型典型违规行为。 在前面的结果的指导下，L Ockpick随后执行并发感知检测，以查明各种锁定滥用误差，从而有效地推论了螺纹相互交织。 结果令人鼓舞 - 我们使用L Ockpick发现了203个独特而确认的锁定误用，例如OpenSSL，Linux内核，Postgresql，Mariadb，FFMPEG，Apache HTTPD和FreeBSD。 三个令人兴奋的结果是，这些确认的锁定滥用是长期的，平均隐藏了7。4年。 总共为发现的严重错误分配了16个CVE ID； l ockpick可能会被以前的工具所遗漏的许多真正的错误，这些工具的误报较少。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2023.html",
        "conf_title": "32nd USENIX Security Symposium 2023:\nAnaheim, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity23",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity23/presentation/wang-zicheng",
        "title": "PET: Prevent Discovered Errors from Being Triggered in the Linux Kernel",
        "authors": "Zicheng Wang, Yueqi Chen, Qingkai Zeng",
        "abstract": "",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "宠物：防止在Linux内核中触发发现的错误",
        "abstract_zh": "",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2023.html",
        "conf_title": "32nd USENIX Security Symposium 2023:\nAnaheim, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity23",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity23/presentation/li-guoren",
        "title": "A Hybrid Alias Analysis and Its Application to Global Variable Protection in the Linux Kernel",
        "authors": "Guoren Li, Hang Zhang, Jinmeng Zhou, Wenbo Shen, Yulei Sui, Zhiyun Qian",
        "abstract": "Global variables in the Linux kernel have been a common target of memory corruption attacks to achieve privilege escalation. Several potential defense mechanisms can be employed to safeguard global variables. One approach involves placing global variables in read-only pages after kernel initialization (ro_after_init), while another involves employing software fault isolation (SFI) to dynamically block unintended writes to these variables. To deploy such solutions in practice, a key building block is a sound, precise, and scalable alias analysis that is capable of identifying all the pointer aliases of global variables, as any pointer alias may be used for intended writes to a global variable. Unfortunately, the two existing styles of data-flow-based (e.g., Andersen-style) alias analysis and typebased alias analysis have serious limitations in scalability and precision when applied to the Linux kernel. This paper proposes a novel and general hybrid alias analysis that unifies the two complementary approaches in a graph reachability framework using context-free-language, also known as CFL-reachability. We show our hybrid alias analysis is extremely effective, significantly and simultaneously outperforming the data-flow-based alias analysis in scalability and the type-based alias analysis in precision. Under the same time budget, our hybrid analysis finds 42% of the Linux kernel global variables protectable as ro_after_init, whereas the two separate analyses find a combined 16% only.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "混合别名分析及其在Linux内核中全球可变保护中的应用",
        "abstract_zh": "Linux内核中的全局变量是内存损坏攻击的常见目标，以实现权限提升。可以使用几种潜在的防御机制来保护全局变量。一种方法是在内核初始化(ro_after_init)后将全局变量放在只读页面中，而另一种方法是采用软件故障隔离(SFI)来动态阻止对这些变量的意外写入。为了在实践中部署这样的解决方案，关键的构建块是能够识别全局变量的所有指针别名的合理的、精确的和可扩展的别名分析，因为任何指针别名都可以用于对全局变量的预期写入。不幸的是，当应用于Linux内核时，基于数据流(例如，Andersen风格)的别名分析和基于类型的别名分析这两种现有风格在可扩展性和精确度方面具有严重的局限性。本文提出了一种新的通用混合别名分析方法，该方法使用上下文无关语言将两种互补的方法统一在一个图可达性框架中，也称为CFL可达性。我们证明了我们的混合别名分析是非常有效的，在可扩展性上显著地同时优于基于数据流的别名分析和基于类型的别名分析。在相同的时间预算下，我们的混合分析发现42%的Linux内核全局变量可以作为ro_after_init进行保护，而两个单独的分析发现总共只有16%。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2023.html",
        "conf_title": "32nd USENIX Security Symposium 2023:\nAnaheim, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity23",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity23/presentation/stone",
        "title": "No Linux, No Problem: Fast and Correct Windows Binary Fuzzing via Target-embedded Snapshotting",
        "authors": "Leo Stone, Rishi Ranjan, Stefan Nagy, Matthew Hicks",
        "abstract": "—Coverage-guided fuzzing remains today’s most successful approach for exposing software security vulnerabilities. Speed is paramount in fuzzing, as maintaining a high test case throughput enables more expeditious exploration of programs—leading to faster vulnerability discovery. High-performance fuzzers exploit the Linux kernel’s customizability to implement process snapshotting : fuzzing-oriented execution primitives that dramatically increase fuzzing throughput. Unfortunately, such speeds remain elusive on Windows. The closed-source nature of its kernel prevents current kernel-based snapshotting techniques from being ported—severely limiting fuzzing’s effectiveness on Windows programs. Thus, accelerating vetting of the Windows software ecosystem demands a fast , correct , and kernel-agnostic fuzzing execution mechanism. We propose making state snapshotting an application-level concern as opposed to a kernel-level concern via target-embedded snapshotting . Target-embedded-snapshotting combines binary-and library-level hooking to allow applications to snapshot themselves—while leaving both their source code and the Windows kernel untouched. Our evaluation on 10 real-world Windows binaries shows that target-embedded snap-shotting overcomes the speed, correctness, and compatibility challenges of previous Windows fuzzing execution mechanisms (i.e., process creation, forkserver-based cloning, and persistent mode). The result is 7–182x increased performance.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "没有Linux，没有问题：快速正确的Windows二进制二进制模糊通过目标插入快照",
        "abstract_zh": "—覆盖导向模糊化仍然是当今揭露软件安全漏洞的最成功的方法。速度在模糊化中是至关重要的，因为保持高测试用例吞吐量能够更快速地探索程序，从而更快地发现漏洞。高性能模糊化器利用Linux内核的可定制性来实现进程快照:面向模糊化的执行原语极大地提高了模糊化的吞吐量。不幸的是，这样的速度在Windows上仍然难以实现。其内核的闭源性质阻止了当前基于内核的快照技术被移植——严重限制了fuzzing在Windows程序上的有效性。因此，加速审查Windows软件生态系统需要一种快速、正确、与内核无关的模糊执行机制。我们建议通过目标嵌入式快照，使状态快照成为应用程序级别的关注点，而不是内核级别的关注点。目标嵌入式快照结合了二进制和库级挂钩，允许应用程序对自己进行快照，同时保持源代码和Windows内核不变。我们对10个真实世界的Windows二进制文件的评估表明，目标嵌入式快照克服了以前的Windows模糊执行机制(即，进程创建、基于forkserver的克隆和持久模式)在速度、正确性和兼容性方面的挑战。结果是性能提高了7–182倍。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2023.html",
        "conf_title": "32nd USENIX Security Symposium 2023:\nAnaheim, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity23",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity23/presentation/cho",
        "title": "BoKASAN: Binary-only Kernel Address Sanitizer for Effective Kernel Fuzzing",
        "authors": "Mingi Cho, Dohyeon An, Hoyong Jin, Taekyoung Kwon",
        "abstract": "Kernel Address Sanitizer (KASAN), an invaluable tool for ﬁnding use-after-free and out-of-bounds bugs in the Linux kernel, needs the kernel source for compile-time instrumentation. To apply KASAN to closed-source systems, we should develop a binary-only KASAN, which is challenging. A technique that uses binary rewriting and processor support to run KASAN for binary modules needs a KASAN-applied kernel, thereby still the kernel source. Dynamic instrumentation offers an alternative way to it but greatly increases the performance overhead, rendering the kernel fuzzing impractical. To address these problems, we present the ﬁrst practical, binary-only KASAN named BoKASAN , which conducts address sanitization through dynamic instrumentation for the entire kernel binaries efﬁciently. Our key idea is selective sanitization , which identiﬁes target processes to sanitize and hooks the page fault mechanism for signiﬁcantly reducing the performance overhead of dynamic instrumentation. Our key insight is that the kernel bugs are most relevant to the processes created by a fuzzer. Thus, BoKASAN deliberately sani-tizes the target memory regions related to these processes and leaves the remains unsanitized for effective kernel fuzzing. Our evaluation results show that BoKASAN is practical on closed-source systems, achieving the compiler-level performance of KASAN even on binary-only kernels and modules. Compared to KASAN on the Linux kernel, BoKASAN detected slightly more bugs in the Janus dataset and slightly fewer bugs in the Syzkaller/SyzVegas dataset; and BoKASAN found the same number of unique bugs in the 5-day fuzzing and executed the similar number of basic blocks. For binary modules on the Windows kernel and the Linux kernel, resp., BoKASAN was effective in ﬁnding bugs. An ablation result shows that selective sanitization affected these outcomes",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "Bokasan：仅二进制内核地址消毒剂，用于有效内核模糊",
        "abstract_zh": "Kernel Address Sanitizer (KASAN)是一个非常有价值的工具，用于发现Linux内核中的释放后使用和越界错误，它需要内核源代码来进行编译时检测。为了将KASAN应用于闭源系统，我们应该开发一个只有二进制的KASAN，这是一个挑战。使用二进制重写和处理器支持来为二进制模块运行KASAN的技术需要应用KASAN的内核，从而仍然是内核源代码。动态插装提供了一种替代方法，但是大大增加了性能开销，使得内核模糊化不切实际。为了解决这些问题，我们提出了第一个实用的仅二进制KASAN，名为BoKASAN，它通过对整个内核二进制文件进行动态检测来有效地进行地址净化。我们的主要思想是选择性清理，它识别要清理的目标进程，并挂钩页面错误机制，以显著降低动态检测的性能开销。我们的关键见解是内核错误与fuzzer创建的进程最相关。因此，BoKASAN有意地对与这些进程相关的目标内存区域进行了精简，并保留了未精简的剩余部分，以便进行有效的内核模糊处理。我们的评估结果表明，BoKASAN在闭源系统上是实用的，甚至在只有二进制的内核和模块上也达到了KASAN的编译器级别的性能。与Linux内核上的KASAN相比，BoKASAN在Janus数据集上检测到的bug略多，在Syzkaller/SyzVegas数据集上检测到的bug略少；BoKASAN在5天的fuzzing中发现了相同数量的独特错误，并执行了相似数量的基本块。对于Windows内核和Linux内核上的二进制模块，分别为。，BoKASAN在查找bug方面很有效。消融结果显示，选择性消毒影响了这些结果",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2023.html",
        "conf_title": "32nd USENIX Security Symposium 2023:\nAnaheim, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity23",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity23/presentation/fleischer",
        "title": "ACTOR: Action-Guided Kernel Fuzzing",
        "authors": "Marius Fleischer, Dipanjan Das, Priyanka Bose, Weiheng Bai, Kangjie Lu, Mathias Payer, Christopher Kruegel, Giovanni Vigna",
        "abstract": "Fuzzing reliably and efficiently finds bugs in software, including operating system kernels. In general, higher code coverage leads to the discovery of more bugs. This is why most existing kernel fuzzers adopt strategies to generate a series of inputs that attempt to greedily maximize the amount of code that they exercise. However, simply executing code may not be sufficient to reveal bugs that require specific sequences of actions. Synthesizing inputs to trigger such bugs depends on two aspects: (i) the actions the executed code takes, and (ii) the order in which those actions are taken. An action is a high-level operation, such as a heap allocation, that is performed by the executed code and has a specific semantic meaning. A CTOR , our action-guided kernel fuzzing framework, deviates from traditional methods. Instead of focusing on code coverage optimization, our approach generates fuzzer programs (inputs) that leverage our understanding of triggered actions and their temporal relationships. Specifically, we first capture actions that potentially operate on shared data structures at different times. Then, we synthesize programs using those actions as building blocks, guided by bug templates expressed in our domain-specific language. We evaluated A CTOR on four different versions of the Linux kernel, including two well-tested and frequently updated long-term (5 . 4 . 206, 5 . 10 . 131) versions, a stable (5 . 19), and the latest (6 . 2-rc5) release. Our evaluation revealed a total of 41 previously unknown bugs, of which 9 have already been fixed. Interestingly, 15 (36 . 59%) of them were discovered in less than a day",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "演员：动作引导的内核模糊",
        "abstract_zh": "可靠，有效地模糊可以在软件中找到错误，包括操作系统内核。 通常，较高的代码覆盖范围会导致发现更多错误。 这就是为什么大多数现有的内核模糊器都采用策略来生成一系列投入，以贪婪地最大程度地提高其行使的代码量的原因。 但是，简单地执行代码可能不足以揭示需要特定操作序列的错误。 综合输入以触发此类错误取决于两个方面：（i）执行代码采取的操作以及（ii）采取这些操作的顺序。 操作是由执行代码执行的高级操作，例如堆分配，具有特定的语义含义。 我们的动作指导内核模糊框架的ctor偏离了传统方法。 我们的方法没有专注于代码覆盖范围优化，而是生成模糊程序（输入），从而利用了我们对触发动作及其时间关系的理解。 具体来说，我们首先捕获可能在不同时间对共享数据结构进行操作的动作。 然后，我们使用这些操作作为构建块合成程序，并由我们特定于域的语言表达的错误模板引导。 我们在四个不同版本的Linux内核上评估了一个CTOR，包括两个经过良好测试且经常更新的长期（5。4.206，5。10.131）版本，稳定（5。19）和最新的版本 （6。2-RC5）释放。 我们的评估显示了41个以前未知的错误，其中9个已固定。 有趣的是，在不到一天的时间内发现了15（36。59％）",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2023.html",
        "conf_title": "32nd USENIX Security Symposium 2023:\nAnaheim, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity23",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity23/presentation/koschel",
        "title": "Uncontained: Uncovering Container Confusion in the Linux Kernel",
        "authors": "Jakob Koschel, Pietro Borrello, Daniele Cono D'Elia, Herbert Bos, Cristiano Giuffrida",
        "abstract": "",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "未经包含的：在Linux内核中发现容器混乱",
        "abstract_zh": "",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2023.html",
        "conf_title": "32nd USENIX Security Symposium 2023:\nAnaheim, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity23",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity23/presentation/kol",
        "title": "Device Tracking via Linux's New TCP Source Port Selection Algorithm",
        "authors": "Moshe Kol, Amit Klein, Yossi Gilad",
        "abstract": "We describe a tracking technique for Linux devices, exploiting a new TCP source port generation mechanism recently introduced to the Linux kernel. This mechanism is based on an algorithm, standardized in RFC 6056, for boosting security by better randomizing port selection. Our technique detects collisions in a hash function used in the said algorithm, based on sampling TCP source ports generated in an attacker-prescribed manner. These hash collisions depend solely on a per-device key, and thus the set of collisions forms a device ID that allows tracking devices across browsers, browser privacy modes, containers, and IPv4/IPv6 networks (including some VPNs). It can distinguish among devices with identical hardware and software, and lasts until the device restarts. We implemented this technique and then tested it using tracking servers in two different locations and with Linux devices on various networks. We also tested it on an Android device that we patched to introduce the new port selection algorithm. The tracking technique works in real-life conditions, and we report detailed ﬁndings about it, including its dwell time, scalability, and success rate in different network types. We worked with the Linux kernel team to mitigate the exploit, resulting in a security patch introduced in May 2022 to the Linux kernel, and we provide recommendations for better securing the port selection algorithm in the paper.",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "通过Linux的新TCP源端口选择算法跟踪设备跟踪",
        "abstract_zh": "我们描述了针对Linux设备的跟踪技术，利用了最近引入Linux内核的新的TCP源端口生成机制。 该机制基于在RFC 6056中标准化的算法，用于通过更好的随机端口选择来提高安全性。 我们的技术基于以攻击者规定方式生成的采样TCP源端口，检测到上述算法中使用的哈希函数的碰撞。 这些哈希碰撞仅取决于每个设备密钥，因此碰撞组形成了一个设备ID，该设备ID允许在浏览器，浏览器隐私模式，容器和IPv4/ipv6网络（包括一些VPN）上跟踪设备。 它可以区分具有相同硬件和软件的设备，并持续到设备重新启动为止。 我们实现了此技术，然后使用两个不同位置的跟踪服务器以及各种网络上的Linux设备对其进行了测试。 我们还在Android设备上测试了它，我们对我们进行了修补，以引入新的端口选择算法。 跟踪技术在现实生活中起作用，我们报告了有关它的详细发现，包括其停留时间，可扩展性和在不同网络类型中的成功率。 我们与Linux内核团队合作，以减轻利用，从而导致2022年5月推出的安全补丁，并提供建议，以更好地确保论文中的端口选择算法。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2023.html",
        "conf_title": "32nd USENIX Security Symposium 2023:\nAnaheim, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity23",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.usenix.org/conference/usenixsecurity23/presentation/lee-yoochan",
        "title": "Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique",
        "authors": "Yoochan Lee, Jinhan Kwak, Junesoo Kang, Yuseok Jeon, Byoungyoung Lee",
        "abstract": "The stealthiness of an attack is the most vital consideration for an attacker to reach their goals without being detected. Therefore, attackers put in a great deal of effort to increase the success rate of attacks in order not to expose information on the attacker and attack attempts resulting from failures. Exploitation of the kernel, which is a prime target for the attacker, usually takes advantage of heap-based vulnerabilities, and these exploits’ success rates fortunately remain low (e.g., 56.1% on average) due to the operating principle of the default Linux kernel heap allocator, SLUB. This paper presents P SPRAY , a timing side-channel attack-based exploitation technique that significantly increases the success probability of exploitation. According to our evaluation, with 10 real-world vulnerabilities, P SPRAY significantly improves the success rate of all those vulnerabilities (e.g., from 56.1% to 97.92% on average). To prevent this exploitation technique from being abused by the attacker, we further introduce a new defense mechanism to mitigate the threat of P SPRAY . After applying mitigation, the overall success rate of P SPRAY becomes similar to that from before using P SPRAY with negligible performance overhead (0.25%) and memory overhead (0.52%).",
        "files": {
            "openAccessPdf": ""
        },
        "title_zh": "PSPRAY：基于侧通道的时机Linux内核堆剥削技术",
        "abstract_zh": "攻击的隐身性是攻击者达到目标而不会被发现的最重要的考虑因素。 因此，攻击者付出了巨大的努力，以提高攻击的成功率，以免暴露有关攻击者的信息和失败导致的攻击尝试。 对内核的开发，这是攻击者的主要目标，通常利用基于堆的漏洞，并且这些漏洞的成功率幸运的是，由于默认Linux内核的操作原理，这些漏洞的成功率仍然很低（例如，平均为56.1％） 堆分配器，slub。 本文介绍了P Spray，这是一种基于侧向通道攻击技术，可显着提高剥削的成功概率。 根据我们的评估，P Spray有10个现实世界的漏洞可显着提高所有这些漏洞的成功率（例如，平均为56.1％到97.92％）。 为了防止这种剥削技术被攻击者滥用，我们进一步引入了一种新的防御机制来减轻P喷雾的威胁。 应用缓解措施后，P喷雾的总体成功率与使用P Spray的开销可忽略不计（0.25％）和内存开销（0.52％）相似。",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/uss/uss2023.html",
        "conf_title": "32nd USENIX Security Symposium 2023:\nAnaheim, CA, USA",
        "conf_url": "https://www.usenix.org/conference/usenixsecurity23",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss-paper/auto-draft-246/",
        "title": "An In-depth Analysis of Duplicated Linux Kernel Bug Reports",
        "authors": "Dongliang Mu, Yuhang Wu, Yueqi Chen, Zhenpeng Lin, Chensheng Yu, Xinyu Xing, Gang Wang",
        "abstract": "—In the past three years, the continuous fuzzing projects Syzkaller and Syzbot have achieved great success in detecting kernel vulnerabilities, finding more kernel bugs than those found in the past 20 years. However, a side effect of continuous fuzzing is that it generates an excessive number of crash reports, many of which are “duplicated” reports caused by the same bug. While Syzbot uses a simple heuristic to group (deduplicate) reports, we find that it is often inaccurate. In this paper, we empirically analyze the duplicated kernel bug reports to understand: (1) the prevalence of duplication; (2) the potential costs introduced by duplication; and (3) the key causes behind the duplication problem. We collected all of the fixed kernel bugs from September 2017 to November 2020, including 3.24 million crash reports grouped by Syzbot under 2,526 bug reports (identified by unique bug titles). We found the bug reports indeed had duplication: 47.1% of the 2,526 bug reports are duplicated with one or more other reports. By analyzing the metadata of these reports, we found undetected duplication introduced extra costs in terms of time and developer efforts. Then we organized Linux kernel experts to analyze a sample of duplicated bugs (375 bug reports, unique 120 bugs) and identified 6 key contributing factors to the duplication. Based on these empirical findings, we proposed and prototyped actionable strategies for bug deduplication. After confirming their effectiveness using a ground-truth dataset, we further applied our methods and identified previously unknown duplication",
        "files": {
            "openAccessPdf": "https://doi.org/10.14722/ndss.2022.24159"
        },
        "abstract_zh": "—在过去的三年中，连续的fuzzing项目Syzkaller和Syzbot在检测内核漏洞方面取得了巨大的成功，找到的内核漏洞比过去20年发现的还要多。然而，持续模糊化的一个副作用是它生成了过多的崩溃报告，其中许多是由同一个bug引起的“重复”报告。虽然Syzbot使用简单的启发式方法对报告进行分组(消除重复),但我们发现这通常是不准确的。在本文中，我们对重复的内核错误报告进行了实证分析，以了解:(1)重复的普遍性；(2)重复带来的潜在成本；以及(3)复制问题背后的关键原因。我们收集了2017年9月至2020年11月所有修复的内核bug，包括Syzbot在2526个bug报告下分组的324万个崩溃报告(由唯一的bug标题标识)。我们发现错误报告确实存在重复:2526个错误报告中有47.1%与一个或多个其他报告重复。通过分析这些报告的元数据，我们发现未被发现的重复在时间和开发人员的努力方面引入了额外的成本。然后，我们组织Linux内核专家分析了一个重复错误的样本(375个错误报告，独特的120个错误),并确定了导致重复的6个关键因素。基于这些经验发现，我们提出并原型化了可行的bug去重策略。在使用地面真实数据集确认了它们的有效性之后，我们进一步应用我们的方法并识别了以前未知的重复",
        "title_zh": "对重复的Linux内核错误报告的深入分析",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2022.html",
        "conf_title": "29th NDSS 2022: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2022/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss-paper/auto-draft-247/",
        "title": "Kasper: Scanning for Generalized Transient Execution Gadgets in the Linux Kernel",
        "authors": "Brian Johannesmeyer, Jakob Koschel, Kaveh Razavi, Herbert Bos, Cristiano Giuffrida",
        "abstract": "—Due to the high cost of serializing instructions to mitigate Spectre-like attacks on mispredicted conditional branches (Spectre-PHT), developers of critical software such as the Linux kernel selectively apply such mitigations with annota-tions to code paths they assume to be dangerous under speculative execution. The approach leads to incomplete protection as it applies mitigations only to easy-to-spot gadgets. Still, until now, this was sufﬁcient, because existing gadget scanners (and kernel developers) are pattern-driven: they look for known exploit signatures and cannot detect more generic gadgets. In this paper, we abandon pattern scanning for an approach that models the essential steps used in speculative execution attacks, allowing us to ﬁnd more generic gadgets—well beyond the reach of existing scanners. In particular, we present K ASPER , a speculative execution gadget scanner that uses taint analysis policies to model an attacker capable of exploiting arbitrary software/hardware vulnerabilities on a transient path to control data (e.g., through memory massaging or LVI), access secrets (e.g., through out-of-bounds or use-after-free accesses), and leak these secrets (e.g., through cache-based, MDS-based, or port contention-based covert channels). Finally, where existing solutions target user programs, K ASPER ﬁnds gadgets in the kernel, a higher-value attack target, but also more complicated to analyze. Even though the kernel is heavily hardened against transient execution attacks, K ASPER ﬁnds 1379 gadgets that are not yet mitigated. We conﬁrm our ﬁndings by demonstrating an end-to-end proof-of-concept exploit for one of the gadgets found by K ASPER .",
        "files": {
            "openAccessPdf": "https://doi.org/10.14722/ndss.2022.24221"
        },
        "abstract_zh": "—由于序列化指令以减轻对错误预测的条件分支的类Spectre攻击(Spectre-PHT)的高成本，关键软件(如Linux内核)的开发人员选择性地将这种带有注释的减轻应用于他们认为在推测性执行下是危险的代码路径。这种方法导致保护不完整，因为它只对容易发现的小工具应用缓解措施。尽管如此，到目前为止，这已经足够了，因为现有的小工具扫描器(和内核开发人员)是模式驱动的:它们寻找已知的漏洞特征，无法检测更多的通用小工具。在本文中，我们放弃了模式扫描，转而采用一种对推测性执行攻击中使用的基本步骤进行建模的方法，这种方法使我们能够找到更通用的小工具，远远超出了现有扫描仪的范围。特别地，我们提出了K ASPER，一种推测性的执行小工具扫描器，其使用污点分析策略来模拟攻击者，该攻击者能够利用瞬时路径上的任意软件/硬件漏洞来控制数据(例如，通过内存按摩或LVI)、访问秘密(例如，通过越界或释放后使用访问)，并泄漏这些秘密(例如，通过基于缓存、基于MDS或基于端口争用的隐蔽通道)。最后，当现有解决方案以用户程序为目标时，K会在内核中发现小工具，这是一个价值更高的攻击目标，但分析起来也更复杂。尽管内核针对瞬时执行攻击进行了大量强化，但K发现了1379个尚未缓解的小工具。我们通过展示K ASPER发现的一个小工具的端到端概念验证利用来确认我们的发现。",
        "title_zh": "Kasper:扫描Linux内核中的通用瞬态执行小工具",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2022.html",
        "conf_title": "29th NDSS 2022: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2022/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss-paper/auto-draft-249/",
        "title": "Progressive Scrutiny: Incremental Detection of UBI bugs in the Linux Kernel",
        "authors": "Yizhuo Zhai, Yu Hao, Zheng Zhang, Weiteng Chen, Guoren Li, Zhiyun Qian, Chengyu Song, Manu Sridharan, Srikanth V. Krishnamurthy, Trent Jaeger, Paul L. Yu",
        "abstract": "—The Linux kernel has a rapid development cycle, with 10 commits every hour, on average. While these updates provide new features and bug ﬁxes, they can also introduce new bugs and security vulnerabilities. Recent techniques showed how to detect some types of vulnerabilities using static analysis, but these tools cannot run quickly enough to keep up with the pace of kernel development. Ideally, an incremental analysis technique could address this problem, by doing a complete analysis once and then only analyzing changed portions of the code subsequently. However, incremental analysis of the Linux kernel poses unique challenges, due to its enormous scale and the high precision required to reduce false positives. In this paper, we design and implement I NCRE L UX , a novel Linux kernel incremental analysis tool. It allows rapid vulnerability detection after each update, via targeted analysis of the new code and affected prior code, and also speeds the tracking of pre-existing bugs to understand how long they have been present, thereby increasing awareness of such bugs. Our approach hinges on a bottom-up, function-summary-based approach, which leverages the beneﬁts of a one-time clean-slate, but expensive analysis of a prior Linux baseline. I NCRE L UX also uses an effective heuristic to apply symbolic execution to incremental results to improve precision. Via extensive experiments on the challenging problem of ﬁnding use-before-initialization (UBI) bugs, we showcase a",
        "files": {
            "openAccessPdf": "https://doi.org/10.14722/ndss.2022.24380"
        },
        "abstract_zh": "Linux内核的开发周期很快，平均每小时提交10次。虽然这些更新提供了新的功能和缺陷，但它们也可能引入新的缺陷和安全漏洞。最近的技术显示了如何使用静态分析来检测某些类型的漏洞，但是这些工具的运行速度不够快，无法跟上内核开发的步伐。理想情况下，增量分析技术可以解决这个问题，只需进行一次完整的分析，然后只分析代码中发生变化的部分。然而，Linux内核的增量分析带来了独特的挑战，这是由于其巨大的规模和减少误报所需的高精度。本文设计并实现了一种新型的Linux内核增量分析工具I·NCRE·L·UX。它允许在每次更新后通过对新代码和受影响的先前代码的有针对性的分析来快速检测漏洞，并且还加速了对预先存在的缺陷的跟踪，以了解它们已经存在了多长时间，从而提高了对这种缺陷的认识。我们的方法依赖于一种自下而上的、基于功能总结的方法，这种方法利用了一次性清理的优点，但是对以前的Linux基线进行昂贵的分析。NCRE·L·UX还使用了一种有效的启发式算法，将符号执行应用于增量结果以提高精度。通过对发现初始化前使用(UBI)错误这一挑战性问题的大量实验，我们展示了一个",
        "title_zh": "渐进式审查:Linux内核中UBI错误的渐进式检测",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2022.html",
        "conf_title": "29th NDSS 2022: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2022/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss-paper/hfl-hybrid-fuzzing-on-the-linux-kernel/",
        "title": "HFL: Hybrid Fuzzing on the Linux Kernel",
        "authors": "Kyungtae Kim, Dae R. Jeong, Chung Hwan Kim, Yeongjin Jang, Insik Shin, Byoungyoung Lee",
        "abstract": "Hybrid fuzzing, combining symbolic execution and fuzzing, is a promising approach for vulnerability discovery because each approach can complement the other. However, we observe that applying hybrid fuzzing to kernel testing is challenging because the following unique characteristics of the kernel make a naive adoption of hybrid fuzzing inefficient: 1) having indirect control transfers determined by system call arguments, 2) controlling and matching internal system state via system calls, and 3) inferring nested argument type for invoking system calls. Failure to handling such challenges will render both fuzzing and symbolic execution inefficient, and thereby, will result in an inefficient hybrid fuzzing. Although these challenges are essential to both fuzzing and symbolic execution, to the best of our knowledge, existing kernel testing approaches either naively use each technique separately without handling such challenges or imprecisely handle a part of challenges only by static analysis. To this end, this paper proposes HFL, which not only combines fuzzing with symbolic execution for hybrid fuzzing but also addresses kernel-specific fuzzing challenges via three distinct features: 1) converting indirect control transfers to direct transfers, 2) inferring system call sequence to build a consistent system state, and 3) identifying nested arguments types of system calls. As a result, HFL found 24 previously unknown vulnerabilities in recent Linux kernels. Additionally, HFL achieves 15% and 26% higher code coverage than Moonshine and Syzkaller, respectively, and over kAFL/S2E/TriforceAFL, achieving even four times better coverage, using the same amount of resources (CPU, time, etc.). Regarding vulnerability discovery performance, HFL found 13 known vulnerabilities more than three times faster than Syzkaller.",
        "files": {
            "openAccessPdf": "https://doi.org/10.14722/ndss.2020.24018"
        },
        "abstract_zh": "混合模糊化结合了符号执行和模糊化，是一种很有前途的漏洞发现方法，因为这两种方法可以相互补充。然而，我们观察到，将混合模糊化应用于内核测试是具有挑战性的，因为内核的以下独特特征使得混合模糊化的天真采用效率低下:1)由系统调用参数确定间接控制转移，2)通过系统调用控制和匹配内部系统状态，以及3)推断用于调用系统调用的嵌套参数类型。未能处理这样的挑战将使模糊化和符号执行效率低下，从而导致低效的混合模糊化。尽管这些挑战对于模糊化和符号化执行都是必不可少的，但据我们所知，现有的内核测试方法要么天真地单独使用每种技术而不处理这些挑战，要么仅通过静态分析不精确地处理部分挑战。为此，本文提出了HFL，它不仅将模糊化与符号执行相结合用于混合模糊化，而且通过三个不同的特性解决了内核特定的模糊化挑战:1)将间接控制转移转换为直接转移，2)推断系统调用序列以构建一致的系统状态，以及3)识别系统调用的嵌套参数类型。结果，HFL在最近的Linux内核中发现了24个以前未知的漏洞。此外，在使用相同数量的资源(CPU、时间等)的情况下，HFL的代码覆盖率分别比Moonshine和Syzkaller高15%和26%，比kAFL/S2E/TriforceAFL高4倍。).在漏洞发现性能方面，HFL发现13个已知漏洞的速度比Syzkaller快三倍多。",
        "title_zh": "HFL:Linux内核上的混合模糊化",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2020.html",
        "conf_title": "27th NDSS 2020: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2020/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss-paper/precisely-characterizing-security-impact-in-a-flood-of-patches-via-symbolic-rule-comparison/",
        "title": "Precisely Characterizing Security Impact in a Flood of Patches via Symbolic Rule Comparison",
        "authors": "Qiushi Wu, Yang He, Stephen McCamant, Kangjie Lu",
        "abstract": "A bug is a vulnerability if it has security impacts when triggered. Determining the security impacts of a bug is important to both defenders and attackers. Maintainers of large software systems are bombarded with numerous bug reports and proposed patches, with missing or unreliable information about their impact. Determining which few bugs are vulnerabilities is difficult, and bugs that a maintainer believes do not have security impact will be de-prioritized or even ignored. On the other hand, a public report of a bug with a security impact is a powerful first step towards exploitation. Adversaries may exploit such bugs to launch devastating attacks if defenders do not fix them promptly. Common practice is for maintainers to assess the security impacts of bugs manually, but the scaling and reliability challenges of manual analysis lead to missed vulnerabilities. We propose an automated approach, SID, to determine the security impacts for a bug given its patch, so that maintainers can effectively prioritize applying the patch to the affected programs. The insight behind SID is that both the effect of a patch (either submitted or applied) and security-rule violations (e.g., out-of-bound access) can be modeled as constraints that can be automatically solved. SID incorporates rule comparison, using under-constrained symbolic execution of a patch to determine the security impacts of an un-applied patch. SID can further automatically classify vulnerabilities based on their security impacts. We have implemented SID and applied it to bug patches of the Linux kernel and matching CVE-assigned vulnerabilities to evaluate its precision and recall. We optimized SID to reduce false positives, and our evaluation shows that, from 54K recent valid commit patches, SID detected 227 security bugs with at least 243 security impacts at a 97% precision rate. Critically, 197 of them were not reported as vulnerabilities before, leading to delayed or ignored patching in derivative programs. Even worse, 21 of them are still unpatched in the latest Android kernel. Once exploited, they can cause critical security impacts on Android devices. The evaluation results confirm that SID’s approach is effective and precise in automatically determining security impacts for a massive stream of bug patches.",
        "files": {
            "openAccessPdf": "https://doi.org/10.14722/ndss.2020.24419"
        },
        "abstract_zh": "如果一个bug在被触发时会产生安全影响，那么它就是一个漏洞。确定bug的安全影响对防御方和攻击方都很重要。大型软件系统的维护者被大量的错误报告和建议的补丁轰炸，关于它们的影响的信息缺失或不可靠。确定哪几个bug是漏洞是困难的，维护人员认为没有安全影响的bug会被降低优先级，甚至被忽略。另一方面，公开报告一个具有安全影响的错误是利用漏洞的有力的第一步。如果防御方不及时修复这些漏洞，对手可能会利用这些漏洞发动毁灭性的攻击。通常的做法是让维护人员手动评估bug的安全影响，但是手动分析的可扩展性和可靠性挑战会导致遗漏漏洞。我们提出了一种自动化的方法，SID，来确定给定补丁的bug的安全影响，以便维护人员可以有效地优先对受影响的程序应用补丁。SID背后的观点是，补丁的影响(无论是提交的还是应用的)和违反安全规则的行为(例如，越界访问)都可以建模为可以自动解决的约束。SID合并了规则比较，使用补丁的欠约束符号执行来确定未应用补丁的安全影响。SID可以根据安全影响进一步自动对漏洞进行分类。我们已经实现了SID，并将其应用于Linux内核的错误补丁和匹配CVE分配的漏洞，以评估其精度和召回率。我们优化了SID以减少误报，我们的评估显示，从54K个最近有效的提交补丁中，SID以97%的准确率检测到227个安全漏洞，至少有243个安全影响。关键的是，其中197个以前没有被报告为漏洞，导致衍生程序中的补丁被延迟或忽略。更糟糕的是，其中有21个仍然没有在最新的Android内核中打补丁。一旦被利用，它们会对Android设备造成严重的安全影响。评估结果证实了SID的方法在自动确定大规模bug补丁流的安全影响方面是有效和精确的。",
        "title_zh": "通过符号规则比较精确描述大量补丁的安全影响",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2020.html",
        "conf_title": "27th NDSS 2020: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2020/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss-paper/no-grammar-no-problem-towards-fuzzing-the-linux-kernel-without-system-call-descriptions/",
        "title": "No Grammar, No Problem: Towards Fuzzing the Linux Kernel without System-Call Descriptions",
        "authors": "Alexander Bulekov, Bandan Das, Stefan Hajnoczi, Manuel Egele",
        "abstract": "The integrity of the entire computing ecosystem depends on the security of our operating systems (OSes). Unfortunately, due to the scale and complexity of OS code, hundreds of security issues are found in OSes, every year [32]. As such, operating systems have constantly been prime use-cases for applying security-analysis tools. In recent years, fuzz-testing has appeared as the dominant technique for automatically finding security issues in software. As such, fuzzing has been adapted to find thousands of bugs in kernels [14]. However, modern OS fuzzers, such as Syzkaller, rely on precise, extensive, manuallycreated harnesses and grammars for each interface fuzzed within the kernel. Due to this reliance on grammars, current OS fuzzers are faced with scaling-issues. In this paper, we present FUZZNG, our generic approach to fuzzing system-calls on OSes. Unlike Syzkaller, FUZZNG does not require intricate descriptions of system-call interfaces in order to function. Instead FUZZNG leverages fundamental kernel design features in order to reshape and simplify the fuzzer’s input-space. As such FUZZNG only requires a small config, for each new target: essentially a list of files and system-call numbers the fuzzer should explore. We implemented FUZZNG for the Linux kernel. Testing FUZZNG over 10 Linux components with extensive descriptions in Syzkaller showed that, on average, FUZZNG achieves 102.5% of Syzkaller’s coverage. FUZZNG found 9 new bugs (5 in components that Syzkaller had already fuzzed extensively, for years). Additionally, FUZZNG’s lightweight configs are less than 1.7% the size of Syzkaller’s manually-written grammars. Crucially, FUZZNG achieves this without initial seed-inputs, or expert guidance.",
        "files": {
            "openAccessPdf": "https://doi.org/10.14722/ndss.2023.24688"
        },
        "abstract_zh": "整个计算生态系统的完整性取决于我们操作系统的安全性。不幸的是，由于操作系统代码的规模和复杂性，每年都会在操作系统中发现数百个安全问题[32]。因此，操作系统一直是应用安全分析工具的主要用例。近年来，模糊测试已经成为自动发现软件安全问题的主要技术。因此，模糊化已经被用来发现内核中的数千个bug[14]。然而，现代的操作系统模糊化器，比如Syzkaller，依赖于精确的、广泛的、手工创建的线束和语法来模糊化内核中的每个接口。由于这种对语法的依赖，当前的操作系统模糊器面临着缩放问题。在本文中，我们提出了FUZZNG，我们的通用方法来模糊系统调用操作系统。与Syzkaller不同，FUZZNG不需要复杂的系统调用接口描述就能运行。相反，FUZZNG利用基本的内核设计特性来重塑和简化模糊器的输入空间。因此，对于每个新目标，FUZZNG只需要一个很小的配置:本质上是fuzzer应该搜索的文件和系统调用号的列表。我们为Linux内核实现了FUZZNG。通过在Syzkaller中对超过10个Linux组件进行大量描述的测试，FUZZNG平均达到了Syzkaller覆盖率的102.5%。FUZZNG发现了9个新的bug(其中5个是Syzkaller已经模糊化了很多年的组件)。此外，FUZZNG的轻量级配置还不到Syzkaller手工编写的语法的1.7%。至关重要的是，FUZZNG在没有初始种子投入或专家指导的情况下实现了这一目标。",
        "title_zh": "没有语法，没有问题:在没有系统调用描述的情况下模糊Linux内核",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2023.html",
        "conf_title": "30th NDSS 2023: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2023/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss2015/whats-your-dongle-and-bank-account-mandatory-and-discretionary-protection-android-external",
        "title": "What's in Your Dongle and Bank Account? Mandatory and Discretionary Protection of Android External Resources",
        "authors": "Soteris Demetriou, Xiao-yong Zhou, Muhammad Naveed, Yeonjoon Lee, Kan Yuan, XiaoFeng Wang, Carl A. Gunter",
        "abstract": "To address this challenge, we present in this paper SEACAT, a new security system for fine-grained, flexible protection on external resources. SEACAT supports both MAC and DAC, and integrates their enforcement mechanisms across the Android middleware and the Linux kernel. It extends SEAndroid for specifying policies on external resources, and also hosts a DAC policy base. Both sets of policies are managed under the same policy engine and Access Vector Cache that support policy checks within the security hooks distributed across the framework and the Linux kernel layers, over different channels. This integrated security model was carefully designed to ensure that misconfigured DAC policies will not affect the enforcement of MAC policies, which manufacturers and system administrators can leverage to define their security rules. In the meantime, a policy management service is offered to the ordinary Android users for setting policies that protect the resources provided by the third party. This service translates simple user selections into SELinux-compatible policies in the background. Our implementation is capable of thwarting all known attacks on external resources at a negligible performance cost.",
        "files": {
            "openAccessPdf": "http://spiral.imperial.ac.uk/bitstream/10044/1/68241/2/demetriouNDSS15.pdf"
        },
        "abstract_zh": "为了应对这一挑战，我们在本文中介绍了SEACAT，一种新的安全系统，用于对外部资源进行细粒度、灵活的保护。SEACAT支持MAC和DAC，并在Android中间件和Linux内核中集成了它们的执行机制。它扩展了SEAndroid以指定外部资源上的策略，并且还托管了一个DAC策略库。两组策略都在同一个策略引擎和访问向量缓存下进行管理，访问向量缓存支持在不同通道上跨框架和Linux内核层分布的安全挂钩内进行策略检查。这种集成的安全模型经过精心设计，以确保错误配置的DAC策略不会影响MAC策略的实施，制造商和系统管理员可以利用这些策略来定义他们的安全规则。同时，向普通Android用户提供策略管理服务，用于设置保护第三方提供的资源的策略。该服务在后台将简单的用户选择转换成SELinux兼容的策略。我们的实现能够以微不足道的性能代价挫败所有已知的对外部资源的攻击。",
        "title_zh": "你的加密狗和银行账户里有什么？Android外部资源的强制和任意保护",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2015.html",
        "conf_title": "NDSS 2015: San Diego, California, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2015/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2018/02/ndss2018_05A-1_Gens_paper.pdf",
        "title": "K-Miner: Uncovering Memory Corruption in Linux",
        "authors": "David Gens, Simon Schmitt, Lucas Davi, Ahmad-Reza Sadeghi",
        "abstract": "Operating system kernels are appealing attack targets: compromising the kernel usually allows attackers to bypass all deployed security mechanisms and take control over the entire system. Commodity kernels, like Linux, are written in low-level programming languages that offer only limited type and memory-safety guarantees, enabling adversaries to launch sophisticated run-time attacks against the kernel by exploiting memory-corruption vulnerabilities. Many defenses have been proposed to protect operating systems at run time, such as control-flow integrity (CFI). However, the goal of these run-time monitors is to prevent exploitation as a symptom of memory corruption, rather than eliminating the underlying root cause, i.e., bugs in the kernel code. While finding bugs can be automated, e.g., using static analysis, all existing approaches are limited to local, intra-procedural checks, and face severe scalability challenges due to the large kernel code base. Consequently, there currently exist no tools for conducting global static analysis of operating system kernels. In this paper, we present K-Miner, a new framework to efficiently analyze large, commodity operating system kernels like Linux. Our novel approach exploits the highly standardized interface structure of the kernel code to enable scalable pointer analysis and conduct global, context-sensitive analysis. Through our inter-procedural analysis we show that K-Miner systematically and reliably uncovers several different classes of memory-corruption vulnerabilities, such as dangling pointers, user-after-free, double-free, and double-lock vulnerabilities. We thoroughly evaluate our extensible analysis framework, which leverages the popular and widely used LLVM compiler suite, for the current Linux kernel and demonstrate its effectiveness by reporting several memory-corruption vulnerabilities.",
        "files": {
            "openAccessPdf": "https://doi.org/10.14722/ndss.2018.23326"
        },
        "abstract_zh": "操作系统内核是吸引人的攻击目标:损害内核通常允许攻击者绕过所有部署的安全机制并控制整个系统。像Linux这样的商用内核是用低级编程语言编写的，这些语言只提供有限的类型和内存安全保证，使得对手能够通过利用内存损坏漏洞对内核发起复杂的运行时攻击。已经提出了许多防御措施来在运行时保护操作系统，例如控制流完整性(CFI)。然而，这些运行时监视器的目标是防止作为内存损坏症状的利用，而不是消除潜在的根本原因，即内核代码中的错误。虽然可以例如使用静态分析来自动查找缺陷，但是所有现有的方法都局限于本地的过程内检查，并且由于大的内核代码库而面临严重的可扩展性挑战。因此，目前不存在对操作系统内核进行全局静态分析的工具。在本文中，我们介绍了K-Miner，这是一个新的框架，可以有效地分析大型商用操作系统内核，如Linux。我们的新方法利用内核代码的高度标准化的接口结构来实现可扩展的指针分析，并进行全局的上下文敏感的分析。通过我们的过程间分析，我们表明K-Miner系统而可靠地揭示了几种不同类别的内存损坏漏洞，如悬空指针、释放后用户、双释放和双锁漏洞。我们全面评估了我们的可扩展分析框架，该框架利用了流行且广泛使用的LLVM编译器套件，适用于当前的Linux内核，并通过报告几个内存损坏漏洞展示了其有效性。",
        "title_zh": "K-Miner:揭露Linux中的内存损坏",
        "year": "2018",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2018.html",
        "conf_title": "25th NDSS 2018: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2018/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss2017/ndss-2017-programme/safelnit-comprehensive-and-practical-mitigation-uninitialized-read-vulnerabilities/",
        "title": "Safelnit: Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities",
        "authors": "Alyssa Milburn, Herbert Bos, Cristiano Giuffrida",
        "abstract": "Usage of uninitialized values remains a common error in C/C++ code. This results not only in undefined and generally undesired behavior, but is also a cause of information disclosure and other security vulnerabilities. Existing solutions for mitigating such errors are not used in practice as they are either limited in scope (for example, only protecting the heap), or incur high runtime overhead. In this paper, we propose SafeInit, a practical protection system which hardens applications against such undefined behavior by guaranteeing initialization of all values on the heap and stack, every time they are allocated or come into scope. Doing so provides comprehensive protection against this class of vulnerabilities in generic programs, including both information disclosure and re-use/logic vulnerabilities. We show that, with carefully designed compiler optimizations, our implementation achieves sufficiently low overhead (<5% for typical server applications and SPEC CPU2006) to serve as a standard hardening protection in practical settings. Moreover, we show that we can effortlessly apply it to harden non-standard code, such as the Linux kernel, with low runtime overhead.",
        "files": {
            "openAccessPdf": "https://download.vusec.net/papers/safeinit_ndss17.pdf"
        },
        "abstract_zh": "使用未初始化的值仍然是C/C++代码中的常见错误。这不仅会导致未定义的和通常不希望的行为，而且还会导致信息泄露和其他安全漏洞。用于减轻这种错误的现有解决方案没有在实践中使用，因为它们或者在范围上受到限制(例如，仅保护堆)，或者导致高运行时开销。在本文中，我们提出了SafeInit，这是一个实用的保护系统，它通过保证在每次分配或进入范围时初始化堆和堆栈上的所有值，来加强应用程序对这种未定义行为的防范。这样做提供了针对一般程序中这类漏洞的全面保护，包括信息泄露和重用/逻辑漏洞。我们表明，通过精心设计的编译器优化，我们的实现实现了足够低的开销(对于典型的服务器应用和SPEC CPU2006，开销小于5%)，可以作为实际设置中的标准强化保护。此外，我们展示了我们可以毫不费力地应用它来强化非标准代码，如Linux内核，而运行时开销很低。",
        "title_zh": "Safelnit:全面实用的未初始化读取漏洞缓解措施",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2017.html",
        "conf_title": "24th NDSS 2017: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2017/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss2017/ndss-2017-programme/pt-rand-practical-mitigation-data-only-attacks-against-page-tables/",
        "title": "PT-Rand: Practical Mitigation of Data-only Attacks against Page Tables",
        "authors": "Lucas Davi, David Gens, Christopher Liebchen, Ahmad-Reza Sadeghi",
        "abstract": "Kernel exploits constitute a powerful attack class allowing attackers to gain full control over a system. Various kernel hardening solutions have been proposed or deployed in practice to protect the kernel against code injection (e.g., DEP) or code-reuse exploits (e.g., CFI). However, the security of all these hardening techniques relies heavily on the assumption that kernel page tables cannot be manipulated, e.g., by means of dataonly attacks. Ensuring kernel page tables integrity is not only essential for kernel security but also a challenging task in practice since existing solutions require hardware trust anchors, costly hypervisors, or inefficient integrity checks. In this paper, we first motivate the importance of protecting kernel page tables by presenting a data-only attack against page tables to bypass the recently released CFI-based (Linux) kernel hardening technique RAP. Thereafter, we present the design and implementation of PT-Rand, the first practical solution to protect kernel page tables that does not suffer from the mentioned deficiencies of previous proposals. PT-Rand randomizes the location of page tables and tackles a number of challenges to ensure that the location of page tables is not leaked. This effectively prevents the attacker from manipulating access permissions of code pages, thereby enabling secure enforcement of kernel exploit mitigation technologies such as CFI. We extensively evaluate our prototype implementation of PT-Rand for the current Linux kernel on the popular Linux distribution Debian and report a low overhead of 0.22% for common benchmarks. Moreover, we combine RAP with PT-Rand to protect RAP against data-only attacks on kernel page tables.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "内核漏洞构成了一个强大的攻击类别，使得攻击者能够完全控制系统。在实践中已经提出或部署了各种内核加固解决方案来保护内核免受代码注入(例如，DEP)或代码重用利用(例如，CFI)。然而，所有这些加固技术的安全性严重依赖于内核页表不能被操纵的假设，例如，通过仅数据攻击。确保内核页表的完整性不仅对内核安全性至关重要，而且在实践中也是一项具有挑战性的任务，因为现有的解决方案需要硬件信任锚、昂贵的管理程序或低效的完整性检查。在本文中，我们首先提出了一种针对页表的纯数据攻击，以绕过最近发布的基于CFI的(Linux)内核加固技术RAP，从而激发了保护内核页表的重要性。此后，我们介绍了PT-Rand的设计和实现，这是第一个保护内核页表的实用解决方案，它不会遭受前面建议中提到的缺陷。PT-Rand将页表的位置随机化，并解决了许多挑战，以确保页表的位置不会泄露。这有效地防止了攻击者操纵代码页的访问权限，从而能够安全地实施内核漏洞利用缓解技术，如CFI。我们在流行的Linux发行版Debian上对当前Linux内核的PT-Rand原型实现进行了广泛的评估，并报告了常见基准的0.22%的低开销。此外，我们将RAP与PT-Rand结合起来，保护RAP免受内核页表的纯数据攻击。",
        "title_zh": "PT-Rand:针对页表的纯数据攻击的实际缓解",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2017.html",
        "conf_title": "24th NDSS 2017: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2017/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://www.ndss-symposium.org/ndss2017/ndss-2017-programme/unleashing-use-initialization-vulnerabilities-linux-kernel-using-targeted-stack-spraying/",
        "title": "Unleashing Use-Before-Initialization Vulnerabilities in the Linux Kernel Using Targeted Stack Spraying",
        "authors": "Kangjie Lu, Marie-Therese Walter, David Pfaff, Stefan Nümberger, Wenke Lee, Michael Backes",
        "abstract": "A common type of memory error in the Linux kernel is using uninitialized variables (uninitialized use). Uninitialized uses not only cause undefined behaviors but also impose a severe security risk if an attacker takes control of the uninitialized variables. However, reliably exploiting uninitialized uses on the kernel stack has been considered infeasible until now since the code executed prior to triggering the vulnerability must leave an attacker-controlled pattern on the stack. Therefore, uninitialized uses are largely overlooked and regarded as undefined behaviors, rather than security vulnerabilities. In particular, full memorysafety techniques (e.g., SoftBound+CETS) exclude uninitialized use as a prevention target, and widely used systems such as OpenSSL even use uninitialized memory as a randomness source. In this paper, we propose a fully automated targeted stackspraying approach for the Linux kernel that reliably facilitates the exploitation of uninitialized uses. Our targeted stack-spraying includes two techniques: (1) a deterministic stack spraying technique that suitably combines tailored symbolic execution and guided fuzzing to identify kernel inputs that user-mode programs can use to deterministically guide kernel code paths and thereby leave attacker-controlled data on the kernel stack, and (2) an exhaustive memory spraying technique that uses memory occupation and pollution to reliably control a large region of the kernel stack. We show that our targeted stack-spraying approach allows attackers to reliably control more than 91% of the Linux kernel stack, which, in combination with uninitialized-use vulnerabilities, suffices for a privilege escalation attack. As a countermeasure, we propose a compiler-based mechanism that initializes potentially unsafe pointer-type fields with almost no performance overhead. Our results show that uninitialized use is a severe attack vector that can be readily exploited with targeted stack-spraying, so future memory-safety techniques should consider it a prevention target, and systems should not use uninitialized memory as a randomness source.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "Linux内核中一种常见的内存错误是使用未初始化的变量(未初始化的使用)。未初始化的使用不仅会导致未定义的行为，而且如果攻击者控制了未初始化的变量，还会带来严重的安全风险。然而，可靠地利用内核堆栈上未初始化的使用一直被认为是不可行的，因为在触发漏洞之前执行的代码必须在堆栈上留下攻击者控制的模式。因此，未初始化的使用在很大程度上被忽略，并被视为未定义的行为，而不是安全漏洞。特别是，全内存安全技术(例如，软绑定+CETS)将未初始化的使用排除在预防目标之外，OpenSSL等广泛使用的系统甚至将未初始化的内存用作随机性来源。在本文中，我们为Linux内核提出了一种全自动的目标堆栈扫描方法，该方法可靠地促进了对未初始化使用的利用。我们的目标堆栈喷射包括两种技术:(1)确定性堆栈喷射技术，其适当地结合了定制的符号执行和引导模糊化，以识别用户模式程序可以用来确定性地引导内核代码路径的内核输入，从而在内核堆栈上留下攻击者控制的数据，以及(2)穷尽性内存喷射技术，其使用内存占用和污染来可靠地控制内核堆栈的大区域。我们表明，我们的目标堆栈喷射方法允许攻击者可靠地控制超过91%的Linux内核堆栈，结合未初始化使用漏洞，足以进行权限提升攻击。作为对策，我们提出了一种基于编译器的机制，它初始化潜在不安全的指针类型字段，几乎没有性能开销。我们的结果表明，未初始化的使用是一个严重的攻击媒介，可以很容易地利用有针对性的堆栈喷射，因此未来的内存安全技术应该将其视为一个预防目标，并且系统不应该使用未初始化的内存作为随机性来源。",
        "title_zh": "使用目标堆栈喷射释放Linux内核中的初始化前使用漏洞",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ndss/ndss2017.html",
        "conf_title": "24th NDSS 2017: San Diego, CA, USA",
        "conf_url": "https://www.ndss-symposium.org/ndss2017/",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3372297.3417256",
        "title": "Exaggerated Error Handling Hurts! An In-Depth Study and Context-Aware Detection",
        "authors": "Aditya Pakki, Kangjie Lu",
        "abstract": "Operating system (OS) kernels frequently encounter various errors due to invalid internal states or external inputs. To ensure the security and reliability of OS kernels, developers propose a diverse set of mechanisms to conservatively capture and handle potential errors. Existing research has thus primarily focused on the completeness and adequacy of error handling to not miss the attention. However, we find that handling an error with an over-severe level (e.g., unnecessarily terminating the execution) instead hurts the security and reliability. In this case, the error-handling consequences are even worse than the error it attempts to resolve. We call such a case Exaggerated Error Handling (EEH). The security impacts of EEH bugs vary, including denial-of-service, data losses, broken control-flow integrity, memory leaks, etc. Despite its significance, detecting EEH remains an unexplored topic. In this paper, we first conduct an in-depth study on EEH. Based on the findings of the study, we then propose an approach, EeCatch, to detect EEH bugs in a context-aware manner. EeCatch accurately identifies errors and extracts their contexts (both spatial and temporal), and automatically infers the appropriate severity level for error handling. Using the inferred severity level, EeCatch finally detects EEH bugs in which the used error handling exceeds the inferred severity level. By analyzing the whole Linux kernel, EeCatch reports hundreds of potential EEH bugs that may cause security issues such as crashing the system. After evaluating 104 cases reported by EeCatch, we manually confirmed 64 EEH bugs and submitted patches for all of them. Using our patches, Linux maintainers have fixed 48 reported EEH bugs, confirming the effectiveness of EeCatch. To the best of our knowledge, we are the first to systematically study and detect EEH bugs. We hope the findings could raise the awareness of the critical consequences of EEH bugs to help developers avoid them.",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3372297.3417256"
        },
        "abstract_zh": "由于无效的内部状态或外部输入，操作系统(OS)内核经常遇到各种错误。为了确保操作系统内核的安全性和可靠性，开发人员提出了一套不同的机制来保守地捕获和处理潜在的错误。因此，现有的研究主要集中在错误处理的完整性和充分性上，以避免遗漏注意力。然而，我们发现处理过度严重的错误(例如，不必要地终止执行)反而会损害安全性和可靠性。在这种情况下，错误处理的后果甚至比它试图解决的错误还要糟糕。我们称这种情况为夸大的错误处理(EEH)。EEH错误的安全影响各不相同，包括拒绝服务、数据丢失、控制流完整性被破坏、内存泄漏等。尽管意义重大，探测EEH仍然是一个未被探索的课题。本文首先对EEH进行了深入的研究。基于这项研究的发现，我们提出了一种方法，EeCatch，以上下文感知的方式检测EEH错误。EeCatch准确地识别错误并提取它们的上下文(包括空间和时间)，并自动推断错误处理的适当严重性级别。使用推断的严重性级别，EeCatch最终检测到EEH错误，其中使用的错误处理超过了推断的严重性级别。通过分析整个Linux内核，EeCatch报告了数百个潜在的EEH错误，这些错误可能会导致系统崩溃等安全问题。在评估了EeCatch报告的104个案例后，我们人工确认了64个EEH漏洞，并为所有这些漏洞提交了补丁。使用我们的补丁，Linux维护者已经修复了48个报告的EEH错误，证实了EeCatch的有效性。据我们所知，我们是第一个系统地研究和检测EEH病毒的人。我们希望这些发现可以提高对EEH错误的严重后果的认识，以帮助开发人员避免它们。",
        "title_zh": "夸张的错误处理很伤人！深入研究和上下文感知检测",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2020.html",
        "conf_title": "27th CCS 2020: Virtual Event, USA",
        "conf_url": "https://doi.org/10.1145/3372297",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3372297.3417884",
        "title": "Off-Path TCP Exploits of the Mixed IPID Assignment",
        "authors": "Xuewei Feng, Chuanpu Fu, Qi Li, Kun Sun, Ke Xu",
        "abstract": "In this paper, we uncover a new off-path TCP hijacking attack that can be used to terminate victim TCP connections or inject forged data into victim TCP connections by manipulating the new mixed IPID assignment method, which is widely used in Linux kernel version 4.18 and beyond to help defend against TCP hijacking attacks. The attack has three steps. First, an off-path attacker can downgrade the IPID assignment for TCP packets from the more secure per-socket-based policy to the less secure hash-based policy, building a shared IPID counter that forms a side channel on the victim. Second, the attacker detects the presence of TCP connections by observing the shared IPID counter on the victim. Third, the attacker infers the sequence number and the acknowledgment number of the detected connection by observing the side channel of the shared IPID counter. Consequently, the attacker can completely hijack the connection, i.e., resetting the connection or poisoning the data stream. We evaluate the impacts of this off-path TCP attack in the real world. Our case studies of SSH DoS, manipulating web traffic, and poisoning BGP routing tables show its threat on a wide range of applications. Our experimental results show that our off-path TCP attack can be constructed within 215 seconds and the success rate is over 88%. Finally, we analyze the root cause of the exploit and develop a new IPID assignment method to defeat this attack. We prototype our defense in Linux 4.18 and confirm its effectiveness through extensive evaluation over real applications on the Internet.",
        "files": {
            "openAccessPdf": "http://arxiv.org/pdf/2008.12981"
        },
        "abstract_zh": "在本文中，我们发现了一种新的路径外TCP劫持攻击，通过操纵新的混合IPID分配方法，该攻击可用于终止受害者TCP连接或将伪造数据注入受害者TCP连接，这种方法在Linux内核4.18版及更高版本中广泛使用，有助于防御TCP劫持攻击。攻击有三个步骤。首先，路径外攻击者可以将TCP数据包的IPID分配从更安全的基于每个套接字的策略降级到不太安全的基于哈希的策略，建立一个共享的IPID计数器，在受害者上形成一个侧信道。其次，攻击者通过观察受害者的共享IPID计数器来检测TCP连接的存在。第三，攻击者通过观察共享IPID计数器的副信道来推断检测到的连接的序列号和确认号。因此，攻击者可以完全劫持连接，即重置连接或毒害数据流。我们评估了这种路径外TCP攻击在现实世界中的影响。我们对SSH DoS、操纵web流量和毒害BGP路由表的案例研究显示了它对各种应用程序的威胁。实验结果表明，我们的路径外TCP攻击可以在215秒内完成，成功率超过88%。最后，我们分析了这种攻击的根本原因，并提出了一种新的IPID分配方法来抵御这种攻击。我们在Linux 4.18中实现了我们的防御原型，并通过对互联网上真实应用程序的广泛评估确认了它的有效性。",
        "title_zh": "混合IPID分配的路径外TCP利用",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2020.html",
        "conf_title": "27th CCS 2020: Virtual Event, USA",
        "conf_url": "https://doi.org/10.1145/3372297",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3372297.3417862",
        "title": "Logging to the Danger Zone: Race Condition Attacks and Defenses on System Audit Frameworks",
        "authors": "Riccardo Paccagnella, Kevin Liao, Dave Tian, Adam Bates",
        "abstract": "For system logs to aid in security investigations, they must be beyond the reach of the adversary. Unfortunately, attackers that have escalated privilege on a host are typically able to delete and modify log events at will. In response to this threat, a variety of secure logging systems have appeared over the years that attempt to provide tamper-resistance (e.g., write once read many drives, remote storage servers) or tamper-evidence (e.g., cryptographic proofs) for system logs. These solutions expose an interface through which events are committed to a secure log, at which point they enjoy protection from future tampering. However, all proposals to date have relied on the assumption that an event's occurrence is concomitant with its commitment to the secured log. In this work, we challenge this assumption by presenting and validating a race condition attack on the integrity of audit frameworks. Our attack exploits the intrinsically asynchronous nature of I/O and IPC activity, demonstrating that an attacker can snatch events about their intrusion out of message buffers after they have occurred but before they are committed to the log, thus bypassing existing protections. We present a first step towards defending against our attack by introducing KennyLoggings, the first kernel- based tamper-evident logging system that satisfies the synchronous integrity property, meaning that it guarantees tamper-evidence of events upon their occurrence. We implement KennyLoggings on top of the Linux kernel and show that it imposes between 8% and 11% overhead on log-intensive application workloads.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "为了让系统日志有助于安全调查，它们必须在对手无法触及的地方。不幸的是，对主机拥有升级权限的攻击者通常能够随意删除和修改日志事件。为了应对这种威胁，近年来出现了各种安全日志记录系统，试图为系统日志提供防篡改(例如，一次写入多次读取的驱动器、远程存储服务器)或防篡改证据(例如，加密证据)。这些解决方案公开了一个接口，通过该接口事件被提交到一个安全的日志中，在这一点上，它们享有防止将来被篡改的保护。然而，迄今为止所有的建议都依赖于这样的假设，即事件的发生伴随着它对安全日志的承诺。在这项工作中，我们通过提出和验证对审计框架完整性的竞争条件攻击来挑战这一假设。我们的攻击利用了I/O和IPC活动固有的异步特性，表明攻击者可以在事件发生之后、提交到日志之前，从消息缓冲区中抓取有关其入侵的事件，从而绕过现有的保护。我们通过引入KennyLoggings向防御我们的攻击迈出了第一步，Kenny loggings是第一个满足同步完整性属性的基于内核的防篡改日志记录系统，这意味着它保证了事件发生时的防篡改证据。我们在Linux内核上实现了KennyLoggings，并表明它给日志密集型应用程序工作负载带来了8%到11%的开销。",
        "title_zh": "登录到危险区域:系统审计框架上的竞争条件攻击和防御",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2020.html",
        "conf_title": "27th CCS 2020: Virtual Event, USA",
        "conf_url": "https://doi.org/10.1145/3372297",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3372297.3417289",
        "title": "Speculative Probing: Hacking Blind in the Spectre Era",
        "authors": "Enes Göktas, Kaveh Razavi, Georgios Portokalidis, Herbert Bos, Cristiano Giuffrida",
        "abstract": "To defeat ASLR or more advanced fine-grained and leakage-resistant code randomization schemes, modern software exploits rely on information disclosure to locate gadgets inside the victim's code. In the absence of such info-leak vulnerabilities, attackers can still hack blind and derandomize the address space by repeatedly probing the victim's memory while observing crash side effects, but doing so is only feasible for crash-resistant programs. However, high-value targets such as the Linux kernel are not crash-resistant. Moreover, the anomalously large number of crashes is often easily detectable. In this paper, we show that the Spectre era enables an attacker armed with a single memory corruption vulnerability to hack blind without triggering any crashes. Using speculative execution for crash suppression allows the elevation of basic memory write vulnerabilities into powerful speculative probing primitives that leak through microarchitectural side effects. Such primitives can repeatedly probe victim memory and break strong randomization schemes without crashes and bypass all deployed mitigations against Spectre-like attacks. The key idea behind speculative probing is to break Spectre mitigations using memory corruption and resurrect Spectre-style disclosure primitives to mount practical blind software exploits. To showcase speculative probing, we target the Linux kernel, a crash-sensitive victim that has so far been out of reach of blind attacks, mount end-to-end exploits that compromise the system with just-in-time code reuse and data-only attacks from a single memory write vulnerability, and bypass strong Spectre and strong randomization defenses. Our results show that it is crucial to consider synergies between different (Spectre vs. code reuse) threat models to fully comprehend the attack surface of modern systems.",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3372297.3417289"
        },
        "abstract_zh": "为了击败ASLR或更先进的细粒度和抗泄漏的代码随机化方案，现代软件利用依赖于信息披露来定位受害者代码中的小工具。在没有这种信息泄漏漏洞的情况下，攻击者仍然可以通过重复探测受害者的内存，同时观察崩溃的副作用，来盲目地攻击和随机化地址空间，但这样做只对抗崩溃的程序可行。然而，像Linux内核这样的高价值目标并不具有抗崩溃性。此外，异常大量的崩溃往往很容易被发现。在本文中，我们展示了Spectre era使拥有单个内存损坏漏洞的攻击者能够在不触发任何崩溃的情况下进行盲目攻击。使用推测性执行来抑制崩溃允许将基本内存写入漏洞提升为通过微体系结构副作用泄漏的强大推测性探测原语。这种原语可以重复探测受害者的内存，在不崩溃的情况下打破强大的随机化方案，并绕过所有针对Spectre类攻击部署的缓解措施。推测性探测背后的关键思想是使用内存损坏来打破Spectre缓解，并复活Spectre风格的披露原语来安装实际的盲目软件利用。为了展示推测性探测，我们以Linux内核为目标，这是一个对崩溃敏感的受害者，迄今为止还没有受到盲目攻击，利用即时代码重用和来自单个内存写入漏洞的纯数据攻击来利用危及系统的端到端漏洞，并绕过强大的Spectre和强大的随机化防御。我们的结果表明，考虑不同(Spectre与代码重用)威胁模型之间的协同作用对于全面理解现代系统的攻击面至关重要。",
        "title_zh": "投机性探索:幽灵时代的黑客盲",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2020.html",
        "conf_title": "27th CCS 2020: Virtual Event, USA",
        "conf_url": "https://doi.org/10.1145/3372297",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3460120.3484753",
        "title": "ECMO: Peripheral Transplantation to Rehost Embedded Linux Kernels",
        "authors": "Muhui Jiang, Lin Ma, Yajin Zhou, Qiang Liu, Cen Zhang, Zhi Wang, Xiapu Luo, Lei Wu, Kui Ren",
        "abstract": "Dynamic analysis based on the full-system emulator QEMU is widely used for various purposes.However, it is challenging to run firmware images of embedded devices in QEMU, especially the process to boot the Linux kernel (we call this process rehosting the Linux kernel in this paper). That's because embedded devices usually use different system-on-chips (SoCs) from multiple vendors and only a limited number of SoCs are currently supported in QEMU. In this work, we propose a technique called peripheral transplantation. The main idea is to transplant the device drivers of designated peripherals into the Linux kernel binary. By doing so, it can replace the peripherals in the kernel that are currently unsupported in QEMU with supported ones, thus making the Linux kernel rehostable. After that, various applications can be built. We implemented this technique inside a prototype system called ECMO and applied it to 815 firmware images, which consist of 20 kernel versions and 37 device models. The result shows that ECMO can successfully transplant peripherals for all the 815 Linux kernels. Among them, 710 kernels can be successfully rehosted, i.e., launching a user-space shell (87.1% success rate). The failed cases are mainly because the root file system format (ramfs) is not supported by the kernel. Meanwhile, we are able to inject rather complex drivers (i.e., NIC driver) for all the rehosted Linux kernels by installing kernel modules. We further build three applications, i.e., kernel crash analysis, rootkit forensic analysis, and kernel fuzzing, based on the rehosted kernels to demonstrate the usage scenarios of ECMO.",
        "files": {
            "openAccessPdf": "http://arxiv.org/pdf/2105.14295"
        },
        "abstract_zh": "基于全系统仿真器QEMU的动态分析被广泛用于各种目的。然而，在QEMU中运行嵌入式设备的固件映像是具有挑战性的，尤其是引导Linux内核的过程(我们在本文中称这个过程为Linux内核的主机转移)。这是因为嵌入式设备通常使用来自多家供应商的不同片上系统(SOC ),而QEMU目前只支持有限数量的SOC。在这项工作中，我们提出了一种称为外周移植的技术。主要思想是将指定外设的设备驱动程序移植到Linux内核二进制文件中。通过这样做，它可以用受支持的外设替换内核中QEMU当前不支持的外设，从而使Linux内核变得可移植。之后，可以构建各种应用程序。我们在一个名为ECMO的原型系统中实现了这项技术，并将其应用于815个固件映像，其中包括20个内核版本和37个设备型号。结果表明，ECMO可以成功地移植所有815 Linux内核的外设。其中710个内核可以成功重托管，即启动一个用户空间shell (87.1%成功率)。失败的案例主要是因为内核不支持根文件系统格式(ramfs)。同时，通过安装内核模块，我们能够为所有重新托管的Linux内核注入相当复杂的驱动程序(即网卡驱动程序)。我们进一步基于重新托管的内核构建了内核崩溃分析、rootkit取证分析和内核模糊化三个应用来展示ECMO的使用场景。",
        "title_zh": "ECMO:移植外围设备来移植嵌入式Linux内核",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2021.html",
        "conf_title": "27th CCS 2021: Virtual Event, Korea",
        "conf_url": "https://doi.org/10.1145/3460120",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3460120.3484744",
        "title": "Demons in the Shared Kernel: Abstract Resource Attacks Against OS-level Virtualization",
        "authors": "Nanzi Yang, Wenbo Shen, Jinku Li, Yutian Yang, Kangjie Lu, Jietao Xiao, Tianyu Zhou, Chenggang Qin, Wang Yu, Jianfeng Ma, Kui Ren",
        "abstract": "Due to its faster start-up speed and better resource utilization efficiency, OS-level virtualization has been widely adopted and has become a fundamental technology in cloud computing. Compared to hardware virtualization, OS-level virtualization leverages the shared-kernel design to achieve high efficiency and runs multiple user-space instances (a.k.a., containers) on the shared kernel. However, in this paper, we reveal a new attack surface that is intrinsic to OS-level virtualization, affecting Linux, FreeBSD, and Fuchsia. The root cause is that the shared-kernel design in OS-level virtualization results containers in sharing thousands of kernel variables and data structures directly and indirectly. Without exploiting any kernel vulnerabilities, a non-privileged container can easily exhaust the shared kernel variables and data structure instances to cause DoS attacks against other containers. Compared with the physical resources, these kernel variables or data structure instances (termed abstract resources) are more prevalent but under-protected. To show the importance of confining abstract resources, we conduct abstract resource attacks that target different aspects of the OS kernel. The results show that attacking abstract resources is highly practical and critical. We further conduct a systematic analysis to identify vulnerable abstract resources in the Linux kernel, which successfully detects 1,010 abstract resources and 501 of them can be repeatedly consumed dynamically. We also conduct the attacking experiments in the self-deployed shared-kernel container environments on the top 4 cloud vendors. The results show that all environments are vulnerable to abstract resource attacks. We conclude that containing abstract resources is hard and give out multiple strategies for mitigating the risks.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "由于其更快的启动速度和更好的资源利用效率，操作系统级虚拟化已被广泛采用，并成为云计算中的一项基础技术。与硬件虚拟化相比，操作系统级虚拟化利用共享内核设计来实现高效率，并在共享内核上运行多个用户空间实例(也称为容器)。然而，在本文中，我们揭示了一种新的攻击面，它是操作系统级虚拟化固有的，影响Linux、FreeBSD和Fuchsia。根本原因是操作系统级虚拟化中的共享内核设计导致容器直接或间接地共享成千上万的内核变量和数据结构。在不利用任何内核漏洞的情况下，非特权容器可以很容易地耗尽共享的内核变量和数据结构实例，从而导致对其他容器的DoS攻击。与物理资源相比，这些内核变量或数据结构实例(称为抽象资源)更为普遍，但保护不足。为了说明限制抽象资源的重要性，我们进行了针对操作系统内核不同方面的抽象资源攻击。结果表明，攻击抽象资源具有很强的实用性和批判性。我们进一步进行了系统分析，以识别Linux内核中易受攻击的抽象资源，成功检测到1，010个抽象资源，其中501个可以重复动态消耗。我们还在四大云供应商的自部署共享内核容器环境中进行了攻击实验。结果表明，所有环境都容易受到抽象资源攻击。我们得出结论，包含抽象资源是困难的，并给出了减轻风险的多种策略。",
        "title_zh": "共享内核中的恶魔:针对操作系统级虚拟化的抽象资源攻击",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2021.html",
        "conf_title": "27th CCS 2021: Virtual Event, Korea",
        "conf_url": "https://doi.org/10.1145/3460120",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3460120.3484738",
        "title": "CPscan: Detecting Bugs Caused by Code Pruning in IoT Kernels",
        "authors": "Lirong Fu, Shouling Ji, Kangjie Lu, Peiyu Liu, Xuhong Zhang, Yuxuan Duan, Zihui Zhang, Wenzhi Chen, Yanjun Wu",
        "abstract": "To reduce the development costs, IoT vendors tend to construct IoT kernels by customizing the Linux kernel. Code pruning is common in this customization process. However, due to the intrinsic complexity of the Linux kernel and the lack of long-term effective maintenance, IoT vendors may mistakenly delete necessary security operations in the pruning process, which leads to various bugs such as memory leakage and NULL pointer dereference. Yet detecting bugs caused by code pruning in IoT kernels is difficult. Specifically, (1) a significant structural change makes precisely locating the deleted security operations (DSO ) difficult, and (2) inferring the security impact of a DSO is not trivial since it requires complex semantic understanding, including the developing logic and the context of the corresponding IoT kernel. In this paper, we present CPscan, a system for automatically detecting bugs caused by code pruning in IoT kernels. First, using a new graph-based approach that iteratively conducts a structure-aware basic block matching, CPscan can precisely and efficiently identify theDSOs in IoT kernels. Then, CPscan infers the security impact of a DSO by comparing the bounded use chains (where and how a variable is used within potentially influenced code segments) of the security-critical variable associated with it. Specifically, CPscan reports the deletion of a security operation as vulnerable if the bounded use chain of the associated security-critical variable remains the same before and after the deletion. This is because the unchanged uses of a security-critical variable likely need the security operation, and removing it may have security impacts. The experimental results on 28 IoT kernels from 10 popular IoT vendors show that CPscan is able to identify 3,193DSO s and detect 114 new bugs with a reasonably low false-positive rate. Many such bugs tend to have a long latent period (up to 9 years and 5 months). We believe CPscan paves a way for eliminating the bugs introduced by code pruning in IoT kernels. We will open-source CPscan to facilitate further research.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "为了降低开发成本，物联网供应商倾向于通过定制Linux内核来构建物联网内核。代码修剪在这个定制过程中很常见。然而，由于Linux内核固有的复杂性以及缺乏长期有效的维护，物联网厂商在剪枝过程中可能会错误地删除必要的安全操作，从而导致内存泄漏、空指针解引用等各种bug。然而，检测物联网内核中由代码修剪引起的错误很困难。具体来说，(1)显著的结构变化使得精确定位被删除的安全操作(DSO)变得困难，以及(2)推断DSO的安全影响并不简单，因为它需要复杂的语义理解，包括相应物联网内核的开发逻辑和上下文。在本文中，我们介绍了CPscan，这是一个自动检测物联网内核中由代码修剪引起的错误的系统。首先，使用一种新的基于图形的方法，迭代地进行结构感知的基本块匹配，CPscan可以精确有效地识别物联网内核中的so。然后，CPscan通过比较与DSO相关的安全关键变量的有界使用链(在潜在受影响的代码段中使用变量的位置和方式)来推断DSO的安全影响。具体来说，如果相关联的安全关键变量的有界使用链在删除前后保持不变，则CPscan将安全操作的删除报告为易受攻击。这是因为安全关键变量的不变使用可能需要安全操作，移除它可能会有安全影响。在来自10个流行物联网供应商的28个物联网内核上的实验结果表明，CPscan能够识别3193个SO，并以合理的低误报率检测到114个新错误。很多这样的bug往往潜伏期很长(长达9年零5个月)。我们相信CPscan为消除物联网内核中由代码修剪引入的错误铺平了道路。我们将开源CPscan以促进进一步的研究。",
        "title_zh": "cpscan:检测物联网内核中运行的代码导致的错误",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2021.html",
        "conf_title": "27th CCS 2021: Virtual Event, Korea",
        "conf_url": "https://doi.org/10.1145/3460120",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3460120.3484798",
        "title": "Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels",
        "authors": "Hang Zhang, Weiteng Chen, Yu Hao, Guoren Li, Yizhuo Zhai, Xiaochen Zou, Zhiyun Qian",
        "abstract": "Static analysis is known to yield numerous false alarms when used in bug finding, especially for complex vulnerabilities in large code bases like the Linux kernel. One important class of such complex vulnerabilities is what we call \"high-order taint style vulnerability\", where the taint flow from the user input to the vulnerable site crosses the boundary of a single entry function invocation (i.e., syscall). Due to the large scope and high precision requirement, few have attempted to solve the problem. In this paper, we present SUTURE, a highly precise and scalable static analysis tool capable of discovering high-order vulnerabilities in OS kernels. SUTURE employs a novel summary-based high-order taint flow construction approach to efficiently enumerate the cross-entry taint flows, while incorporating multiple innovative enhancements on analysis precision that are unseen in existing tools, resulting in a highly precise inter-procedural flow-, context-, field-, index-, and opportunistically path-sensitive static taint analysis. We apply SUTURE to discover high-order taint vulnerabilities in multiple Android kernels from mainstream vendors (e.g., Google, Samsung, Huawei), the results show that SUTURE can both confirm known high-order vulnerabilities and uncover new ones. So far, SUTURE generates 79 true positive warning groups, of which 19 have been confirmed by the vendors, including a high severity vulnerability rated by Google. SUTURE also achieves a reasonable false positive rate (51.23%) perceived by users of our tool.",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3460120.3484798"
        },
        "abstract_zh": "众所周知，静态分析在用于bug查找时会产生大量错误警报，尤其是对于像Linux内核这样的大型代码库中的复杂漏洞。这种复杂漏洞的一个重要类别是我们所谓的“高阶污点风格漏洞”，其中从用户输入到易受攻击站点的污点流跨越了单入口函数调用(即syscall)的边界。由于大范围和高精度的要求，很少有人试图解决这个问题。在本文中，我们介绍了缝合，一个高度精确和可扩展的静态分析工具，能够发现操作系统内核中的高阶漏洞。缝合采用了一种新的基于摘要的高阶污染流构建方法来有效地枚举交叉条目污染流，同时结合了现有工具中未见过的多种创新的分析精度增强，从而实现了高度精确的过程间流、上下文、字段、索引和机会路径敏感的静态污染分析。我们应用缝合线发现了主流厂商(如谷歌、三星、华为)的多个Android内核中的高阶污点漏洞，结果表明缝合线既能确认已知的高阶漏洞，又能发现新的高阶漏洞。到目前为止，缝合生成了79个真正的正面警告组，其中19个已被供应商确认，包括一个由谷歌评级的高严重性漏洞。缝合还实现了一个合理的假阳性率(51.23%)，由我们的工具的用户感知。",
        "title_zh": "静态发现操作系统内核中的高阶污点式漏洞",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2021.html",
        "conf_title": "27th CCS 2021: Virtual Event, Korea",
        "conf_url": "https://doi.org/10.1145/3460120",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3460120.3485373",
        "title": "Detecting Missed Security Operations Through Differential Checking of Object-based Similar Paths",
        "authors": "Dinghao Liu, Qiushi Wu, Shouling Ji, Kangjie Lu, Zhenguang Liu, Jianhai Chen, Qinming He",
        "abstract": "Missing a security operation such as a bound check has been a major cause of security-critical bugs. Automatically checking whether the code misses a security operation in large programs is challenging since it has to understand whether the security operation is indeed necessary in the context. Recent methods typically employ cross-checking to identify deviations as security bugs, which collects functionally similar program slices and infers missed security operations through majority-voting. An inherent limitation of such approaches is that they heavily rely on a substantial number of similar code pieces to enable cross-checking. In practice, many code pieces are unique, and thus we may be unable to find adequate similar code snippets to utilize cross-checking. In this paper, we present IPPO (Inconsistent Path Pairs as a bug Oracle), a static analysis framework for detecting security bugs based on differential checking. IPPO defines several novel rules to identify code paths that share similar semantics with respect to an object, and collects them as similar-path pairs. It then investigates the path pairs for identifying inconsistent security operations with respect to the object. If one path in a path pair enforces a security operation while the other does not, IPPO reports it as a potential security bug. By utilizing on object-based path-similarity analysis, IPPO achieves a higher precision, compared to conventional code-similarity analysis methods. Through differential checking of a similar-path pair, IPPO eliminates the requirement of constructing a large number of similar code pieces, addressing the limitation of traditional cross-checking approaches. We implemented IPPO and extensively evaluated it on four widely used open-source programs: Linux kernel, OpenSSL library, FreeBSD kernel, and PHP. IPPO found 154, 5, 1, and 1 new security bugs in the above systems, respectively. We have submitted patches for all these bugs, and 136 of them have been accepted by corresponding maintainers. The results confirm the effectiveness and usefulness of IPPO in practice.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "遗漏诸如边界检查之类的安全操作是安全关键错误的主要原因。自动检查代码是否遗漏了大型程序中的安全操作是具有挑战性的，因为它必须了解安全操作在上下文中是否确实是必要的。最近的方法通常采用交叉检查来识别作为安全缺陷的偏差，其收集功能相似的程序片段，并通过多数表决来推断遗漏的安全操作。这种方法的一个固有限制是，它们严重依赖大量相似的代码段来实现交叉检查。实际上，许多代码片段都是独特的，因此我们可能无法找到足够的相似代码片段来利用交叉检查。在本文中，我们提出了IPPO(不一致路径对作为漏洞预言)，一个静态分析框架，用于检测基于差异检查的安全漏洞。IPPO定义了几个新颖的规则来识别代码路径，这些代码路径相对于一个对象共享相似的语义，并将它们收集为相似路径对。然后，它调查路径对以识别关于该对象的不一致的安全操作。如果路径对中的一条路径实施了安全操作，而另一条没有，IPPO会将其报告为潜在的安全漏洞。与传统的代码相似性分析方法相比，通过利用基于对象的路径相似性分析，IPPO获得了更高的精度。通过相似路径对的差分检查，IPPO消除了构造大量相似代码段的需求，解决了传统交叉检查方法的局限性。我们实现了IPPO，并在四个广泛使用的开源程序上对其进行了广泛的评估:Linux内核、OpenSSL库、FreeBSD内核和PHP。IPPO在上述系统中分别发现了154个、5个、1个和1个新的安全漏洞。我们已经提交了所有这些bug的补丁，其中136个已经被相应的维护者接受。结果证实了IPPO在实践中的有效性和实用性。",
        "title_zh": "通过基于对象的相似路径的差异检查来检测遗漏的安全操作",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2021.html",
        "conf_title": "27th CCS 2021: Virtual Event, Korea",
        "conf_url": "https://doi.org/10.1145/3460120",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3548606.3559366",
        "title": "C2C: Fine-grained Configuration-driven System Call Filtering",
        "authors": "Seyedhamed Ghavamnia, Tapti Palit, Michalis Polychronakis",
        "abstract": "Configuration options allow users to customize application features according to the desired requirements. While the code that corresponds to disabled features is never executed, it still resides in process memory and comprises part of the application's attack surface, e.g., it can be reused for the construction of exploit code. Automatically reducing the attack surface of disabled application features according to a given configuration is thus a desirable defense-in-depth capability. The intricacies of modern software design and the complexities of popular programming languages, however, introduce significant challenges in automatically deriving the mapping of configuration options to their corresponding application code. In this paper, we present Configuration-to-Code (C2C), a generic configuration-driven attack surface reduction technique that automatically maps configuration options to application code using static code analysis and instrumentation. C2C operates at a fine-grained level by pruning configuration-dependent conditional branches in the control flow graph, allowing the precise identification of a given configuration option's code at the basic block level. At runtime, C2C reduces the application's attack surface by filtering any system calls required exclusively by disabled features. Using popular applications, we show how security-critical system calls (such as execve) can be automatically disabled when not needed, limiting an attacker's vulnerability exploitation capabilities. System call filtering also reduces the exposed attack surface of the underlying Linux kernel, neutralizing 32 additional CVEs (for a total of 88) compared to previous software specialization techniques.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "配置选项允许用户根据所需需求定制应用程序功能。虽然对应于被禁用特征的代码从不被执行，但是它仍然驻留在进程存储器中，并且包括应用程序的攻击面的一部分，例如，它可以被重新用于构造利用代码。因此，根据给定的配置自动减少被禁用的应用程序功能的攻击面是一种理想的纵深防御能力。然而，现代软件设计的复杂性和流行编程语言的复杂性在自动导出配置选项到它们对应的应用代码的映射方面引入了重大挑战。在本文中，我们介绍了配置到代码(C2C)，这是一种通用的配置驱动的攻击面减少技术，它使用静态代码分析和工具自动将配置选项映射到应用程序代码。C2C通过修剪控制流图中依赖于配置的条件分支在细粒度级别运行，允许在基本块级别精确识别给定配置选项的代码。在运行时，C2C通过过滤被禁用的特性所独有的任何系统调用来减少应用的攻击面。通过使用流行的应用程序，我们展示了如何在不需要时自动禁用安全关键系统调用(如execve ),从而限制攻击者的漏洞利用能力。系统调用过滤还减少了底层Linux内核暴露的攻击面，与以前的软件专门化技术相比，抵消了32个额外的CVE(总共88个)。",
        "title_zh": "C2C:细粒度配置驱动的系统调用过滤",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2022.html",
        "conf_title": "28th CCS 2022: Los Angeles, CA, USA",
        "conf_url": "https://doi.org/10.1145/3548606",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3548606.3560585",
        "title": "DirtyCred: Escalating Privilege in Linux Kernel",
        "authors": "Zhenpeng Lin, Yuhang Wu, Xinyu Xing",
        "abstract": "The kernel vulnerability DirtyPipe was reported to be present in nearly all versions of Linux since 5.8. Using this vulnerability, a bad actor could fulfill privilege escalation without triggering existing kernel protection and exploit mitigation, making this vulnerability particularly disconcerting. However, the success of DirtyPipe exploitation heavily relies on this vulnerability's capability (i.e., injecting data into the arbitrary file through Linux's pipes). Such an ability is rarely seen for other kernel vulnerabilities, making the defense relatively easy. As long as Linux users eliminate the vulnerability, the system could be relatively secure. This work proposes a new exploitation method -- DirtyCred -- pushing other Linux kernel vulnerabilities to the level of DirtyPipe. Technically speaking, given a Linux kernel vulnerability, our exploitation method swaps unprivileged and privileged kernel credentials and thus provides the vulnerability with the DirtyPipe-like exploitability. With this exploitability, a bad actor could obtain the ability to escalate privilege and even escape the container. We evaluated this exploitation approach on 24 real-world kernel vulnerabilities in a fully-protected Linux system. We discovered that DirtyCred could demonstrate exploitability on 16 vulnerabilities, implying DirtyCred's security severity. Following the exploitability assessment, this work further proposes a new kernel defense mechanism. Unlike existing Linux kernel defenses, our new defense isolates kernel credential objects on non-overlapping memory regions based on their own privilege. Our experiment result shows that the new defense introduces primarily negligible overhead.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "据报道，内核漏洞DirtyPipe存在于自5.8以来的几乎所有Linux版本中。利用此漏洞，坏人可以在不触发现有内核保护和漏洞缓解的情况下实现权限提升，这使得此漏洞特别令人不安。但是，成功利用DirtyPipe在很大程度上依赖于此漏洞的能力(即通过Linux的管道将数据注入任意文件)。这种能力在其他内核漏洞中很少见，使得防御相对容易。只要Linux用户消除了这个漏洞，系统就可能相对安全。这项工作提出了一种新的利用方法——dirty cred——将其他Linux内核漏洞推到DirtyPipe级别。从技术上讲，给定一个Linux内核漏洞，我们的利用方法交换非特权和特权内核凭证，从而为漏洞提供类似DirtyPipe的可利用性。利用这种可利用性，不良行为者可以获得提升权限甚至逃离容器的能力。我们在一个完全受保护的Linux系统中的24个真实内核漏洞上评估了这种利用方法。我们发现DirtyCred可以利用16个漏洞，这暗示了DirtyCred的安全严重性。继可利用性评估之后，本文进一步提出了一种新的内核防御机制。与现有的Linux内核防御不同，我们的新防御基于内核凭证对象自己的特权将它们隔离在不重叠的内存区域上。我们的实验结果表明，新的防御引入的开销基本上可以忽略不计。",
        "title_zh": "DirtyCred:在Linux内核中提升权限",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2022.html",
        "conf_title": "28th CCS 2022: Los Angeles, CA, USA",
        "conf_url": "https://doi.org/10.1145/3548606",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3548606.3559373",
        "title": "Proving UNSAT in Zero Knowledge",
        "authors": "Ning Luo, Timos Antonopoulos, William R. Harris, Ruzica Piskac, Eran Tromer, Xiao Wang",
        "abstract": "Zero-knowledge (ZK) protocols enable one party to prove to others that it knows a fact without revealing any information about the evidence for such knowledge. There exist ZK protocols for all problems in NP, and recent works developed highly efficient protocols for proving knowledge of satisfying assignments to Boolean formulas, circuits and other NP formalisms. This work shows an efficient protocol for the converse: proving formula unsatisfiability in ZK (when the prover posses a non-ZK proof). An immediate practical application is efficiently proving safety of secret programs. The key insight is to prove, in ZK, the validity of resolution proofs of unsatisfiability. This is efficiently realized using an algebraic representation that exploits resolution proofs' structure to represent formula clauses as low-degree polynomials, combined with ZK random-access arguments. Only the proof's dimensions are revealed. We implemented our protocol and used it to prove unsatisfiability of formulas that encode combinatoric problems and program correctness conditions in standard verification benchmarks, including Linux kernel drivers and Intel cryptography modules. The results demonstrate both that our protocol has practical utility, and that its aggressive optimizations, based on non-trivial encodings, significantly improve practical performance.",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3548606.3559373"
        },
        "abstract_zh": "零知识(ZK)协议使一方能够向其他方证明它知道一个事实，而不需要透露任何关于这种知识的证据的信息。NP中的所有问题都存在ZK协议，最近的工作开发了高效的协议来证明布尔公式、电路和其他NP形式的满足赋值的知识。这项工作给出了一个有效的逆协议:在ZK证明公式不可满足性(当证明者拥有非ZK证明时)。一个直接的实际应用是有效地证明秘密程序的安全性。关键的洞见是证明，在ZK，不可满足性的决议证明的有效性。这可以通过使用代数表示来有效地实现，该代数表示利用解析证明的结构来将公式子句表示为低次多项式，并结合ZK随机访问自变量。只显示了证据的维度。我们实现了我们的协议，并使用它来证明标准验证基准(包括Linux内核驱动程序和英特尔密码模块)中编码组合问题和程序正确性条件的公式的不可满足性。结果表明，我们的协议具有实际效用，并且其基于非平凡编码的积极优化显著提高了实际性能。",
        "title_zh": "零知识证明不满足",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2022.html",
        "conf_title": "28th CCS 2022: Los Angeles, CA, USA",
        "conf_url": "https://doi.org/10.1145/3548606",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3548606.3560568",
        "title": "NeVerMore: Exploiting RDMA Mistakes in NVMe-oF Storage Applications",
        "authors": "Konstantin Taranov, Benjamin Rothenberger, Daniele De Sensi, Adrian Perrig, Torsten Hoefler",
        "abstract": "This paper presents a security analysis of the InfiniBand architecture, a prevalent RDMA standard, and NVMe-over-Fabrics (NVMe-oF), a prominent protocol for industrial disaggregated storage that exploits RDMA protocols to achieve low-latency and high-bandwidth access to remote solid-state devices. Our work, NeVerMore, discovers new vulnerabilities in RDMA protocols that unveils several attack vectors on RDMA-enabled applications and the NVMe-oF protocol, showing that the current security mechanisms of the NVMe-oF protocol do not address the security vulnerabilities posed by the use of RDMA. In particular, we show how an unprivileged user can inject packets into any RDMA connection created on a local network controller, bypassing security mechanisms of the operating system and its kernel, and how the injection can be used to acquire unauthorized block access to NVMe-oF devices. Overall, we implement four attacks on RDMA protocols and seven attacks on the NVMe-oF protocol and verify them on the two most popular implementations of NVMe-oF: SPDK and the Linux kernel. To mitigate the discovered attacks we propose multiple mechanisms that can be implemented by RDMA and NVMe-oF providers.",
        "files": {
            "openAccessPdf": "https://zenodo.org/record/7361587/files/3548606.3560568_Nevermore.pdf"
        },
        "abstract_zh": "本文介绍了对InfiniBand架构(一种流行的RDMA标准)和NVMe(NVMe-oF)的安全性分析，后者是一种用于工业分类存储的著名协议，利用RDMA协议实现对远程固态设备的低延迟和高带宽访问。我们的工作NeVerMore在RDMA协议中发现了新的漏洞，揭示了对支持RDMA的应用程序和NVMe-oF协议的几个攻击媒介，表明NVMe-oF协议的当前安全机制没有解决使用RDMA带来的安全漏洞。特别是，我们展示了未经授权的用户如何将数据包注入在本地网络控制器上创建的任何RDMA连接，绕过操作系统及其内核的安全机制，以及这种注入如何被用来阻止对NVMe设备的未经授权的访问。总的来说，我们实现了对RDMA协议的四次攻击和对NVMe协议的七次攻击，并在NVMe协议的两个最流行的实现上验证了它们:SPDK和Linux内核。为了减轻已发现的攻击，我们提出了多种可以由RDMA和NVMe实现的机制。",
        "title_zh": "永不复返:利用NVMe存储应用中的RDMA错误",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2022.html",
        "conf_title": "28th CCS 2022: Los Angeles, CA, USA",
        "conf_url": "https://doi.org/10.1145/3548606",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3338507.3358615",
        "title": "Protecting Actuators in Safety-Critical IoT Systems from Control Spoofing Attacks",
        "authors": "Monowar Hasan, Sibin Mohan",
        "abstract": "In this paper, we propose a framework called Contego-TEE to secure Internet-of-Things (IoT) edge devices with timing requirements from control spoofing attacks where an adversary sends malicious control signals to the actuators. We use a trusted computing base available in commodity processors (such as ARM TrustZone) and propose an invariant checking mechanism to ensure the security and safety of the physical system. A working prototype of Contego-TEE was developed using embedded Linux kernel. We demonstrate the feasibility of our approach for a robotic vehicle running on an ARM-based platform.",
        "files": {
            "openAccessPdf": "http://arxiv.org/pdf/1908.09444"
        },
        "abstract_zh": "在本文中，我们提出了一个名为Contego-TEE的框架，以保护具有时序要求的物联网边缘设备免受控制欺骗攻击，其中对手向执行器发送恶意控制信号。我们使用商用处理器(如ARM TrustZone)中可用的可信计算基础，并提出一种不变量检查机制来确保物理系统的安全性。使用嵌入式Linux内核开发了Contego-TEE的工作原型。我们为运行在基于ARM的平台上的机器人车辆演示了我们的方法的可行性。",
        "title_zh": "保护安全关键物联网系统中的执行器免受控制欺骗攻击",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/iotsp2019.html",
        "conf_title": "IoT S&P@CCS 2019: London, UK",
        "conf_url": "https://doi.org/10.1145/3338507",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3319535.3363212",
        "title": "SLAKE: Facilitating Slab Manipulation for Exploiting Vulnerabilities in the Linux Kernel",
        "authors": "Yueqi Chen, Xinyu Xing",
        "abstract": "To determine the exploitability for a kernel vulnerability, a secu- rity analyst usually has to manipulate slab and thus demonstrate the capability of obtaining the control over a program counter or performing privilege escalation. However, this is a lengthy process because (1) an analyst typically has no clue about what objects and system calls are useful for kernel exploitation and (2) he lacks the knowledge of manipulating a slab and obtaining the desired layout. In the past, researchers have proposed various techniques to facilitate exploit development. Unfortunately, none of them can be easily applied to address these challenges. On the one hand, this is because of the complexity of the Linux kernel. On the other hand, this is due to the dynamics and non-deterministic of slab variations. In this work, we tackle the challenges above from two perspectives. First, we use static and dynamic analysis techniques to explore the kernel objects, and the corresponding system calls useful for exploitation. Second, we model commonly-adopted exploitation methods and develop a technical approach to facilitate the slab layout adjustment. By extending LLVM as well as Syzkaller, we implement our techniques and name their combination after SLAKE. We evaluate SLAKE by using 27 real-world kernel vulnerabilities, demonstrating that it could not only diversify the ways to perform kernel exploitation but also sometimes escalate the exploitability of kernel vulnerabilities.",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3319535.3363212"
        },
        "abstract_zh": "为了确定内核漏洞的可利用性，安全分析师通常必须操作slab，从而证明获得对程序计数器的控制或执行权限提升的能力。然而，这是一个漫长的过程，因为(1)分析师通常不知道什么对象和系统调用对内核开发有用，以及(2)他缺乏操纵板和获得所需布局的知识。过去，研究人员提出了各种技术来促进漏洞利用开发。不幸的是，没有一种方法可以轻松地解决这些挑战。一方面，这是因为Linux内核的复杂性。另一方面，这是由于板坯变化的动态性和不确定性。在这项工作中，我们从两个角度应对上述挑战。首先，我们使用静态和动态分析技术来探索内核对象，以及相应的对开发有用的系统调用。第二，我们对常用的开发方法进行建模，并开发一种技术方法来促进板布局调整。通过扩展LLVM和Syzkaller，我们实现了我们的技术，并以SLAKE命名它们的组合。我们通过使用27个真实世界的内核漏洞来评估SLAKE，证明它不仅可以多样化执行内核利用的方式，而且有时会提升内核漏洞的可利用性。",
        "title_zh": "SLAKE:为利用Linux内核中的漏洞提供便利",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2019.html",
        "conf_title": "26th CCS 2019: London, UK",
        "conf_url": "https://doi.org/10.1145/3319535",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3319535.3354244",
        "title": "Where Does It Go?: Refining Indirect-Call Targets with Multi-Layer Type Analysis",
        "authors": "Kangjie Lu, Hong Hu",
        "abstract": "System software commonly uses indirect calls to realize dynamic program behaviors. However, indirect-calls also bring challenges to constructing a precise control-flow graph that is a standard pre-requisite for many static program-analysis and system-hardening techniques. Unfortunately, identifying indirect-call targets is a hard problem. In particular, modern compilers do not recognize indirect-call targets by default. Existing approaches identify indirect-call targets based on type analysis that matches the types of function pointers and the ones of address-taken functions. Such approaches, however, suffer from a high false-positive rate as many irrelevant functions may share the same types. In this paper, we propose a new approach, namely Multi-Layer Type Analysis (MLTA), to effectively refine indirect-call targets for C/C++ programs. MLTA relies on an observation that function pointers are commonly stored into objects whose types have a multi-layer type hierarchy; before indirect calls, function pointers will be loaded from objects with the same type hierarchy \"layer by layer\". By matching the multi-layer types of function pointers and functions, MLTA can dramatically refine indirect-call targets. MLTA is effective because multi-layer types are more restrictive than single-layer types. It does not introduce false negatives by conservatively tracking targets propagation between multi-layer types, and the layered design allows MLTA to safely fall back whenever the analysis for a layer becomes infeasible. We have implemented MLTA in a system, namely TypeDive, based on LLVM and extensively evaluated it with the Linux kernel, the FreeBSD kernel, and the Firefox browser. Evaluation results show that TypeDive can eliminate 86% to 98% more indirect-call targets than existing approaches do, without introducing new false negatives. We also demonstrate that TypeDive not only improves the scalability of static analysis but also benefits semantic-bug detection. With TypeDive, we have found 35 new deep semantic bugs in the Linux kernel.",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3319535.3354244"
        },
        "abstract_zh": "系统软件通常使用间接调用来实现动态程序行为。然而，间接调用也给构建精确的控制流图带来了挑战，这是许多静态程序分析和系统加固技术的标准先决条件。不幸的是，识别间接调用目标是一个难题。特别是，现代编译器默认不识别间接调用目标。现有方法基于匹配函数指针类型和地址获取函数类型的类型分析来识别间接调用目标。然而，这种方法有很高的假阳性率，因为许多不相关的函数可能共享相同的类型。在本文中，我们提出了一种新的方法，即多层类型分析(MLTA ),以有效地细化C/C++程序的间接调用目标。MLTA依赖于一种观察，即函数指针通常存储在具有多层类型层次结构的对象中；在间接调用之前，函数指针会从具有相同类型层次结构的对象中“逐层”加载。通过匹配多层类型的函数指针和函数，MLTA可以极大地细化间接调用目标。MLTA是有效的，因为多层类型比单层类型更具限制性。它不会通过保守地跟踪多层类型之间的目标传播而引入假阴性，并且分层设计允许MLTA在层的分析变得不可行时安全地回退。我们已经在基于LLVM的系统TypeDive中实现了MLTA，并使用Linux内核、FreeBSD内核和Firefox浏览器对其进行了广泛的评估。评估结果表明，TypeDive可以比现有方法多消除86%到98%的间接调用目标，而不会引入新的假阴性。我们还证明了TypeDive不仅提高了静态分析的可伸缩性，而且有利于语义错误检测。通过TypeDive，我们在Linux内核中发现了35个新的深层语义错误。",
        "title_zh": "它通向哪里？:使用多层类型分析细化间接呼叫目标",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2019.html",
        "conf_title": "26th CCS 2019: London, UK",
        "conf_url": "https://doi.org/10.1145/3319535",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3133956.3134085",
        "title": "SemFuzz: Semantics-based Automatic Generation of Proof-of-Concept Exploits",
        "authors": "Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang, Xiaojing Liao, Pan Bian, Bin Liang",
        "abstract": "Patches and related information about software vulnerabilities are often made available to the public, aiming to facilitate timely fixes. Unfortunately, the slow paces of system updates (30 days on average) often present to the attackers enough time to recover hidden bugs for attacking the unpatched systems. Making things worse is the potential to automatically generate exploits on input-validation flaws through reverse-engineering patches, even though such vulnerabilities are relatively rare (e.g., 5% among all Linux kernel vulnerabilities in last few years). Less understood, however, are the implications of other bug-related information (e.g., bug descriptions in CVE), particularly whether utilization of such information can facilitate exploit generation, even on other vulnerability types that have never been automatically attacked. In this paper, we seek to use such information to generate proof-of-concept (PoC) exploits for the vulnerability types never automatically attacked. Unlike an input validation flaw that is often patched by adding missing sanitization checks, fixing other vulnerability types is more complicated, usually involving replacement of the whole chunk of code. Without understanding of the code changed, automatic exploit becomes less likely. To address this challenge, we present SemFuzz, a novel technique leveraging vulnerability-related text (e.g., CVE reports and Linux git logs) to guide automatic generation of PoC exploits. Such an end-to-end approach is made possible by natural-language processing (NLP) based information extraction and a semantics-based fuzzing process guided by such information. Running over 112 Linux kernel flaws reported in the past five years, SemFuzz successfully triggered 18 of them, and further discovered one zero-day and one undisclosed vulnerabilities. These flaws include use-after-free, memory corruption, information leak, etc., indicating that more complicated flaws can also be automatically attacked. This finding calls into question the way vulnerability-related information is shared today.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "有关软件漏洞的补丁和相关信息通常可公开提供，旨在促进及时修复。 不幸的是，系统更新的缓慢速度（平均为30天）通常向攻击者出现足够的时间，以恢复隐藏的错误以攻击未解决的系统。 使情况变得更糟的是，即使这种漏洞相对较少，也可以通过反向工程贴片自动生成输入验证缺陷的利用（例如，过去几年中所有Linux内核漏洞中的5％）。 然而，不太了解的是其他与错误相关信息的含义（例如，CVE中的错误描述），尤其是对此类信息的利用是否可以促进利用生成，即使在从未自动攻击过的其他漏洞类型上也是如此。 在本文中，我们试图使用此类信息来生成概念证明（POC）利用从未自动攻击的漏洞类型。 与通常通过添加缺失的消毒检查来修补的输入验证缺陷不同，修复其他漏洞类型更为复杂，通常涉及更换整个代码的整个块。 在不了解代码更改的情况下，自动利用的可能性较小。 为了应对这一挑战，我们提出了Semfuzz，这是一种利用与脆弱性相关的文本（例如CVE报告和Linux GIT日志）的新技术，以指导自动生成POC漏洞利用。 通过自然语言处理（NLP）的信息提取和以这些信息为指导的基于语义的模糊过程，这种端到端方法可以通过自然语言处理（NLP）进行。 在过去的五年中，Semfuzz在报道的112个Linux内核缺陷中成功触发了其中的18个，并进一步发现了一个零日和一个未公开的漏洞。 这些缺陷包括无用后，内存损坏，信息泄漏等，表明也可以自动攻击更复杂的缺陷。 这一发现引起了质疑，今天共享与脆弱性相关的信息的方式。",
        "title_zh": "SemFuzz:基于语义的概念证明漏洞自动生成",
        "year": "2017",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2017.html",
        "conf_title": "24th CCS 2017: Dallas, TX, USA",
        "conf_url": "https://doi.org/10.1145/3133956",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3243734.3243844",
        "title": "Check It Again: Detecting Lacking-Recheck Bugs in OS Kernels",
        "authors": "Wenwen Wang, Kangjie Lu, Pen-Chung Yew",
        "abstract": "Operating system kernels carry a large number of security checks to validate security-sensitive variables and operations. For example, a security check should be embedded in a code to ensure that a user-supplied pointer does not point to the kernel space. Using security-checked variables is typically safe. However, in reality, security-checked variables are often subject to modification after the check. If a recheck is lacking after a modification, security issues may arise, e.g., adversaries can control the checked variable to launch critical attacks such as out-of-bound memory access or privilege escalation. We call such cases lacking-recheck (LRC) bugs, a subclass of TOCTTOU bugs, which have not been explored yet. In this paper, we present the first in-depth study of LRC bugs and develop LRSan, a static analysis system that systematically detects LRC bugs in OS kernels. Using an inter-procedural analysis and multiple new techniques, LRSan first automatically identifies security checks, critical variables, and uses of the checked variables, and then reasons about whether a modification is present after a security check. A case in which a modification is present but a recheck is lacking is an LRC bug. We apply LRSan to the latest Linux kernel and evaluate the effectiveness of LRSan. LRSan reports thousands of potential LRC cases, and we have confirmed 19 new LRC bugs. We also discuss patching strategies of LRC bugs based on our study and bug-fixing experience.",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3243734.3243844"
        },
        "abstract_zh": "操作系统内核携带大量的安全检查以验证对安全敏感的变量和操作。 例如，应将安全检查嵌入代码中，以确保用户提供的指针不能指向内核空间。 使用安全检查的变量通常是安全的。 但是，实际上，安全检查的变量通常会在检查后进行修改。 如果修改后缺少重新检查，则可能会出现安全问题，例如，对手可以控制检查变量以启动关键攻击，例如内存外内存访问或特权升级。 我们称此类案例缺乏核电（LRC）错误，这是一个尚未探索的Tocttou Bugs的子类。 在本文中，我们介绍了LRC错误的首次深入研究，并开发了LRSAN，这是一种静态分析系统，该系统系统地检测到OS内核中的LRC错误。 LRSAN使用术间分析和多种新技术，首先自动识别安全检查，关键变量和检查变量的使用，然后在安全检查后是否存在修改。 存在修改但缺乏重新检查的情况是LRC错误。 我们将LRSAN应用于最新的Linux内核，并评估LRSAN的有效性。 LRSA报告报告了数千例潜在的LRC病例，我们已经确认了19个新的LRC错误。 我们还根据我们的研究和固定经验讨论LRC错误的修补策略。",
        "title_zh": "再次检查:检测操作系统内核中的缺陷",
        "year": "2018",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2018.html",
        "conf_title": "25th CCS 2018: Toronto, ON, Canada",
        "conf_url": "http://dl.acm.org/citation.cfm?id=3243734",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "http://dl.acm.org/citation.cfm?id=2995960",
        "title": "Studying Naive Users and the Insider Threat with SimpleFlow",
        "authors": "Ryan V. Johnson, Jessie Lass, W. Michael Petullo",
        "abstract": "Most access control systems prohibit illicit actions at the moment they seem to violate a security policy. While effective, such early action often clouds insight into the intentions behind negligent or willful security policy violations. Furthermore, existing control mechanisms are often very low-level; this hinders understanding because controls must be spread throughout a system. We propose SimpleFlow, a simple, information-flow-based access control system which allows illicit actions to occur up until sensitive information would have left the local network. SimpleFlow marks such illicit traffic before transmission, and this allows network devices to filter such traffic in a number of ways. SimpleFlow can also spoof intended recipients to trick malware into revealing application-layer communication messages even while blocking them. We have written SimpleFlow as a modification to the Linux kernel, and we have released our work as open source.",
        "files": {
            "openAccessPdf": "http://dl.acm.org/ft_gateway.cfm?id=2995960&type=pdf"
        },
        "abstract_zh": "大多数访问控制系统都禁止非法行动违反安全政策。 尽管有效，但这种早期行动常常使人们深入了解违反疏忽或故意的安全政策背后的意图。 此外，现有的控制机制通常是非常低级的。 这会阻碍理解，因为必须在整个系统中传播控制。 我们建议SimpleFlow，这是一个简单，基于信息流的访问控制系统，可以进行非法操作，直到敏感信息离开本地网络为止。 SimpleFlow在传输前标记了这种非法流量，这允许网络设备以多种方式过滤此类流量。 SimpleFlow还可以欺骗预期的收件人，即使在阻止它们时，也可以欺骗恶意软件来揭示应用程序层的通信消息。 我们已经为Linux内核编写了SimpleFlow作为修改，并且已经发布了作为开源的作品。",
        "title_zh": "用SimpleFlow研究幼稚用户和内部威胁",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/mist2016.html",
        "conf_title": "8th MIST@CCS 2016: Vienna, Austria",
        "conf_url": "https://doi.org/10.1145/2995959",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "http://dl.acm.org/citation.cfm?id=2995968",
        "title": "WatchIT: Who Watches Your IT Guy?",
        "authors": "Noam Shalev, Idit Keidar, Yosef Moatti, Yaron Weinsberg",
        "abstract": "System administrators have unlimited access to system resources. As the Snowden case highlighted, these permissions can be exploited to steal valuable personal, classified, or commercial data. This problem is exacerbated when a third party administers the system. For example, a bank outsourcing its IT would not want to allow administrators access to the actual data. We propose WatchIT: a strategy that constrains IT personnel's view of the system and monitors their actions. To this end, we introduce the abstraction of perforated containers -- while regular Linux containers are too restrictive to be used by system administrators, by \"punching holes\" in them, we strike a balance between information security and required administrative needs. Following the principle of least privilege, our system predicts which system resources should be accessible for handling each IT issue, creates a perforated container with the corresponding isolation, and deploys it as needed for fixing the problem. Under this approach, the system administrator retains superuser privileges, however only within the perforated container limits. We further provide means for the administrator to bypass the isolation, but such operations are monitored and logged for later analysis and anomaly detection. We provide a proof-of-concept implementation of our strategy, which includes software for deploying perforated containers, monitoring mechanisms, and changes to the Linux kernel. Finally, we present a case study conducted on the IT database of IBM Research in Israel, showing that our approach is feasible.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "系统管理员无限制地访问系统资源。 正如Snowden案所强调的那样，可以利用这些权限来窃取宝贵的个人，分类或商业数据。 当第三方管理系统时，此问题会加剧。 例如，将其外包的银行不想允许管理员访问实际数据。 我们提出Watchit：一种策略，限制了IT人员对系统的看法并监视其行为。 为此，我们介绍了穿孔容器的抽象 - 而常规的Linux容器过于限制，无法通过“打孔”中的“打孔”来使用，我们在信息安全和所需的管理需求之间取得了平衡。 遵循最低特权的原则，我们的系统预测应访问哪些系统资源以处理每个IT问题，创建一个带有相应隔离的穿孔容器，并根据需要部署它来解决问题。 在这种方法下，系统管理员保留了超级用户特权，但是仅在穿孔的容器限制内。 我们进一步提供了管理员绕过隔离的手段，但是对此类操作进行监控和记录以进行以后的分析和异常检测。 我们提供了我们策略的概念验证实施，其中包括用于部署穿孔容器，监视机制以及对Linux内核更改的软件。 最后，我们介绍了以色列IBM研究IT数据库进行的案例研究，这表明我们的方法是可行的。",
        "title_zh": "WatchIT:谁监视你的IT人员？",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/mist2016.html",
        "conf_title": "8th MIST@CCS 2016: Vienna, Austria",
        "conf_url": "https://doi.org/10.1145/2995959",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/2976749.2978327",
        "title": "Enforcing Least Privilege Memory Views for Multithreaded Applications",
        "authors": "Terry Ching-Hsiang Hsu, Kevin J. Hoffman, Patrick Eugster, Mathias Payer",
        "abstract": "Failing to properly isolate components in the same address space has resulted in a substantial amount of vulnerabilities. Enforcing the least privilege principle for memory accesses can selectively isolate software components to restrict attack surface and prevent unintended cross-component memory corruption. However, the boundaries and interactions between software components are hard to reason about and existing approaches have failed to stop attackers from exploiting vulnerabilities caused by poor isolation. We present the secure memory views (SMV) model: a practical and efficient model for secure and selective memory isolation in monolithic multithreaded applications. SMV is a third generation privilege separation technique that offers explicit access control of memory and allows concurrent threads within the same process to partially share or fully isolate their memory space in a controlled and parallel manner following application requirements. An evaluation of our prototype in the Linux kernel (TCB < 1,800 LOC) shows negligible runtime performance overhead in real-world applications including Cherokee web server (< 0.69%), Apache httpd web server (< 0.93%), and Mozilla Firefox web browser (< 1.89%) with at most 12 LOC changes.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "在同一地址空间中未能正确隔离组件已经导致了大量漏洞。 为内存访问执行最小特权原则可以选择性地隔离软件组件以限制攻击表面并防止意外的跨组件内存损坏。 但是，软件组件之间的边界和相互作用很难推理，现有方法未能阻止攻击者利用由于隔离不良而引起的脆弱性。 我们介绍了安全的内存视图（SMV）模型：在整体式多线程应用程序中使用安全和选择性内存隔离的实用和高效模型。 SMV是第三代特权分离技术，可提供明确的内存访问控制，并允许在同一过程中并发线程以在应用程序要求下以受控和并行方式部分共享或完全隔离其内存空间。 在Linux内核（TCB <1,800 LOC）中对我们的原型的评估显示，在包括Cherokee Web服务器（<0.69％），Apache HTTPD Web服务器（<0.93％）和Mozilla Firefox Firefox Web Browser在内的真实世界应用程序中可忽略不计的运行时性能开销可忽略不计 （<1.89％）最多12个LOC更改。",
        "title_zh": "为多线程应用程序实施最低特权内存视图",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2016.html",
        "conf_title": "23rd CCS 2016: Vienna, Austria",
        "conf_url": "http://dl.acm.org/citation.cfm?id=2976749",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/2976749.2978403",
        "title": "Twice the Bits, Twice the Trouble: Vulnerabilities Induced by Migrating to 64-Bit Platforms",
        "authors": "Christian Wressnegger, Fabian Yamaguchi, Alwin Maier, Konrad Rieck",
        "abstract": "Subtle flaws in integer computations are a prime source for exploitable vulnerabilities in system code. Unfortunately, even code shown to be secure on one platform can be vulnerable on another, making the migration of code a notable security challenge. In this paper, we provide the first study on how code that works as expected on 32-bit platforms can become vulnerable on 64-bit platforms. To this end, we systematically review the effects of data model changes between platforms. We find that the larger width of integer types and the increased amount of addressable memory introduce previously non-existent vulnerabilities that often lie dormant in program code. We empirically evaluate the prevalence of these flaws on the source code of Debian stable (\"Jessie\") and 200 popular open-source projects hosted on GitHub. Moreover, we discuss 64-bit migration vulnerabilities that have been discovered as part of our study, including vulnerabilities in Chromium, the Boost C++ Libraries, libarchive, the Linux Kernel, and zlib.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "整数计算中的细微缺陷是系统代码中可利用漏洞的主要来源。 不幸的是，即使是在一个平台上显示安全的代码也可能在另一个平台上易受攻击，这使得代码的迁移成为一个显着的安全挑战。 在本文中，我们提供了有关32位平台上预期工作的代码如何在64位平台上变得脆弱的研究。 为此，我们系统地回顾了平台之间数据模型变化的效果。 我们发现，整数类型的宽度较大和可寻址内存的增加量会引入以前不存在的漏洞，这些漏洞通常在程序代码中处于休眠状态。 我们从经验上评估了这些缺陷在Debian Stable（“ Jessie”）和GitHub上举办的200个流行的开源项目中的流行率。 此外，我们讨论了作为我们研究的一部分发现的64位迁移漏洞，包括Chromium中的脆弱性，Boost C ++文库，Libarchive，Linux内核和Zlib。",
        "title_zh": "两倍的位，两倍的麻烦:迁移到64位平台引发的漏洞",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2016.html",
        "conf_title": "23rd CCS 2016: Vienna, Austria",
        "conf_url": "http://dl.acm.org/citation.cfm?id=2976749",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/2976749.2978324",
        "title": "A Software Approach to Defeating Side Channels in Last-Level Caches",
        "authors": "Ziqiao Zhou, Michael K. Reiter, Yinqian Zhang",
        "abstract": "We present a software approach to mitigate access-driven side-channel attacks that leverage last-level caches (LLCs) shared across cores to leak information between security domains (e.g., tenants in a cloud). Our approach dynamically manages physical memory pages shared between security domains to disable sharing of LLC lines, thus preventing \"Flush-Reload\" side channels via LLCs. It also manages cacheability of memory pages to thwart cross-tenant \"Prime-Probe\" attacks in LLCs. We have implemented our approach as a memory management subsystem called CacheBar within the Linux kernel to intervene on such side channels across container boundaries, as containers are a common method for enforcing tenant isolation in Platform-as-a-Service (PaaS) clouds. Through formal verification, principled analysis, and empirical evaluation, we show that CacheBar achieves strong security with small performance overheads for PaaS workloads.",
        "files": {
            "openAccessPdf": "http://dl.acm.org/ft_gateway.cfm?id=2978324&type=pdf"
        },
        "abstract_zh": "我们提出了一种软件方法，以减轻访问驱动的侧通道攻击，该攻击利用了跨核心共享的最后级别缓存（LLC）来泄漏安全域之间的信息（例如，云中的租户）。 我们的方法动态地管理安全域之间共享的物理内存页面，以禁用LLC线的共享，从而防止通过LLCS“齐平雷”侧通道。 它还管理着记忆页的缓存，以阻止LLCS中的跨租户“ Prime-Probe”攻击。 我们已将方法作为一个内存管理子系统在Linux内核中的内存管理子系统，以在容器边界跨容器范围内进行干预，因为容器是在平台-AS-AS-AS-AS-Service（PAAS）云中执行租户隔离的常见方法。 通过正式验证，原则分析和经验评估，我们表明，Cachebar通过较小的PAAS工作负载可实现强大的安全性。",
        "title_zh": "消除末级缓存中旁路的软件方法",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2016.html",
        "conf_title": "23rd CCS 2016: Vienna, Austria",
        "conf_url": "http://dl.acm.org/citation.cfm?id=2976749",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/2976749.2978366",
        "title": "UniSan: Proactive Kernel Memory Initialization to Eliminate Data Leakages",
        "authors": "Kangjie Lu, Chengyu Song, Taesoo Kim, Wenke Lee",
        "abstract": "Operating system kernel is the de facto trusted computing base for most computer systems. To secure the OS kernel, many security mechanisms, e.g., kASLR and StackGuard, have been increasingly deployed to defend against attacks (e.g., code reuse attack). However, the effectiveness of these protections has been proven to be inadequate-there are many information leak vulnerabilities in the kernel to leak the randomized pointer or canary, thus bypassing kASLR and StackGuard. Other sensitive data in the kernel, such as cryptographic keys and file caches, can also be leaked. According to our study, most kernel information leaks are caused by uninitialized data reads. Unfortunately, existing techniques like memory safety enforcements and dynamic access tracking tools are not adequate or efficient enough to mitigate this threat. In this paper, we propose UniSan, a novel, compiler-based approach to eliminate all information leaks caused by uninitialized read in the OS kernel. UniSan achieves this goal using byte-level, flow-sensitive, context-sensitive, and field-sensitive initialization analysis and reachability analysis to check whether an allocation has been fully initialized when it leaves kernel space; if not, it automatically instruments the kernel to initialize this allocation. UniSan's analyses are conservative to avoid false negatives and are robust by preserving the semantics of the OS kernel. We have implemented UniSan as passes in LLVM and applied it to the latest Linux kernel (x86_64) and Android kernel (AArch64). Our evaluation showed that UniSan can successfully prevent 43 known and many new uninitialized data leak vulnerabilities. Further, 19 new vulnerabilities in the latest kernels have been confirmed by Linux and Google. Our extensive performance evaluation with LMBench, ApacheBench, Android benchmarks, and the SPEC benchmarks also showed that UniSan imposes a negligible performance overhead.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "操作系统内核是大多数计算机系统的事实上值得信赖的计算基础。 为了保护OS内核，例如Kaslr和StackGuard的许多安全机制已越来越多地部署以防止攻击（例如，代码重用攻击）。 但是，这些保护的有效性已被证明是不充分的 - 内核中有许多信息泄漏漏洞泄漏随机指针或金丝雀，因此绕过了kaslr和stackguard。 内核中的其他敏感数据（例如加密密钥和文件缓存）也可以泄漏。 根据我们的研究，大多数内核信息泄漏是由非初始化的数据读取引起的。 不幸的是，现有的技术（例如内存安全执行和动态访问跟踪工具）不足或有效地减轻这种威胁。 在本文中，我们提出了Unisan，这是一种基于新颖的编译器方法，以消除OS内核中非初始化读取引起的所有信息泄漏。 Unisan使用字节级，流动敏感，上下文敏感和现场敏感的初始化分析和可及性分析来实现此目标，以检查分配在离开内核空间时是否已完全初始化； 如果没有，它会自动启动内核来初始化此分配。 Unisan的分析是保守的，可以避免虚假负面因素，并通过保留OS内核的语义来稳健。 我们已经在LLVM中实现了Unisan，并将其应用于最新的Linux内核（X86_64）和Android内核（AARCH64）。 我们的评估表明，Unisan可以成功防止43个已知和许多新的非初始化数据泄漏漏洞。 此外，Linux和Google确认了最新内核中的19个新漏洞。 我们对LMBench，Apachebench，Android基准和规格基准的广泛绩效评估也表明，Unisan施加了可忽略不计的开销。",
        "title_zh": "UniSan:主动内核内存初始化以消除数据泄漏",
        "year": "2016",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2016.html",
        "conf_title": "23rd CCS 2016: Vienna, Austria",
        "conf_url": "http://dl.acm.org/citation.cfm?id=2976749",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/2810103.2813691",
        "title": "Timely Rerandomization for Mitigating Memory Disclosures",
        "authors": "David Bigelow, Thomas Hobson, Robert Rudd, William W. Streilein, Hamed Okhravi",
        "abstract": "Address Space Layout Randomization (ASLR) can increase the cost of exploiting memory corruption vulnerabilities. One major weakness of ASLR is that it assumes the secrecy of memory addresses and is thus ineffective in the face of memory disclosure vulnerabilities. Even fine-grained variants of ASLR are shown to be ineffective against memory disclosures. In this paper we present an approach that synchronizes randomization with potential runtime disclosure. By applying rerandomization to the memory layout of a process every time it generates an output, our approach renders disclosures stale by the time they can be used by attackers to hijack control flow. We have developed a fully functioning prototype for x86_64 C programs by extending the Linux kernel, GCC, and the libc dynamic linker. The prototype operates on C source code and recompiles programs with a set of augmented information required to track pointer locations and support runtime rerandomization. Using this augmented information we dynamically relocate code segments and update code pointer values during runtime. Our evaluation on the SPEC CPU2006 benchmark, along with other applications, show that our technique incurs a very low performance overhead (2.1% on average).",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "地址空间布局随机化（ASLR）可以增加利用内存损坏漏洞的成本。 ASLR的一个主要弱点是，它假设了内存地址的保密性，因此面对记忆披露脆弱性，无效。 即使是ASLR的细颗粒变体也被证明对内存披露无效。 在本文中，我们提出了一种将随机化与潜在的运行时披露同步的方法。 通过将重新汇总化应用于过程每次产生输出时的存储器布局，我们的方法在攻击者可以使用时披露陈旧的陈旧，以劫持控制流。 我们通过扩展Linux内核，GCC和LIBC Dynamic Linker为X86_64 C程序开发了功能齐全的原型。 该原型在C源代码和重新编译程序上运行，并具有一组跟踪指针位置所需的增强信息并支持运行时重新汇总化。 使用这些增强信息，我们在运行时动态地重新安置代码段并更新代码指针值。 我们对SPEC CPU2006基准测试的评估以及其他应用程序表明，我们的技术会导致非常低的性能开销（平均为2.1％）。",
        "title_zh": "及时重新随机化以减少内存泄漏",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2015.html",
        "conf_title": "22nd CCS 2015: Denver, CO, USA",
        "conf_url": "http://dl.acm.org/citation.cfm?id=2810103",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/2810103.2813643",
        "title": "Static Detection of Packet Injection Vulnerabilities: A Case for Identifying Attacker-controlled Implicit Information Leaks",
        "authors": "Qi Alfred Chen, Zhiyun Qian, Yunhan Jack Jia, Yuru Shao, Zhuoqing Morley Mao",
        "abstract": "Off-path packet injection attacks are still serious threats to the Internet and network security. In recent years, a number of studies have discovered new variations of packet injection attacks, targeting critical protocols such as TCP. We argue that such recurring problems need a systematic solution. In this paper, we design and implement PacketGuardian, a precise static taint analysis tool that comprehensively checks the packet handling logic of various network protocol implementations. The analysis operates in two steps. First, it identifies the critical paths and constraints that lead to accepting an incoming packet. If paths with weak constraints exist, a vulnerability may be revealed immediately. Otherwise, based on \"secret\" protocol states in the constraints, a subsequent analysis is performed to check whether such states can be leaked to an attacker. In the second step, observing that all previously reported leaks are through implicit flows, our tool supports implicit flow tainting, which is a commonly excluded feature due to high volumes of false alarms caused by it. To address this challenge, we propose the concept of attacker-controlled implicit information leaks, and prioritize our tool to detect them, which effectively reduces false alarms without compromising tool effectiveness. We use PacketGuardian on 6 popular protocol implementations of TCP, SCTP, DCCP, and RTP, and uncover new vulnerabilities in Linux kernel TCP as well as 2 out of 3 RTP implementations. We validate these vulnerabilities and confirm that they are indeed highly exploitable.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "距离分组注射攻击仍然是对互联网和网络安全的严重威胁。 近年来，许多研究发现了针对TCP等关键方案的数据包注射攻击的新变化。 我们认为这种经常性问题需要系统的解决方案。 在本文中，我们设计和实施PacketGuardian，这是一种精确的静态污点分析工具，可全面检查各种网络协议实现的数据包处理逻辑。 分析分为两个步骤。 首先，它标识导致接受传入数据包的关键路径和约束。 如果存在较弱的约束路径，则可以立即揭示漏洞。 否则，基于约束中的“秘密”协议状态，将执行随后的分析以检查是否可以将此类状态泄露给攻击者。 在第二步中，观察所有先前报道的泄漏都是通过隐式流量来的，我们的工具支持隐式流潮，这是由于它引起的大量错误警报，这通常是被排除在外的特征。 为了应对这一挑战，我们提出了攻击者控制的隐式信息泄漏的概念，并优先考虑检测它们的工具，从而在不损害工具效力的情况下有效地降低了错误警报。 我们在TCP，SCTP，DCCP和RTP的6个流行协议实现中使用PacketGuardian，并在Linux内核TCP中发现了新的漏洞，以及3个RTP实现中的2个。 我们验证了这些漏洞，并确认它们确实是高度利用的。",
        "title_zh": "数据包注入漏洞的静态检测:识别攻击者控制的隐含信息泄漏的案例",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2015.html",
        "conf_title": "22nd CCS 2015: Denver, CO, USA",
        "conf_url": "http://dl.acm.org/citation.cfm?id=2810103",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/2810103.2813637",
        "title": "From Collision To Exploitation: Unleashing Use-After-Free Vulnerabilities in Linux Kernel",
        "authors": "Wen Xu, Juanru Li, Junliang Shu, Wenbo Yang, Tianyi Xie, Yuanyuan Zhang, Dawu Gu",
        "abstract": "Since vulnerabilities in Linux kernel are on the increase, attackers have turned their interests into related exploitation techniques. However, compared with numerous researches on exploiting use-after-free vulnerabilities in the user applications, few efforts studied how to exploit use-after-free vulnerabilities in Linux kernel due to the difficulties that mainly come from the uncertainty of the kernel memory layout. Without specific information leakage, attackers could only conduct a blind memory overwriting strategy trying to corrupt the critical part of the kernel, for which the success rate is negligible. In this work, we present a novel memory collision strategy to exploit the use-after-free vulnerabilities in Linux kernel reliably. The insight of our exploit strategy is that a probabilistic memory collision can be constructed according to the widely deployed kernel memory reuse mechanisms, which significantly increases the success rate of the attack. Based on this insight, we present two practical memory collision attacks: An object-based attack that leverages the memory recycling mechanism of the kernel allocator to achieve freed vulnerable object covering, and a physmap-based attack that takes advantage of the overlap between the physmap and the SLAB caches to achieve a more flexible memory manipulation. Our proposed attacks are universal for various Linux kernels of different architectures and could successfully exploit systems with use-after-free vulnerabilities in kernel. Particularly, we achieve privilege escalation on various popular Android devices (kernel version>=4.3) including those with 64-bit processors by exploiting the CVE-2015-3636 use-after-free vulnerability in Linux kernel. To our knowledge, this is the first generic kernel exploit for the latest version of Android. Finally, to defend this kind of memory collision, we propose two corresponding mitigation schemes.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "由于Linux内核中的漏洞正在增加，因此攻击者将他们的兴趣转变为相关的剥削技术。 但是，与在用户应用程序中利用无用的无用漏洞的许多研究相比，很少有努力研究如何利用Linux内核中的无用使用漏洞，因为这主要来自内核内存布局的不确定性。 没有特定的信息泄漏，攻击者只能执行盲目的记忆覆盖策略，试图破坏内核的关键部分，因为成功率可以忽略不计。 在这项工作中，我们提出了一种新颖的记忆碰撞策略，以可靠地利用Linux内核中的无使用漏洞。 我们的利用策略的见解是，可以根据广泛部署的内核内存重用机制来构建概率内存碰撞，从而大大提高了攻击的成功率。 基于这种见解，我们提出了两种实际的内存碰撞攻击：基于对象的攻击，它利用内核分配器的内存回收机制来实现释放的易受伤害的对象覆盖物，以及一种利用Physmap之间重叠的基于物理图的攻击 和平板缓存以实现更灵活的内存操作。 我们提出的攻击对于不同体系结构的各种Linux内核都是通用的，并且可以成功利用内核中使用无用漏洞的系统。 特别是，我们通过利用CVE-2015-3636在Linux内核中利用CVE-2015-3636使用CVE-2015-3636，在各种流行的Android设备（内核版本> 4.3）上实现特权升级。 据我们所知，这是最新版本的Android的第一个通用内核利用。 最后，为了捍卫这种记忆碰撞，我们提出了两个相应的缓解方案。",
        "title_zh": "从冲突到利用:释放Linux内核中的释放后使用漏洞",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2015.html",
        "conf_title": "22nd CCS 2015: Denver, CO, USA",
        "conf_url": "http://dl.acm.org/citation.cfm?id=2810103",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/2810103.2810122",
        "title": "POSTER: PatchGen: Towards Automated Patch Detection and Generation for 1-Day Vulnerabilities",
        "authors": "Tianyue Luo, Chen Ni, Qing Han, Mutian Yang, JingZheng Wu, Yanjun Wu",
        "abstract": "A large fraction of source code in open-source systems such as Linux contain 1-day vulnerabilities. The command \"patch\" is used to apply the patches to source codes, and returns feedback information automatically. Unfortunately, this operation is not always successful when patching directly, and two typical error scenarios may occur as follows. 1. The patch may be applied in wrong place, meaning the fix location should be adjusted in patch. 2. The patch may be applied repeatedly, meaning a verification should be executed before applying. To resolve the above scenarios, we propose PatchGen, a new system to quickly detect and generate patches for 1-day vulnerabilities in OS distributions. Comparing with the previous works on 1-day vulnerabilities detection, PatchGen is able to solve the above two error scenarios and use a quick, syntax-based approach that scales to OS distribution-sized code base no matter the code written in what types of language. We implement the PatchGen prototype, and evaluate it by checking all codes from packages in Ubuntu Maverick/Oneiric, all SourceForge C and C++ projects, and the Linux kernel source. Specifically, it takes less than 10 minutes for PatcheGen to detect 175 1-day vulnerabilities and generate 140 patches for Linux Kernel. All of the results have been manually confirmed and tested in the real systems.",
        "files": {
            "openAccessPdf": "https://hal.inria.fr/hal-01406328/file/Dasip_Conf-2Pages.pdf"
        },
        "abstract_zh": "在诸如Linux之类的开源系统中，很大一部分源代码包含1天的漏洞。 命令“补丁”用于将补丁程序应用于源代码，并自动返回反馈信息。 不幸的是，直接进行修补时，此操作并不总是成功的，并且可能会发生两个典型的错误场景。 1.补丁可以在错误的位置应用，这意味着应在补丁中调整修复位置。 2.可以重复应用补丁，这意味着在应用之前应执行验证。 为了解决上述方案，我们建议PatchGen，这是一个新系统，可以快速检测和生成针对OS分布中1天漏洞的补丁程序。 与先前的1天漏洞检测作品进行比较，PatchGen能够解决上述两个错误方案，并使用基于语法的快速，基于语法的方法，无论是在哪种类型的语言中编写的代码 。 我们实现了PatchGen原型，并通过检查Ubuntu Maverick/Oneiric，所有SourceForge C和C ++项目以及Linux内核源中的所有代码来对其进行评估。 具体而言，Patchegen不到10分钟才能检测175个1天漏洞并为Linux内核生成140个补丁。 所有结果均已在实际系统中手动确认和测试。",
        "title_zh": "海报:PatchGen:面向1天漏洞的自动补丁检测和生成",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/ccs/ccs2015.html",
        "conf_title": "22nd CCS 2015: Denver, CO, USA",
        "conf_url": "http://dl.acm.org/citation.cfm?id=2810103",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3381991.3395396",
        "title": "Analysis of Access Control Enforcement in Android",
        "authors": "William Enck",
        "abstract": "Over the past decade, the Android operating system install-base has proliferated to billions of devices, rivaling Microsoft Windows as a top computing platform. One of the most attractive aspects of Android is its vast collection of applications, available from application stores such as Google's Play Store. Developers have been drawn to Android due to its semantically-rich runtime APIs, which simplify the creation of third-party applications. Many of these APIs provide access to security- and privacy-sensitive information and resources such as the device's geographic location, audio recorded from the device's microphone, and the ability to send and receive SMS messages. In providing these APIs to third-party applications, the Android OS has implicitly taken responsibility for their protection, increasing its access control burden. As a result, current versions of Android have thousands of manually placed access control checks throughout the platform. The goal of this talk is to motivate the need for and utility of semi-automated tools to analyze and validate the access control checks that occur within Android's system code. The challenges are two-fold. First, analysis of Android's middleware code is more challenging than that of third-party applications, which has been studied in-depth over the past decade [3-5]. The code spans hundreds of system services, which are implemented in a combination of Java, C++, and C. The system services also have heavy inter-dependencies with one another, frequently invoking entry points in each other using Android's Binder inter-process communication (IPC) framework within the Linux kernel. Second, identifying what is an access control check is nontrivial. While there are well-known checks based on user-authorized permissions and Linux-layer user and group identifiers, system services also use an array of different service-specific checks that must be captured and modeled to assess the correctness of access control enforcement. In this talk, we will discuss these challenges in the context of two case studies. We will begin by discussing ACMiner [6], a tool designed to assess the correctness of access control checks in Android's middleware using consistency analysis. For each Binder entry point in each system service, ACMiner statically analyzes the code to identify all potential access control checks. To do so, ACMiner uses the names of methods and variables and the values of constant strings used in conditional statements to infer the security-semantics of each check on the control-flow path to instructions that throw a SecurityException. ACMiner then uses association rule mining to identify not only which entry points have inconsistent access control checks, but also to suggest what checks should be added. In applying ACMiner to the Android Open Source Project (AOSP), we found the suggestions to be invaluable when determining whether or not an inconsistency was a vulnerability. Next, we discuss the Android Re-Delegation Finder (ARF) [7]. When designing ACMiner, we optimized our static program analysis by terminating the control-flow analysis of an entry point when the execution reaches another entry point in the same or different system service. Upon further study, we found that entry points frequently call one another, often changing the protection domain of execution when they do (e.g., by explicitly clearing the calling identity, or calling the entry point of a system service executing in a different process). As with most modern operating systems, Android uses deputies (i.e., system services) to safely perform privileged functionality on behalf of third-party applications. Deputies are inherently necessary for the protection of system resources. However, by losing the calling identity, entry points to Android's system services can become confused deputies. ARF builds on the access control policy extracted by ACMiner to identify potential confused deputy vulnerabilities. Neither ACMiner or ARF were designed to eliminate all false positives. In a code-base as vast as Android, it is unrealistic to expect every nuance can be captured programmatically. Instead, ACMiner and ARF were designed to be semi-automated. Our goal is to drastically reduce the amount of time it takes for a security analyst with domain expertise to identify and fix vulnerabilities. Over the course of our research, we have applied our tools to AOSP versions~7, 8, and 9, discovering many vulnerabilities, seven of which have been assigned CVEs by Google. Moving forward, we hope that our tools can be used not only to identify new vulnerabilities, but also to aid regression testing as new versions of Android are released. Both tools have been made open-source and are hosted on Github [1,2].",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3381991.3395396"
        },
        "abstract_zh": "在过去的十年里，Android操作系统的安装基础已经激增到数十亿台设备，作为顶级计算平台与微软Windows相抗衡。Android最吸引人的一个方面是其庞大的应用程序集合，可从应用程序商店(如谷歌的Play Store)获得。由于Android语义丰富的运行时API，简化了第三方应用程序的创建，开发人员已经被它所吸引。其中许多API提供对安全和隐私敏感信息和资源的访问，如设备的地理位置、从设备麦克风录制的音频以及发送和接收SMS消息的能力。在向第三方应用程序提供这些API时，Android操作系统隐含地承担了保护它们的责任，增加了其访问控制负担。因此，当前版本的Android在整个平台上有数以千计的手动访问控制检查。本次演讲的目标是激发半自动工具的需求和效用，以分析和验证Android系统代码中发生的访问控制检查。挑战是双重的。首先，分析Android的中间件代码比分析第三方应用程序更具挑战性，第三方应用程序在过去十年中已经得到了深入研究[3-5]。代码跨越了数百个系统服务，这些服务是用Java、C++和C的组合实现的。系统服务之间也有很强的相互依赖性，经常使用Android的Binder进程间通信(IPC)框架在Linux内核中调用彼此的入口点。第二，识别什么是访问控制检查是很重要的。虽然存在基于用户授权许可和Linux层用户和组标识符的众所周知的检查，但是系统服务还使用一系列不同的特定于服务的检查，必须对这些检查进行捕获和建模，以评估访问控制实施的正确性。在本次讲座中，我们将通过两个案例研究来讨论这些挑战。我们将从讨论ACMiner [6]开始，这是一个使用一致性分析评估Android中间件中访问控制检查正确性的工具。对于每个系统服务中的每个绑定器入口点，ACMiner静态地分析代码，以识别所有潜在的访问控制检查。为此，ACMiner使用方法和变量的名称以及条件语句中使用的常量字符串的值来推断抛出SecurityException的指令的控制流路径上每个检查的安全语义。然后，ACMiner使用关联规则挖掘不仅识别哪些入口点具有不一致的访问控制检查，还建议应该添加哪些检查。在将ACMiner应用于Android开源项目(AOSP)的过程中，我们发现在确定不一致性是否是一个漏洞时，这些建议是非常宝贵的。接下来，我们讨论Android再授权查找器(ARF) [7]。在设计ACMiner时，我们通过在执行到达相同或不同系统服务中的另一个入口点时终止入口点的控制流分析来优化我们的静态程序分析。通过进一步研究，我们发现入口点频繁地相互调用，当它们这样做时，经常改变执行的保护域(例如，通过显式地清除调用标识，或者调用在不同进程中执行的系统服务的入口点)。与大多数现代操作系统一样，Android使用代理(即系统服务)来代表第三方应用程序安全地执行特权功能。副手是保护系统资源的内在需要。然而，由于失去了呼叫身份，Android系统服务的入口点可能会成为困惑的代理。ARF建立在ACMiner提取的访问控制策略的基础上，以识别潜在的混淆代理漏洞。ACMiner和ARF都不是为消除所有假阳性而设计的。在像Android这样庞大的代码库中，期望通过编程来捕捉每一个细微差别是不现实的。相反，ACMiner和ARF被设计成半自动的。我们的目标是大幅减少具有领域专业知识的安全分析师识别和修复漏洞所需的时间。在我们的研究过程中，我们已经将我们的工具应用于AOSP版本7、8和9，发现了许多漏洞，其中七个被Google指定为CVE。展望未来，我们希望我们的工具不仅可以用于识别新的漏洞，还可以在新版本Android发布时帮助回归测试。这两个工具都是开源的，托管在Github上[1，2]。",
        "title_zh": "Android中的访问控制实施分析",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/sacmat/sacmat2020.html",
        "conf_title": "SACMAT 2020: Barcelona, Spain",
        "conf_url": "https://doi.org/10.1145/3381991",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TIFS.2022.3226906",
        "title": "From Release to Rebirth: Exploiting Thanos Objects in Linux Kernel",
        "authors": "Danjun Liu, Pengfei Wang, Xu Zhou, Wei Xie, Gen Zhang, Zhenhao Luo, Tai Yue, Baosheng Wang",
        "abstract": "Vulnerability fixing is time-consuming, hence, not all of the discovered vulnerabilities can be fixed timely. In reality, developers prioritize vulnerability fixing based on exploitability. Large numbers of vulnerabilities are delayed to patch or even ignored as they are regarded as “unexploitable” or underestimated owing to the difficulty in exploiting the weak primitives. However, exploits may have been in the wild. In this paper, to exploit the weak primitives that traditional approaches fail to exploit, we propose a versatile exploitation strategy that can transform weak exploit primitives into strong exploit primitives. Based on a special object in the kernel named Thanos object, our approach can exploit a UAF vulnerability that does not have function pointer dereference and an OOB write vulnerability that has limited write length and value. Our approach overcomes the shortage that traditional exploitation strategies heavily rely on the capability of the vulnerability. To facilitate using Thanos objects, we devise a tool named TAODE to automatically search for eligible Thanos objects from the kernel. Then, it evaluates the usability of the identified Thanos objects by the complexity of the constraints. Finally, it pairs vulnerabilities with eligible Thanos objects. We have evaluated our approach with real-world kernels. TAODE successfully identified numerous Thanos objects from Linux. Using the identified Thanos objects, we proved the feasibility of our approach with 20 real-world vulnerabilities, most of which traditional techniques failed to exploit. Through the experiments, we find that in addition to exploiting weak primitives, our approach can sometimes bypass the kernel SMAP mechanism (CVE-2016-10150, CVE-2016-0728), better utilize the leaked heap pointer address (CVE-2022-25636), and even theoretically break certain vulnerability patches (e.g., double-free).",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "漏洞修复非常耗时，因此，并非所有发现的漏洞都能及时修复。实际上，开发人员根据可利用性来确定漏洞修复的优先级。大量的漏洞被延迟修补甚至被忽略，因为它们被认为是“不可利用的”或者由于难以利用脆弱的原语而被低估。然而，漏洞可能是在野外发现的。在本文中，为了利用传统方法无法利用的弱原语，我们提出了一种通用的利用策略，可以将弱原语转化为强原语。基于内核中名为灭霸对象的特殊对象，我们的方法可以利用没有函数指针解引用的UAF漏洞和具有有限写长度和值的OOB写漏洞。该方法克服了传统利用策略严重依赖漏洞能力的不足。为了方便使用灭霸对象，我们设计了一个名为陶德的工具，从内核中自动搜索符合条件的灭霸对象。然后，通过约束的复杂性来评估所识别的灭霸对象的可用性。最后，它将漏洞与合格的灭霸对象配对。我们已经用真实世界的内核评估了我们的方法。陶德成功地从Linux中识别出许多灭霸对象。使用识别出的灭霸对象，我们用20个真实世界的漏洞证明了我们的方法的可行性，其中大多数是传统技术未能利用的。通过实验，我们发现，除了利用弱原语之外，我们的方法有时可以绕过内核SMAP机制(CVE-2016-10150，CVE-2016-0728)，更好地利用泄露的堆指针地址(CVE-2022-25636)，甚至在理论上打破某些漏洞补丁(例如，双自由)。",
        "title_zh": "从发布到重生:利用Linux内核中的灭霸对象",
        "year": "2023",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/tifs/tifs18.html",
        "conf_title": "IEEE Transactions on Information Forensics and Security, Volume 18",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/TIFS.2018.2883027",
        "title": "Hardware-Assisted Transparent Tracing and Debugging on ARM",
        "authors": "Zhenyu Ning, Fengwei Zhang",
        "abstract": "The existing malware analysis platforms leave detectable fingerprints such as uncommon string properties in QEMU, signatures in Android Java virtual machine, and artifacts in Linux kernel profiles. Since these fingerprints provide the malware a chance to split its behavior depending on whether the analysis system is present or not, the existing analysis systems are not sufficient to analyze the sophisticated malware. In this paper, we propose NINJA, a transparent malware analysis framework on the ARM platform with low artifacts. NINJA leverages a hardware-assisted isolated execution environment TrustZone to transparently trace and debug a target application with the help of performance monitor unit and embedded trace macrocell. These hardware features help NINJA to achieve transparency while avoiding heavy performance overhead. NINJA does not modify system software and is OS-agnostic on the ARM platform. We implement a prototype of NINJA (i.e., tracing and debugging subsystems), and the experimental results show that NINJA is efficient and transparent for malware analysis. An improved fast system restoration mechanism is also designed to facilitate the continuous malware analysis.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "现有的恶意软件分析平台会留下可检测的指纹，例如QEMU中不常见的字符串属性、Android Java虚拟机中的签名以及Linux内核配置文件中的工件。由于这些指纹为恶意软件提供了根据分析系统是否存在来分割其行为的机会，所以现有的分析系统不足以分析复杂的恶意软件。本文提出了NINJA，一个基于ARM平台的透明恶意软件分析框架，具有低伪像。NINJA利用硬件辅助的隔离执行环境TrustZone，在性能监控单元和嵌入式跟踪宏单元的帮助下，透明地跟踪和调试目标应用程序。这些硬件特性有助于NINJA实现透明性，同时避免沉重的性能开销。NINJA不修改系统软件，在ARM平台上与操作系统无关。我们实现了一个NINJA原型(即跟踪和调试子系统)，实验结果表明NINJA对于恶意软件分析是高效和透明的。还设计了一种改进的快速系统恢复机制，以便于持续的恶意软件分析。",
        "title_zh": "ARM上硬件辅助的透明跟踪和调试",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/tifs/tifs14.html",
        "conf_title": "IEEE Transactions on Information Forensics and Security, Volume 14",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1016/j.diin.2018.04.022",
        "title": "Leveraging relocations in ELF-binaries for Linux kernel version identification",
        "authors": "Manish Bhatt, Irfan Ahmed",
        "abstract": "",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "",
        "title_zh": "利用ELF二进制文件中的重定位进行Linux内核版本识别",
        "year": "2018",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/di/di26.html",
        "conf_title": "Digital Investigation, Volume 26 Supplement",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.2478/popets-2020-0012",
        "title": "SqORAM: Read-Optimized Sequential Write-Only Oblivious RAM",
        "authors": "Anrin Chakraborti, Radu Sion",
        "abstract": "Abstract Oblivious RAMs (ORAMs) allow a client to access data from an untrusted storage device without revealing the access patterns. Typically, the ORAM adversary can observe both read and write accesses. Write-only ORAMs target a more practical, multi-snapshot adversary only monitoring client writes – typical for plausible deniability and censorship-resilient systems. This allows write-only ORAMs to achieve significantly-better asymptotic performance. However, these apparent gains do not materialize in real deployments primarily due to the random data placement strategies used to break correlations between logical and physical names-paces, a required property for write access privacy. Random access performs poorly on both rotational disks and SSDs (often increasing wear significantly, and interfering with wear-leveling mechanisms). In this work, we introduce SqORAM, a new locality-preserving write-only ORAM that preserves write access privacy without requiring random data access. Data blocks close to each other in the logical domain land in close proximity on the physical media. Importantly, SqORAM maintains this data locality property over time, significantly increasing read throughput. A full Linux kernel-level implementation of SqORAM is 100x faster than non locality-preserving solutions for standard workloads and is 60-100% faster than the state-of-the-art for typical file system workloads.",
        "files": {
            "openAccessPdf": "http://arxiv.org/pdf/1707.01211"
        },
        "abstract_zh": "摘要不经意内存(ORAMs)允许客户端在不暴露访问模式的情况下从不受信任的存储设备访问数据。通常，ORAM对手可以观察到读写访问。只写ORAMs的目标是更实用的、仅针对对手的多快照监控客户端写入——典型的可信拒绝和审查弹性系统。这允许只写ORAMs实现显著更好的渐近性能。然而，这些明显的好处在实际部署中并没有实现，主要是因为随机数据放置策略用于打破逻辑和物理名称空间之间的相关性，这是写访问隐私的一个必需属性。随机存取在旋转磁盘和固态硬盘上的性能都很差(通常会显著增加磨损，并干扰磨损平衡机制)。在本文中，我们介绍了SqORAM，这是一种新的保持局部性的只写ORAM，它可以在不需要随机数据访问的情况下保持写访问隐私。逻辑域中彼此靠近的数据块在物理介质上的位置非常接近。重要的是，SqORAM会随着时间的推移保持这种数据局部性属性，从而显著提高读取吞吐量。对于标准工作负载，SqORAM的完整Linux内核级实现比非局部保留解决方案快100倍，对于典型文件系统工作负载，比最新技术快60-100%。",
        "title_zh": "SqORAM:读优化的顺序只写不经意RAM",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/popets/popets2020.html",
        "conf_title": "Proceedings on Privacy Enhancing Technologies, Volume 2020",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.2478/popets-2020-0027",
        "title": "Enhanced Performance and Privacy for TLS over TCP Fast Open",
        "authors": "Erik Sy, Tobias Mueller, Christian Burkert, Hannes Federrath, Mathias Fischer",
        "abstract": "Abstract Small TCP flows make up the majority of web flows. For them, the TCP three-way handshake induces significant delay overhead. The TCP Fast Open (TFO) protocol can significantly decrease this delay via zero round-trip time (0-RTT) handshakes for all TCP handshakes that follow a full initial handshake to the same host. However, this comes at the cost of privacy limitations and also has some performance limitations. In this paper, we investigate the TFP deployment on popular websites and browsers. We found that a client revisiting a web site for the first time fails to use an abbreviated TFO handshake in 40% of all cases due to web server load-balancing using multiple IP addresses. Our analysis further reveals significant privacy problems of the protocol design and implementation. Network-based attackers and online trackers can exploit TFO to track the online activities of users. As a countermeasure, we introduce a novel protocol called TCP Fast Open Privacy (FOP). TCP FOP prevents tracking by network attackers and impedes third-party tracking, while still allowing 0-RTT handshakes as in TFO. As a proof-of-concept, we have implemented the proposed protocol for the Linux kernel and a TLS library. Our measurements indicate that TCP FOP outperforms TLS over TFO when websites are served from multiple IP addresses.",
        "files": {
            "openAccessPdf": "http://arxiv.org/pdf/1905.03518"
        },
        "abstract_zh": "摘要小型TCP流构成了web流的大部分。对他们来说，TCP三次握手会导致显著的延迟开销。TCP快速开放(TFO)协议可以通过在与同一主机的完整初始握手之后的所有TCP握手的零往返时间(0-RTT)握手来显著减少这种延迟。然而，这是以隐私限制为代价的，并且也有一些性能限制。在本文中，我们调查了TFP在流行的网站和浏览器上的部署情况。我们发现，由于使用多个IP地址的web服务器负载平衡，第一次访问网站的客户端在40%的情况下无法使用简短的TFO握手。我们的分析进一步揭示了协议设计和实现中的重要隐私问题。基于网络的攻击者和在线跟踪器可以利用TFO来跟踪用户的在线活动。作为对策，我们引入了一种称为TCP快速开放隐私(FOP)的新协议。TCP FOP防止网络攻击者的跟踪，并阻止第三方跟踪，同时仍然允许0-RTT握手，就像在TFO一样。作为概念验证，我们已经为Linux内核和TLS库实现了提议的协议。我们的测量表明，当网站由多个IP地址提供服务时，TCP FOP优于TLS，优于TFO。",
        "title_zh": "TCP上TLS的增强性能和隐私快速开放",
        "year": "2020",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/popets/popets2020.html",
        "conf_title": "Proceedings on Privacy Enhancing Technologies, Volume 2020",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.2478/popets-2019-0071",
        "title": "Detecting TCP/IP Connections via IPID Hash Collisions",
        "authors": "Geoffrey Alexander, Antonio M. Espinoza, Jedidiah R. Crandall",
        "abstract": "Abstract We present a novel attack for detecting the presence of an active TCP connection between a remote Linux server and an arbitrary client machine. The attack takes advantage of side-channels present in the Linux kernel’s handling of the values used to populate an IPv4 packet’s IPID field and applies to kernel versions of 4.0 and higher. We implement and test this attack and evaluate its real world effectiveness and performance when used on active connections to popular web servers. Our evaluation shows that the attack is capable of correctly detecting the IP-port 4-tuple representing an active TCP connection in 84% of our mock attacks. We also demonstrate how the attack can be used by the middle onion router in a Tor circuit to test whether a given client is connected to the guard entry node associated with a given circuit. In addition we discuss the potential issues an attacker would face when attempting to scale it to real world attacks, as well as possible mitigations against the attack. Our attack does not exhaust any global resource, and therefore challenges the notion that there is a direct one-to-one connection between shared, limited resources and non-trivial network side-channels. This means that simply enumerating global shared resources and considering the ways in which they can be exhausted will not suffice for certifying a kernel TCP/IP network stack to be free of privacy risk side-channels.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "摘要我们提出了一种新的攻击方法，用于检测远程Linux服务器和任意客户机之间的活动TCP连接的存在。该攻击利用了Linux内核在处理用于填充IPv4数据包的IPID字段的值时存在的旁路，适用于4.0及更高版本的内核。我们实现并测试了这种攻击，并评估了它在与流行的web服务器进行活动连接时的实际效果和性能。我们的评估表明，在84%的模拟攻击中，该攻击能够正确地检测到代表活动TCP连接的IP端口4元组。我们还演示了Tor电路中的中间洋葱路由器如何利用该攻击来测试给定客户端是否连接到与给定电路相关联的防护入口节点。此外，我们还讨论了攻击者在尝试将其扩展到现实世界攻击时可能面临的问题，以及针对攻击的可能缓解措施。我们的攻击没有耗尽任何全局资源，因此挑战了在共享的有限资源和非平凡的网络侧信道之间存在直接一对一连接的概念。这意味着简单地列举全局共享资源并考虑它们被耗尽的方式不足以证明内核TCP/IP网络栈没有隐私风险旁路。",
        "title_zh": "通过IPID哈希冲突检测TCP/IP连接",
        "year": "2019",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/popets/popets2019.html",
        "conf_title": "Proceedings on Privacy Enhancing Technologies, Volume 2019",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1515/popets-2015-0005",
        "title": "Analyzing the Great Firewall of China Over Space and Time",
        "authors": "Roya Ensafi, Philipp Winter, Abdullah Mueen, Jedidiah R. Crandall",
        "abstract": "Abstract A nation-scale firewall, colloquially referred to as the “Great Firewall of China,” implements many different types of censorship and content filtering to control China’s Internet traffic. Past work has shown that the firewall occasionally fails. In other words, sometimes clients in China are able to reach blacklisted servers outside of China. This phenomenon has not yet been characterized because it is infeasible to find a large and geographically diverse set of clients in China from which to test connectivity. In this paper, we overcome this challenge by using a hybrid idle scan technique that is able to measure connectivity between a remote client and an arbitrary server, neither of which are under the control of the researcher performing measurements. In addition to hybrid idle scans, we present and employ a novel side channel in the Linux kernel’s SYN backlog. We show that both techniques are practical by measuring the reachability of the Tor network which is known to be blocked in China. Our measurements reveal that failures in the firewall occur throughout the entire country without any conspicuous geographical patterns.We give some evidence that routing plays a role, but other factors (such as how the GFW maintains its list of IP/port pairs to block) may also be important.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "摘要一个民族规模的防火墙，被称为“中国的大防火墙”，实施了许多不同类型的审查制度和内容过滤，以控制中国的互联网流量。 过去的工作表明，防火墙有时会失败。 换句话说，有时中国的客户能够接触到中国以外的黑名单服务器。 这种现象尚未得到特征，因为在中国找到一组大量且地理上多样化的客户来测试连通性是不可行的。 在本文中，我们通过使用能够衡量远程客户端和任意服务器之间的连接性的混合闲置扫描技术来克服这一挑战，而这些服务器都没有在研究人员的控制下进行测量。 除了混合闲置扫描外，我们还在Linux内核SYN积压列表中介绍并采用了一个新颖的侧渠道。 我们表明，通过测量已知在中国被阻止的TOR网络的可及性，这两种技术都是实用的。 我们的测量结果表明，防火墙的故障在整个国家发生，没有任何明显的地理模式。我们给出一些证据表明路由起着作用，但其他因素（例如，GFW如何保持其IP/端口对列表的方式）可能可能会阻止）。 也很重要。",
        "title_zh": "时空视角下的中国防火墙探析",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/popets/popets2015.html",
        "conf_title": "Proceedings on Privacy Enhancing Technologies, Volume 2015",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3485832.3488011",
        "title": "VIA: Analyzing Device Interfaces of Protected Virtual Machines",
        "authors": "Felicitas Hetzelt, Martin Radev, Robert Buhren, Mathias Morbitzer, Jean-Pierre Seifert",
        "abstract": "Both AMD and Intel have presented technologies for confidential computing in cloud environments. The proposed solutions — AMD SEV (-ES, -SNP) and Intel TDX — protect VMs (VMs) against attacks from higher privileged layers through memory encryption and integrity protection. This model of computation draws a new trust boundary between virtual devices and the VM, which in so far lacks thorough examination. In this paper, we therefore present an analysis of the virtual device interface and discuss several attack vectors against a protected VM. Further, we develop and evaluate VIA, an automated analysis tool to detect cases of improper sanitization of input recieved via the virtual device interface. VIA improves upon existing approaches for the automated analysis of device interfaces in the following aspects: (i) support for virtualization relevant buses, (ii) efficient Direct Memory Access (DMA) support and (iii) performance. VIA builds upon the Linux Kernel Library and clang’s libfuzzer to fuzz the communication between the driver and the device via MMIO, PIO, and DMA. An evaluation of VIA shows that it performs 570 executions per second on average and improves performance compared to existing approaches by an average factor of 2706. Using VIA, we analyzed 22 drivers in Linux 5.10.0-rc6, thereby uncovering 50 bugs and initiating multiple patches to the virtual device driver interface of Linux. To prove our findings’ criticality under the threat model of AMD SEV and Intel TDX, we showcase three exemplary attacks based on the bugs found. The attacks enable a malicious hypervisor to corrupt the memory and gain code execution in protected VMs with SEV-ES and are theoretically applicable to SEV-SNP and TDX.",
        "files": {
            "openAccessPdf": "http://arxiv.org/pdf/2109.10660"
        },
        "abstract_zh": "AMD和英特尔都展示了在云环境中进行保密计算的技术。AMD SEV (-ES，-SNP)和英特尔TDX提出的解决方案通过内存加密和完整性保护来保护虚拟机(VM)免受来自更高特权层的攻击。这种计算模型在虚拟设备和虚拟机之间画出了一个新的信任边界，到目前为止还缺乏彻底的检查。因此，在本文中，我们对虚拟设备接口进行了分析，并讨论了针对受保护虚拟机的几种攻击手段。此外，我们还开发和评估了VIA，这是一款自动分析工具，用于检测通过虚拟设备接口接收的输入处理不当的情况。VIA在以下方面改进了现有的设备接口自动分析方法:(I)对虚拟化相关总线的支持，(ii)高效的直接存储器访问(DMA)支持，以及(iii)性能。VIA构建于Linux内核库和clang的libfuzzer之上，通过MMIO、PIO和DMA来模糊驱动程序和设备之间的通信。对VIA的评估表明，它平均每秒执行570次，与现有方法相比，性能平均提高了2706倍。使用VIA，我们分析了Linux 5.10.0-rc6中的22个驱动程序，从而发现了50个错误，并启动了对Linux的虚拟设备驱动程序接口的多个补丁。为了证明我们的发现在AMD SEV和英特尔TDX的威胁模型下的重要性，我们展示了基于所发现的漏洞的三个示例性攻击。这些攻击使恶意虚拟机管理程序能够破坏内存，并在带有服务的受保护虚拟机中执行代码，理论上适用于服务单端口和TDX。",
        "title_zh": "通过：分析受保护虚拟机的设备界面",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/acsac/acsac2021.html",
        "conf_title": "ACSAC 2021: Virtual Event, USA",
        "conf_url": "https://doi.org/10.1145/3485832",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3485832.3488019",
        "title": "FlexFilt: Towards Flexible Instruction Filtering for Security",
        "authors": "Leila Delshadtehrani, Sadullah Canakci, William Blair, Manuel Egele, Ajay Joshi",
        "abstract": "As the complexity of software applications increases, there has been a growing demand for intra-process memory isolation. The commercially available intra-process memory isolation mechanisms in modern processors, e.g., Intel’s memory protection keys, trade-off between efficiency and security guarantees. Recently, researchers have tended to leverage the features with low security guarantees for intra-process memory isolation. Subsequently, they have relied on binary scanning and runtime binary rewriting to prevent the execution of unsafe instructions, which improves the security guarantees. Such intra-process memory isolation mechanisms are not the only security solutions that have to prevent the execution of unsafe instructions in untrusted parts of the code. In fact, we identify a similar requirement in a variety of other security solutions. Although binary scanning and runtime binary rewriting approaches can be leveraged to address this requirement, it is challenging to efficiently implement these approaches. In this paper, we propose an efficient and flexible hardware-assisted feature for runtime filtering of user-specified instructions. This flexible feature, called FlexFilt, assists with securing various isolation-based mechanisms. FlexFilt enables the software developer to create up to 16 instruction domains, where each instruction domain can be configured to filter the execution of user-specified instructions. In addition to filtering unprivileged instructions, FlexFilt is capable of filtering privileged instructions. To illustrate the effectiveness of FlexFilt compared to binary scanning approaches, we measure the overhead caused by scanning the JIT compiled code while browsing various webpages. We demonstrate the feasibility of FlexFilt by implementing our design on the RISC-V Rocket core, providing the Linux kernel support for it, and prototyping our full design on an FPGA.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "随着软件应用程序复杂性的增加，对进程内内存隔离的需求也在不断增长。现代处理器中的商用进程内存储器隔离机制，例如Intel的存储器保护密钥，在效率和安全性保证之间进行权衡。最近，研究人员倾向于利用安全性保证较低的特性来实现进程内内存隔离。随后，他们依靠二进制扫描和运行时二进制重写来防止不安全指令的执行，这提高了安全性保证。这种进程内存储器隔离机制并不是防止在不可信代码部分执行不安全指令的唯一安全解决方案。事实上，我们在各种其他安全解决方案中发现了类似的需求。尽管可以利用二进制扫描和运行时二进制重写方法来满足这一需求，但是有效地实现这些方法是具有挑战性的。在这篇文章中，我们提出了一个有效和灵活的硬件辅助功能，用于运行时过滤用户指定的指令。这种称为FlexFilt的灵活特性有助于保护各种基于隔离的机制。FlexFilt使软件开发人员能够创建多达16个指令域，其中每个指令域都可以配置为过滤用户指定指令的执行。除了过滤非特权指令，FlexFilt还能够过滤特权指令。为了说明与二进制扫描方法相比FlexFilt的有效性，我们测量了在浏览各种网页时扫描JIT编译的代码所导致的开销。我们通过在RISC-V Rocket core上实现我们的设计，为其提供Linux内核支持，并在FPGA上原型化我们的完整设计，展示了FlexFilt的可行性。",
        "title_zh": "弹性：促进灵活的说明过滤以进行安全性",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/acsac/acsac2021.html",
        "conf_title": "ACSAC 2021: Virtual Event, USA",
        "conf_url": "https://doi.org/10.1145/3485832",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3564625.3564634",
        "title": "Making Memory Account Accountable: Analyzing and Detecting Memory Missing-account bugs for Container Platforms",
        "authors": "Yutian Yang, Wenbo Shen, Xun Xie, Kangjie Lu, Mingsen Wang, Tianyu Zhou, Chenggang Qin, Wang Yu, Kui Ren",
        "abstract": "Linux kernel introduces the memory control group (memcg) to account and confine memory usage at the process-level. Due to its flexibility and efficiency, memcg has been widely adopted by container platforms and has become a fundamental technique. While being critical, memory accounting is prone to missing-account bugs due to the diverse memory accounting interfaces and the massive amount of allocation/free paths. To our knowledge, there is still no systematic analysis against the memory missing-account problem, with respect to its security impacts, detection, etc. In this paper, we present the first systematic study on the memory missing-account problem. We first perform an in-depth analysis of its exploitability and security impacts on container platforms. We then develop a tool named MANTA (short for Memory AccouNTing Analyzer), which combines both static and dynamic analysis techniques to detect and validate memory missing-account bugs automatically. Our analysis shows that all container runtimes, including runC and Kata container, are vulnerable to memory missing-account-based attacks. Moreover, memory missing-account can be exploited to attack the Docker, the CaaS, and the FaaS platforms, leading to memory exhaustion, which crashes individual node or even the whole cluster. Our tool reports 53 exploitable memory missing-account bugs, 37 of which were confirmed by kernel developers with the corresponding patches submitted, and two new CVEs are assigned. Through the in-depth analysis, automated detection, the reported bugs and the submitted patches, we believe our research improves the correctness and security of memory accounting for container platforms.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "Linux内核引入了内存控制组(memcg)来在进程级计算和限制内存使用。由于其灵活性和效率，memcg已经被容器平台广泛采用，并成为一种基本技术。虽然内存核算很重要，但由于内存核算接口的多样性和大量的分配/空闲路径，内存核算容易出现帐户缺失错误。据我们所知，目前还没有针对内存丢失帐户问题的系统分析，包括其安全影响、检测等。本文首次系统地研究了记忆缺失问题。我们首先对其可利用性和对容器平台的安全影响进行了深入分析。然后，我们开发了一个名为MANTA(内存核算分析器的缩写)的工具，它结合了静态和动态分析技术来自动检测和验证内存丢失帐户错误。我们的分析表明，所有容器运行时，包括runC和Kata容器，都容易受到基于内存缺失帐户的攻击。此外，可以利用内存缺失帐户来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而使单个节点甚至整个集群崩溃。我们的工具报告了53个可利用的内存缺失帐户错误，其中37个已由内核开发人员通过提交相应的补丁进行了确认，并分配了两个新的CVE。通过深入分析、自动检测、报告的错误和提交的补丁，我们相信我们的研究提高了容器平台内存核算的正确性和安全性。",
        "title_zh": "使内存帐户负责：分析和检测容器平台的内存丢失符合错误",
        "year": "2022",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/acsac/acsac2022.html",
        "conf_title": "ACSAC 2022: Austin, TX, USA",
        "conf_url": "https://doi.org/10.1145/3564625",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/2818000.2818046",
        "title": "MobiPluto: File System Friendly Deniable Storage for Mobile Devices",
        "authors": "Bing Chang, Zhan Wang, Bo Chen, Fengwei Zhang",
        "abstract": "Mobile devices are prevalently used for processing personal private data and sometimes collecting evidence of social injustice or political oppression. The device owners may always feel reluctant to expose this type of data to undesired observers or inspectors. This usually can be achieved by encryption. However, the traditional encryption may not work when an adversary is able to coerce device owners into revealing their encrypted content. Plausibly Deniable Encryption (PDE) is thus designed to protect sensitive data against this type of powerful adversaries. In this paper, we present MobiPluto, a file system friendly PDE scheme for denying the existence of sensitive data stored on mobile devices. MobiPluto achieves deniability feature as nothing but a \"side-effect\" of combining thin provisioning, a well-established tool in Linux kernel, with encryption. This feature makes MobiPluto more plausible for users to have such software on their mobile devices. A salient difference between MobiPluto and the existing PDE schemes is that MobiPluto is \"file system friendly\", i.e., any block-based file systems can be deployed on top of it. Thus, it is possible to deploy MobiPluto on most mobile devices. We provide a proof-of-concept implementation for MobiPluto in an Android phone to assess its feasibility and performance.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "移动设备普遍用于处理个人隐私数据，有时还用于收集社会不公或政治压迫的证据。设备所有者可能总是不愿意将这种类型的数据暴露给不受欢迎的观察者或检查员。这通常可以通过加密来实现。然而，当对手能够强迫设备所有者透露他们的加密内容时，传统的加密可能不起作用。因此，似是而非的可否认加密(PDE)旨在保护敏感数据免受这类强大对手的攻击。在本文中，我们提出了MobiPluto，一个文件系统友好的PDE方案，用于否认存储在移动设备上的敏感数据的存在。MobiPluto实现可否认性特性不过是将精简配置(Linux内核中一个成熟的工具)与加密相结合的“副作用”。这个特性使得MobiPluto更有可能让用户在他们的移动设备上安装这样的软件。mobi luto和现有PDE方案之间的一个显著区别是mobi luto是“文件系统友好的”，即任何基于块的文件系统都可以部署在它上面。因此，在大多数移动设备上部署MobiPluto是可能的。我们提供了一个在Android手机中实现MobiPluto的概念验证，以评估其可行性和性能。",
        "title_zh": "Mobipluto：文件系统友好的移动设备存储",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/acsac/acsac2015.html",
        "conf_title": "31. ACSAC 2015: Los Angeles, CA, USA",
        "conf_url": "http://dl.acm.org/citation.cfm?id=2818000",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1108/ICS-02-2014-0013",
        "title": "Logical acquisition and analysis of data from android mobile devices",
        "authors": "Himanshu Srivastava, Shashikala Tapaswi",
        "abstract": "Purpose – The purpose of this paper is to propose an approach that helps in acquisition of live data as well as data stored in the internal/external memory of android mobile device considering that the data on the device are not much altered during the extraction process. Also, the emphasis is laid on testing the validity of existing forensic tools against the data obtained manually and by using this approach. Smartphones have spurred the mobile computing technology, and Android is widely used as an Operating System in these devices. These days, users store most of their personal information like emails, images, contacts etc., on Phones/Tablets as their data would be readily accessible and thus convenient for them. Design/methodology/approach – Android Operating System is built on the Linux Kernel and scripts to extract data from Android Mobile Device with the use of Android Debugging Bridge have been written. The approach is more focused on the logical acquisition of data from devices rather than acquisi...",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "目的–考虑到设备上的数据在提取过程中不会发生太大变化，本文的目的是提出一种有助于获取实时数据以及存储在android移动设备内部/外部存储器中的数据的方法。此外，重点放在根据手动获取的数据和使用这种方法获取的数据测试现有取证工具的有效性。智能手机推动了移动计算技术的发展，Android作为操作系统被广泛应用于这些设备中。如今，用户存储大部分个人信息，如电子邮件、图像、联系人等。在手机/平板电脑上，因为他们的数据很容易访问，因此对他们来说很方便。设计/方法/途径——Android操作系统建立在Linux内核上，使用Android调试桥从Android移动设备提取数据的脚本已经编写完成。这种方法更侧重于从设备中逻辑地获取数据，而不是...",
        "title_zh": "从android移动设备逻辑采集和分析数据",
        "year": "2015",
        "dblp_url": "https://dblp.uni-trier.de/db/journals/imcs/imcs23.html",
        "conf_title": "Information and Computer Security, Volume 23",
        "conf_url": "",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1145/3471621.3471839",
        "title": "μSCOPE: A Methodology for Analyzing Least-Privilege Compartmentalization in Large Software Artifacts",
        "authors": "Nick Roessler, Lucas Atayde, Imani Palmer, Derrick Paul McKee, Jai Pandey, Vasileios P. Kemerlis, Mathias Payer, Adam Bates, Jonathan M. Smith, André DeHon, Nathan Dautenhahn",
        "abstract": "By prioritizing simplicity and portability, least-privilege engineering has been an afterthought in OS design, resulting in monolithic kernels where any exploit leads to total compromise. μSCOPE (“microscope”) addresses this problem by automatically identifying opportunities for least-privilege separation. μSCOPE replaces expert-driven, semi-automated analysis with a general methodology for exploring a continuum of security vs. performance design points by adopting a quantitative and systematic approach to privilege analysis. We apply the μSCOPE methodology to the Linux kernel by (1) instrumenting the entire kernel to gain comprehensive, fine-grained memory access and call activity; (2) mapping these accesses to semantic information; and (3) conducting separability analysis on the kernel using both quantitative privilege and overhead metrics. We discover opportunities for orders of magnitude privilege reduction while predicting relatively low overheads—at 15% mediation overhead, overprivilege in Linux can be reduced up to 99.8%—suggesting fine-grained privilege separation is feasible and laying the groundwork for accelerating real privilege separation.",
        "files": {
            "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3471621.3471839"
        },
        "abstract_zh": "通过优先考虑简单性和可移植性，最低特权工程已经成为OS设计中的一个事后想法，导致了单片内核，其中任何利用都会导致全面的危害。μSCOPE(“显微镜”)通过自动识别最低权限分离的机会来解决这个问题。μSCOPE通过采用量化和系统化的方法进行权限分析，用一种通用方法取代专家驱动的半自动分析，探索安全性与性能设计点的连续性。我们通过以下方式将μSCOPE方法应用于Linux内核:( 1)检测整个内核以获得全面、细粒度的内存访问和调用活动；(2)将这些访问映射到语义信息；以及(3)使用定量特权和开销度量对内核进行可分离性分析。我们发现了数量级特权减少的机会，同时预测相对较低的开销—在15%的中介开销下，Linux中的过度特权可以减少高达99.8%—这表明细粒度的特权分离是可行的，并为加速真正的特权分离奠定了基础。",
        "title_zh": "μSCOPE:一种分析大型软件工件中最小特权划分的方法",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/raid/raid2021.html",
        "conf_title": "24th RAID 2021: San Sebastian, Spain",
        "conf_url": "https://doi.org/10.1145/3471621",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/EuroSPW54576.2021.00014",
        "title": "FlushBlocker: Lightweight mitigating mechanism for CPU cache flush instruction based attacks",
        "authors": "Shuhei Enomoto, Hiroki Kuzuno",
        "abstract": "CPU cache flush instruction based attacks (cache instruction attacks) such as FLUSH+RELOAD can function in many environments. Meltdown and Spectre adopt FLUSH+RELOAD with cache instructions to access secret data. Additionally, Rowhammer employs cache instructions to modify data in physical memory. An adversary can read and write arbitrary data using these attacks. The deployment of corresponding hardware to combat these attacks is difficult for users, and existing software-based countermeasures incur high overheads, or cannot be applied to a variety of machines. In this study, we propose a novel mitigation mechanism for cache instruction attacks called FlushBlocker, which employs an effective approach that focuses on restricting cache flush instructions. We implemented FlushBlocker on the latest Linux kernel to conduct experiments. The experimental results indicate that FlushBlocker prevents existing cache instruction attacks and runtime overhead is negligible.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "基于CPU缓存刷新指令的攻击(缓存指令攻击)，如刷新+重新加载，可以在许多环境中起作用。Meltdown和Spectre采用带缓存指令的FLUSH+RELOAD来访问秘密数据。此外，Rowhammer使用缓存指令来修改物理内存中的数据。对手可以利用这些攻击读写任意数据。部署相应的硬件来对抗这些攻击对用户来说是困难的，并且现有的基于软件的对策招致高开销，或者不能应用于各种机器。在这项研究中，我们提出了一种新的缓存指令攻击缓解机制，称为FlushBlocker，它采用了一种有效的方法来限制缓存刷新指令。我们在最新的Linux内核上实现了FlushBlocker进行实验。实验结果表明，FlushBlocker可以防止现有的缓存指令攻击，并且运行时开销可以忽略不计。",
        "title_zh": "FlushBlocker:针对基于CPU缓存刷新指令的攻击的轻量级缓解机制",
        "year": "2021",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/eurosp/eurosp2021w.html",
        "conf_title": "EuroS&P 2021: Vienna, Austria - Workshops",
        "conf_url": "https://doi.org/10.1109/EuroSPW54576.2021",
        "keywords": [
            "Linux Kernel"
        ]
    },
    {
        "url": "https://doi.org/10.1109/EuroSP.2018.00019",
        "title": "Eraser: Your Data Won't Be Back",
        "authors": "Kaan Onarlioglu, William K. Robertson, Engin Kirda",
        "abstract": "Secure deletion of data from non-volatile storage is a well-recognized problem. While numerous solutions have been proposed, advances in storage technologies have stymied efforts to solve the problem. For instance, SSDs make use of techniques such as wear leveling that involve replication of data; this is in direct opposition to efforts to securely delete sensitive data from storage. We present a technique to provide secure deletion guarantees at file granularity, independent of the characteristics of the underlying storage medium. The approach builds on prior seminal work on cryptographic erasure, encrypting every file on an insecure medium with a unique key that can later be discarded to cryptographically render the data irrecoverable. To make the approach scalable and, therefore, usable on commodity systems, keys are organized in an efficient tree structure where a single master key is confined to a secure store. We describe an implementation of this scheme as a fileaware stackable block device, deployed as a standalone Linux kernel module that does not require modifications to the operating system. Our prototype demonstrates that secure deletion independent of the underlying storage medium can be achieved with comparable overhead to existing full disk encryption implementations.",
        "files": {
            "openAccessPdf": ""
        },
        "abstract_zh": "从非易失性存储器中安全删除数据是一个众所周知的问题。虽然已经提出了许多解决方案，但是存储技术的进步阻碍了解决该问题的努力。例如，固态硬盘利用了损耗均衡等涉及数据复制的技术；这与从存储中安全删除敏感数据的努力形成了鲜明对比。我们提出了一种在文件粒度上提供安全删除保证的技术，它与底层存储介质的特性无关。这种方法建立在先前关于加密擦除的开创性工作的基础上，用唯一的密钥对不安全介质上的每个文件进行加密，该密钥可以在以后被丢弃，从而以加密方式使数据不可恢复。为了使这种方法具有可伸缩性，从而可以在商用系统上使用，密钥被组织在一个有效的树结构中，其中一个主密钥被限制在一个安全的存储中。我们将此方案的实现描述为文件感知可堆叠块设备，作为独立的Linux内核模块部署，不需要对操作系统进行修改。我们的原型表明，独立于底层存储介质的安全删除可以以与现有的全磁盘加密实现相当的开销来实现。",
        "title_zh": "橡皮擦:你的数据不会回来",
        "year": "2018",
        "dblp_url": "https://dblp.uni-trier.de/db/conf/eurosp/eurosp2018.html",
        "conf_title": "EuroS&P 2018: London, UK",
        "conf_url": "https://ieeexplore.ieee.org/xpl/conhome/8405665/proceeding",
        "keywords": [
            "Linux Kernel"
        ]
    }
]